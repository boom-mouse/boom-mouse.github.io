<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>FISCO table表使用</title>
    <link href="/2024/12/28/FISCO%20table/"/>
    <url>/2024/12/28/FISCO%20table/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>fico Table.sol提供了CRUD接口用于直接访问底层的存储表</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>在节点控制台中的合约仓库中，可以添加<code>Table.sol</code>到IDE<br>引用Table.sol</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">import &quot;Table.sol&quot;;<br></code></pre></td></tr></table></figure><p>Table.sol的接口包括：</p><ul><li>createTable :创建表</li><li>select(string, Condition): 查询数据</li><li>insert(string, Entry): 插入数据</li><li>update(string, Entry, Condition): 更新数据</li><li>remove(string, Condition): 删除数据</li></ul><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// TableFactory的地址固定为0x1001<br>TableFactory tf = TableFactory(0x1001);<br><br>int count = tf.createTable(&quot;table_name&quot;, &quot;key_name&quot;, &quot;item_1,item_2&quot;);<br>if (count == 0) &#123;<br>    // success<br>&#125;<br></code></pre></td></tr></table></figure><p>解释：</p><ul><li><p><code>TableFactory(0x1001)</code>:<br>  <code>TableFactory</code>合约默认地址为<code>0x1001</code></p></li><li><p><code>table_name</code>:<br>  创建的表的表名</p></li><li><p><code>key_name</code>:<br>  表的主键名，在Table中，可以有多个相同主键</p></li><li><p><code>item_1,item_2</code>:<br>  表的字段名，用逗号分隔</p></li><li><p><code>count</code>:<br>  <code>createTable</code>会返回状态码，为0则创建成功，状态码如下：</p><table><thead><tr><th>错误码</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>创建成功</td></tr><tr><td>-50000</td><td>用户没有权限</td></tr><tr><td>-50001</td><td>创建表名已存在</td></tr><tr><td>-50002</td><td>表名超过48字符</td></tr><tr><td>-50003</td><td>valueField长度超过64字符</td></tr><tr><td>-50004</td><td>valueField总长度超过1024字符</td></tr><tr><td>-50005</td><td>keyField长度超过64字符</td></tr><tr><td>-50007</td><td>存在重复字段</td></tr><tr><td>-50007</td><td>字段存在非法字符</td></tr><tr><td>其他</td><td>创建时遇到的其他错误</td></tr></tbody></table></li></ul><h2 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">TableFactory tf = TableFactory(0x1001);<br>Table table = tf.openTable(&quot;table_name&quot;);<br><br>if(table == address(0x0)) &#123;<br>    // error<br>&#125;<br></code></pre></td></tr></table></figure><p>解释：</p><ul><li><code>tf.openTable(&quot;table_name&quot;)</code>:<br>  <code>table_name</code>为表名，返回<code>table_name</code>的地址，如果<code>address(0x0)</code>则表示打开失败</li></ul><h2 id="插入行"><a href="#插入行" class="headerlink" title="插入行"></a>插入行</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs solidity">TableFactory tf = TableFactory(0x1001);<br>Table table = tf.openTable(&quot;table_name&quot;);<br><br>// 新建行<br>Entry entry = table.newEntry();<br>// 设置字段值<br>entry.set(&quot;item_1&quot;,&quot;1&quot;);<br>entry.set(&quot;item_2&quot;,&quot;2&quot;);<br>// 将行插入到表中，主键设为key1<br>int count = table.insert(&quot;key1&quot;, entry);<br><br>if (count == 1) &#123;<br>    // success<br>&#125;<br></code></pre></td></tr></table></figure><p>解释：</p><ul><li><code>Entry</code>:<br>  <code>Entry</code>表示一行，<code>table.newEntry</code>用于新建一个<code>table</code>表对应的行</li><li><code>set</code>:<br>  用于设置行的字段，第一个参数为字段名，第二个参数为字值，字段值支持<code>int string address</code></li><li><code>insert</code>:<br>  用于将行插入到表中，第一个参数为插入行的主键值，第二参数为待插入的行对象</li><li><code>count</code>:<br>  <code>insert</code>返回值表示 “受影响的行数” 为1说明插入成功</li></ul><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs solidity">TableFactory tf = TableFactory(0x1001);<br>Table table = tf.openTable(&quot;table_name&quot;);<br>if(table == address(0x0)) &#123;<br>    // error<br>&#125;<br><br>// 新建筛选条件对象<br>Condition condition = table.newCondition();<br>// 筛选出符合条件的行<br>Entries entries = table.select(&quot;key1&quot;, condition);<br><br>// 新建数据，存储数据，根据字段选择数组类型<br>bytes32[] string_item_list = new bytes32[];<br>int256[]  int_item_list = new int256[];<br><br>// 获得行数<br>int size = entries.size();<br>// 便利每行，将对应数据放入数组<br>for (int i = 0; i &lt; size; i++) &#123;<br>    // 获取查询结果的第i行<br>    Entry entry = entries.get(i);<br>    // 获取i行的item_1字段，以Bytes32的形式读取<br>    string_item_list[uint256(i)] = entry.getBytes32(&quot;item_1&quot;);<br>    // 获取i行的item_1字段，以int的形式读取<br>    int_item_list[uint256(i)] = entry.getInt(&quot;item_2&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><p>解释：</p><ul><li><p><code>Entries</code>:<br>  <code>Entry</code>的复数，表示多行的集合</p></li><li><p><code>Condition</code>:<br>  过滤条件对象，可以通过它的子方法添加过滤条件，<code>condition.EQ(&quot;item_1&quot;,&quot;1&quot;)</code>表示筛选条件为 字段item_值 为 1的行，条件可以设置多个</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs solidity">condition.EQ(&quot;item_1&quot;,&quot;1&quot;);<br>condition.EQ(&quot;item_1&quot;,&quot;2&quot;);<br></code></pre></td></tr></table></figure><table><thead><tr><th>接口</th><th>功能</th><th>参数</th></tr></thead><tbody><tr><td>EQ(string, int)</td><td>相等条件</td><td>字段名，字段值</td></tr><tr><td>EQ(string, string)</td><td>相等条件</td><td>字段名，字段值</td></tr><tr><td>NE(string, int)</td><td>不等条件</td><td>字段名，字段值</td></tr><tr><td>NE(string, string)</td><td>不等条件</td><td>字段名，字段值</td></tr><tr><td>GT(string, int)</td><td>大于条件</td><td>字段名，字段值</td></tr><tr><td>GE(string, int)</td><td>大于或等于条件</td><td>字段名，字段值</td></tr><tr><td>LT(string, int)</td><td>小于条件</td><td>字段名，字段值</td></tr><tr><td>LE(string, int)</td><td>小于或等于条件</td><td>字段名，字段值</td></tr><tr><td>limit(int)</td><td>记录选取条件</td><td>返回多少条记录</td></tr><tr><td>limit(int, int)</td><td>记录选取条件</td><td>记录启始行位置，返回多少条记录</td></tr></tbody></table></li><li><p><code>table.select</code>:<br>  用于筛选数据，参数一为主键值，参数二为筛选条件，比<code>table.select(&quot;key1&quot;, condition)</code>表示筛选出所有主键为<code>key1</code>且，满足筛选条件<code>condition</code>的行</p></li><li><p><code>entries.size</code>:<br>  返回行数</p></li><li><p><code>entries.get</code>:<br>  单独获取某一行，参数为uint，表示需要获取的行</p></li><li><p><code>entry.get...()</code>:<br>  <code>Entry</code>提供了多个get方法，在使用时需要根据字段值使用应的get方法，如<code>getString getBytes32 getInt</code>，传入参数为需要获取的字段名</p><table><thead><tr><th>接口</th><th>功能</th><th>参数</th></tr></thead><tbody><tr><td>getInt(string)</td><td>获取字段值</td><td>字段名</td></tr><tr><td>getString(string)</td><td>获取字段值</td><td>字段名</td></tr><tr><td>getBytes64(string)</td><td>获取字段值</td><td>字段名</td></tr><tr><td>getBytes32(string)</td><td>获取字段值</td><td>字段名</td></tr><tr><td>getAddress(string)</td><td>获取字段值</td><td>字段名</td></tr></tbody></table></li></ul><h2 id="删除行"><a href="#删除行" class="headerlink" title="删除行"></a>删除行</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">TableFactory tf = TableFactory(0x1001);<br>Table table = tf.openTable(&quot;table_name&quot;);<br>if(table == address(0x01)) &#123;<br>    // error<br>&#125;<br><br>// 新建筛选条件<br>Condition condition = table.newCondition();<br>condition.EQ(&quot;item_1&quot;,&quot;1&quot;);<br>// 删除<br>int count = table.remove(&quot;key1&quot;, condition);<br></code></pre></td></tr></table></figure><p>解释：</p><ul><li><code>count</code>:<br>  删除的行数</li><li><code>table.remove</code>:<br>  删除满足条件的行，参数一为主键值，参数二为筛选条件，返回值为删除的行数</li></ul><h2 id="修改行"><a href="#修改行" class="headerlink" title="修改行"></a>修改行</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs solidity">TableFactory tf =TableFactory(0x1001);<br>Table table =tf.openTable(&quot;t_test&quot;);<br>// 检查table是否是空地址<br>if(table == address(0x0))<br>&#123;<br>    // error<br>&#125;<br><br>// 新建行<br>Entry newEntry = table.newEntry();<br>// 设置字段值<br>entry.set(&quot;item_1&quot;,&quot;1&quot;);<br>entry.set(&quot;item_2&quot;.&quot;2&quot;);<br><br>// 新建过滤条件<br>Condition condition = table.newCondition();<br>// 设置过滤条件<br>condition.EQ(&quot;imte_1&quot;,&quot;update&quot;);<br><br>// 修改行<br>int count = table.update(&quot;key1&quot;, newEntry, condition);<br></code></pre></td></tr></table></figure><p>解释:</p><ul><li><code>update</code>:<br>  参数一为主键值，参数二为修改后的行对象，参数三为过滤条件，返回值为修改的行数</li></ul><h1 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h1><ol><li><strong>主键不唯一</strong></li><li><strong>字段过多，可以使用数组或struct封装参数</strong></li></ol><p>​        </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区块链</tag>
      
      <tag>solidity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Foundry笔记</title>
    <link href="/2024/10/08/Foundry%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/10/08/Foundry%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -L https://foundry.paradigm.xyz | bash<br></code></pre></td></tr></table></figure><p>如果实在 Windows 中，则需要使用 git bash</p><h1 id="Hello-项目"><a href="#Hello-项目" class="headerlink" title="Hello 项目"></a>Hello 项目</h1><ul><li><p>创建项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">forge init hello_foundry<br></code></pre></td></tr></table></figure><p>如果没有配置 git，则需要用<code>--no-git</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">forge init hello_foundry --no-git<br></code></pre></td></tr></table></figure><p>创建的项目为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> hello_foundry<br>$ tree . -d -L 1<br>.<br>├── lib<br>├── script<br>├── src<br>└── <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure></li><li><p>构建项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">forge build<br></code></pre></td></tr></table></figure></li><li><p>运行测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">forge <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">forge init hello_foundry<br></code></pre></td></tr></table></figure><p>如果没有配置 git config，则需要使用<code>forge init hello_foundry --not-git</code>创建,或者使用<code>git config --global user.name &quot;your_name&quot;</code>和<code>git config --global user.email &quot;your_email&quot;</code>进行 git 配置</p><p>在创建时还可以使用<code>--template</code>选择模板</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">forge init --template https://github.com/foundry-rs/forge-template hello_template<br></code></pre></td></tr></table></figure><p>创建好后，可以使用<code>forge build</code>和<code>forge test</code>进行构建和测试。</p><h1 id="在现有项目工作"><a href="#在现有项目工作" class="headerlink" title="在现有项目工作"></a>在现有项目工作</h1><ul><li>克隆项目</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> ...<br></code></pre></td></tr></table></figure><ul><li>安装依赖项</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> project<br>forge install<br></code></pre></td></tr></table></figure><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── foundry.toml<br>├── lib<br>│   └── forge-std<br>│       ├── LICENSE-APACHE<br>│       ├── LICENSE-MIT<br>│       ├── README.md<br>│       ├── foundry.toml<br>│       ├── lib<br>│       └── src<br>├── script<br>│   └── Counter.s.sol<br>├── src<br>│   └── Counter.sol<br>└── <span class="hljs-built_in">test</span><br>    └── Counter.t.sol<br><br>7 directories, 8 files<br></code></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="使用-solidity-编写测试脚本"><a href="#使用-solidity-编写测试脚本" class="headerlink" title="使用 solidity 编写测试脚本"></a>使用 solidity 编写测试脚本</h2><p>编写测试需要使用<strong>Forge 标准库（forge-std）</strong>的 Test 合约</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">import &quot;forge-std/Test.sol&quot;;<br></code></pre></td></tr></table></figure><p>测试的基础写法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity 0.8.10;<br><br>import &quot;forge-std/Test.sol&quot;;<br><br>// 继承Test<br>contract ContractBTest is Test &#123;<br>    uint256 testNumber;<br><br>    // setUp 在每个测试用例运行之前调用的可选函数<br>    function setUp() public &#123;<br>        testNumber = 42;<br>    &#125;<br><br>    // test 前缀开头的函数表示一个测试用例<br>    function testNumberIs42() public &#123;<br>        // 断言<br>        assertEq(testNumber, 42);<br>    &#125;<br><br>    // testFail 作为test用例的反面，如果函数没有revert，则失败<br>    function testFailSubtract43() public &#123;<br>        testNumber -= 43;<br>    &#125;<br>&#125;<br><br>// 抽象合约用于共享设置<br>abstract contract HelperContract &#123;<br>    address constant IMPORTANT_ADDRESS = 0x543d...;<br>    SomeContract someContract;<br>    constructor() &#123;...&#125;<br>&#125;<br>// 共享HelperContract的设置<br>contract MyContractTest is Test, HelperContract &#123;<br>    function setUp() public &#123;<br>        someContract = new SomeContract(0, IMPORTANT_ADDRESS);<br>        ...<br>    &#125;<br>&#125;<br>contract MyOtherContractTest is Test, HelperContract &#123;<br>    function setUp() public &#123;<br>        someContract = new SomeContract(1000, IMPORTANT_ADDRESS);<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区块链</tag>
      
      <tag>solidity</tag>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mocha测试框架笔记</title>
    <link href="/2024/08/10/mocha%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/08/10/mocha%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>发音摩卡，是 js 测试框架之一，可以为 js 应用添加测试用例</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --global mocha<br><span class="hljs-built_in">mkdir</span> <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><h1 id="测试脚本编写"><a href="#测试脚本编写" class="headerlink" title="测试脚本编写"></a>测试脚本编写</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// add.js</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>) &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = add;<br></code></pre></td></tr></table></figure><p>待测试的 js 为<code>add.js</code>，为了规范，其测试脚本应为<code>add.test.js</code>，也就是加上<code>.test.js</code>后缀</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// add.test.js</span><br><span class="hljs-comment">// 导入需要测试的js</span><br><span class="hljs-keyword">var</span> add = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./add.js&#x27;</span>);<br><span class="hljs-comment">// 导入断言库，用于比较两个值是否相等</span><br><br><span class="hljs-comment">// describe 一个测试套件，可以有多个</span><br><span class="hljs-comment">// 参数1为套件名称，参数2为函数</span><br><span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;加法函数的测试&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// it 一个测试用例，可以有多个</span><br>    <span class="hljs-title function_">it</span>(<span class="hljs-string">&quot;1 + 1 应该 = 2&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 断言：判断实际结果与预期结果是否一致</span><br>        <span class="hljs-comment">// 不通过将抛出错误</span><br>        <span class="hljs-title function_">expect</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>),).<span class="hljs-property">to</span>.<span class="hljs-property">be</span>.<span class="hljs-title function_">equal</span>(<span class="hljs-number">2</span>);<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h1 id="Mocha-运行测试"><a href="#Mocha-运行测试" class="headerlink" title="Mocha 运行测试"></a>Mocha 运行测试</h1><ul><li><p>运行单个测试文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mocha add.test.js<br></code></pre></td></tr></table></figure></li><li><p>运行多个测试文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mocha file1 file2 file3<br></code></pre></td></tr></table></figure></li><li><p>运行 test 目录下所有测试文件（不包括子目录）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mocha<br></code></pre></td></tr></table></figure><p>mocha 默认去 test 目录中执行测试脚本，如果 test 中有其他子目录，子目录里的脚本不会被执行</p></li><li><p>运行 test 目录下所有测试文件（包括子目录）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mocha --recursive<br></code></pre></td></tr></table></figure><p>加上<code>--recursive</code>即可</p></li></ul><h1 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h1><ul><li><p>–help -h:<br>查看所有命令行参数</p></li><li><p>–reporter -R:<br>用于指定测试报告的格式，默认为<code>spec</code>格式</p></li></ul><h1 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h1><p>mocha 提供了四个钩子函数<code>before()</code>、<code>after()</code>、<code>beforeEach()</code>和<code>afterEach()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">before</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 在本区块的所有测试用例之前执行</span><br>&#125;);<br><br><span class="hljs-title function_">after</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 在本区块的所有测试用例之后执行</span><br>&#125;);<br><br><span class="hljs-title function_">beforeEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 在本区块的每个测试用例之前执行</span><br>&#125;);<br><br><span class="hljs-title function_">afterEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 在本区块的每个测试用例之后执行</span><br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>测试</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AJAX</title>
    <link href="/2024/08/02/ajax/"/>
    <url>/2024/08/02/ajax/</url>
    
    <content type="html"><![CDATA[<h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">变量名 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequst</span>();<br></code></pre></td></tr></table></figure><p>老版本的ie需要用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">变量名 =<span class="hljs-keyword">new</span> <span class="hljs-title class_">ActiveXObject</span>(<span class="hljs-string">&quot;Microsoft.XMLHTTP&quot;</span>);<br></code></pre></td></tr></table></figure><h1 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h1><p>发送请求通过<code>open</code>和<code>send</code>方法实现<br>方法参数如下：</p><ul><li>open<ul><li>method-string: 请求的类型GET或者POST，字符</li><li>url-string: 接口链接</li><li>async-bool: true为异步，false为同步</li></ul></li><li>send<ul><li>body-string: 发送给服务器的参数<br>  示例：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建对象</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Http</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequst</span>();<br><br><span class="hljs-comment">// GET请求</span><br><span class="hljs-comment">// 传入参数，GET方法、接口链接、异步</span><br><span class="hljs-title class_">Http</span>.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>,<span class="hljs-string">&quot;http://127.0.0.1:8888&quot;</span>，<span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 发送请求</span><br><span class="hljs-title class_">Http</span>.<span class="hljs-title function_">send</span>();<br><br><span class="hljs-comment">// POST请求</span><br><span class="hljs-comment">// 传入参数，GET方法、接口链接、异步</span><br><span class="hljs-title class_">Http</span>.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;POST&quot;</span>,<span class="hljs-string">&quot;http://127.0.0.1:8888&quot;</span>，<span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 设置请求头</span><br><span class="hljs-title class_">Http</span>.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Content-type&quot;</span>,<span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>);<br><span class="hljs-comment">// 发送带参数的请求</span><br><span class="hljs-title class_">Http</span>.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;name=lihua&amp;age=10&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h1><h2 id="设置请求头"><a href="#设置请求头" class="headerlink" title="设置请求头"></a>设置请求头</h2><p>设置请求头可以通过<code>setRequestHeader()</code>方法实现<br>方法参数如下：</p><ul><li>header-string: 头的名称</li><li>values-string: 头的值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Http</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequst</span>();<br><span class="hljs-title class_">Http</span>.<span class="hljs-title function_">open</span>(......);<br><span class="hljs-title class_">Http</span>.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Content-type&quot;</span>,<span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><h2 id="请求头的作用"><a href="#请求头的作用" class="headerlink" title="请求头的作用"></a>请求头的作用</h2><p>可以传递请求的附加信息，如：身份验证、用户代理、缓存行为、请求体格式等</p><h2 id="常用请求头"><a href="#常用请求头" class="headerlink" title="常用请求头"></a>常用请求头</h2><ul><li><strong>host</strong>: 域名</li><li><strong>Content-Type</strong>: 媒体类型(MIME类型),用于区分数据类型<br>  它的格式为：<code>Content-Type: type/subtype ; parameter</code>，主类型&#x2F;子类型；可选参数（比如字符集等）。参见的有：<ul><li>application&#x2F;x-www-form-urlencoded<br>  一般用于表单提交,http请求将会以key1&#x3D;value1&amp;key2&#x3D;value2的形式，如果是中文字符或特殊字符会自动进行URL转码。</li><li>application&#x2F;xml<br>  用于接受和发送XML</li><li>application&#x2F;json<br>  用于接受和发送JSON数据</li><li>text&#x2F;html<br>  表示HTML文档，用于传输网页内容</li><li>multipart&#x2F;form-data<br>  用于上传文件的表单提交</li></ul></li><li><strong>Connection</strong>: 链接类型，发送请求后是否关闭链接<ul><li>kepp-alive: 长链接，每次请求复用已建立好的请求</li><li>close: 每次请求重新建立一个请求</li></ul></li><li><strong>Accept</strong>: 指定能够接收的内容类型，常用的有：<ul><li>text&#x2F;html: HTML文档</li><li>application&#x2F;json：JSON 数据</li><li>application&#x2F;xml：XML 数据</li><li>text&#x2F;plain：纯文本</li><li>&#x2F;：任意类型的数据</li></ul></li><li><strong>Upgrade-Insecure-Requests</strong>: 升级为HTTPS请求，取值‘1’</li><li><strong>User-Agent</strong>: 用户代理（浏览器、主机信息）</li><li><strong>referer</strong>: 页面跳转处（跳转来源），用于检查页面跳转是否合法、防盗链，取值为链接</li><li><strong>Cookie</strong>: 状态保持</li><li><strong>Authorization</strong>: 用于身份验证，常用于发送token</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络技术学习</title>
    <link href="/2024/07/26/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/07/26/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="网络类型"><a href="#网络类型" class="headerlink" title="网络类型"></a>网络类型</h1><p>网络在范围上可以分为</p><ul><li>广域网</li><li>城域网</li><li>局域网</li></ul><h1 id="网络地址"><a href="#网络地址" class="headerlink" title="网络地址"></a>网络地址</h1><p>网络地址可以分为a、b、c三类，和d、e两种特殊类，他们的范围如下：</p><table><thead><tr><th>分类</th><th>范围</th></tr></thead><tbody><tr><td>A</td><td>0-127，其中只有1-126可用</td></tr><tr><td>B</td><td>127-191</td></tr><tr><td>C</td><td>192-223</td></tr><tr><td>D</td><td>224-239(组播地址)</td></tr><tr><td>E</td><td>240-255(军事、科研地址)</td></tr></tbody></table><p>ip地址形本质是32位的二进制数，通常用三点分十进制表示如192.168。1.1</p><h2 id="网段"><a href="#网段" class="headerlink" title="网段"></a>网段</h2><p>ip地址可以分为网络位和主机位，网络位相同意味着处于同一网段，主机位用于辨别主机。</p><p>网络位可以用<strong>子网掩码</strong>进行标识，标准的掩码可以分A,B,C三类（255.0.0.0，255.255.0.0，255.255.255.0），也就是网络位数分别位8，16，32。</p><p>对于<strong>主机位取值</strong>也有要求，主机位全0表示网络地址，(比如192.168.27.0&#x2F;24),全1表示广播地址(192.168.27.255&#x2F;24)</p><h2 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h2><p>如果用标准网段，会造成主机位的浪费，就算是C类地址也可以有254个主机可用。这就需要子网划分。</p><p>这时，网络位可以向主机位借位，进行子网划分可以划分出多个子网</p><p><strong>划分个数 &#x3D; 2^n，n&#x3D;借位数</strong></p><p><strong>每个子网可用地址 &#x3D; 原可用&#x2F;n - 2（去掉2个特殊地址）</strong></p><p>比如:192.168.10.0&#x2F;25，分为两个子网，每个子网范围为:192.168.10.1-192.168.10.127, 192.168.10.129-192.168.10.254</p><h2 id="VLSM"><a href="#VLSM" class="headerlink" title="VLSM"></a>VLSM</h2><p>在子网的基础上，再次借位</p><h1 id="数据包发送方式"><a href="#数据包发送方式" class="headerlink" title="数据包发送方式"></a>数据包发送方式</h1><ul><li><p>单播</p><p>一对一</p></li><li><p>组播</p><p>一对多（按需）</p></li><li><p>广播</p><p>一对多</p></li></ul><h1 id="DHCP-IP分配"><a href="#DHCP-IP分配" class="headerlink" title="DHCP-IP分配"></a>DHCP-IP分配</h1><ul><li><p>作用：</p><p>全称：动态主机配置协议，可以<strong>为主机自动分配IP地址</strong>，除了IP地址，它还分配以下：</p><ul><li><p>IP地址：用于标识网络设备&#x2F;接口</p></li><li><p>子网掩码：标识网络位</p></li><li><p>默认网关：本质是一个IP地址，用于跨网段通信的中介</p><p>网络通信会经过网关进行转发。</p></li><li><p>DNS：域名解析</p></li></ul></li><li><p>原理：</p><p>报文：</p><ul><li><strong>Discover发现报文</strong></li><li><strong>offer回应报文</strong></li><li><strong>Request请求报文</strong></li><li><strong>ACK确认报文</strong></li><li>Reset地址释放</li><li>Decline地址冲突</li><li>NAK客户端拒绝</li><li>inform其他信息（网关地址、dns等）</li></ul></li><li><p>思科配置：</p><ul><li><p>思科三模式：</p><ol><li>Router&gt;用户模式</li><li>Router权模式，输入enable即可进入特权模式</li><li>Router(config)#全局模式&#x2F;配置模式，输入configure terminal即可进入全局模式</li></ol></li><li><p>配置代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Router</span><span class="hljs-params">(config)</span></span><span class="hljs-selector-id">#ip</span> dhcp pool pc1      -- 创建地址池，名为pc1<br><span class="hljs-function"><span class="hljs-title">Router</span><span class="hljs-params">(dhcp-config)</span></span><span class="hljs-selector-id">#network</span> <span class="hljs-number">192.168</span>.<span class="hljs-number">10.0</span> <span class="hljs-number">255.255</span>.<span class="hljs-number">255.0</span>-- 指定DHCP分配的网络范围<br><span class="hljs-function"><span class="hljs-title">Router</span><span class="hljs-params">(dhcp-config)</span></span><span class="hljs-selector-id">#default-router</span> <span class="hljs-number">192.168</span>.<span class="hljs-number">10.254</span>-- 设置默认网关<br><span class="hljs-function"><span class="hljs-title">Router</span><span class="hljs-params">(dhcp-config)</span></span><span class="hljs-selector-id">#dns-server</span> <span class="hljs-number">1.1</span>.<span class="hljs-number">1.1</span>-- 配置 DNS 服务器地址<br><span class="hljs-function"><span class="hljs-title">Router</span><span class="hljs-params">(dhcp-config)</span></span><span class="hljs-selector-id">#exit</span>-- 退出 DHCP 地址池配置模式<br><span class="hljs-function"><span class="hljs-title">Router</span><span class="hljs-params">(config)</span></span><span class="hljs-selector-id">#interface</span> fastEthernet <span class="hljs-number">0</span>/<span class="hljs-number">0</span>-- 进入 FastEthernet <span class="hljs-number">0</span>/<span class="hljs-number">0</span> 接口配置模式<br><span class="hljs-function"><span class="hljs-title">Router</span><span class="hljs-params">(config-if)</span></span><span class="hljs-selector-id">#no</span> shutdown -- 激活接口<br><span class="hljs-function"><span class="hljs-title">Router</span><span class="hljs-params">(config-if)</span></span><span class="hljs-selector-id">#ip</span> <span class="hljs-selector-tag">address</span> <span class="hljs-number">192.168</span>.<span class="hljs-number">10.254</span> <span class="hljs-number">255.255</span>.<span class="hljs-number">255.0</span>-- 配置接口 IP 地址和子网掩码<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h1><ul><li><p>作用：私有地址转公有地址-</p></li><li><p>私有地址：</p><ul><li>A:10.0.0.-10255.255.255.255</li><li>B:172.16.0.0-172.31.255.255</li><li>C:192.168.0.0-192.168.255.255</li></ul></li><li><p>NAT分类：</p><ul><li>静态NAT：一对一映射，常用于服务器，实现双向通信</li><li>动态NAT：多对多映射</li><li>easy IP：多对一，最常用</li><li>NATserver：一对一映射，与静态类似，但可以实现端口映射</li><li>NAPT：多对一，有多个公网IP，内部多态设备可以共用一个公网IP</li></ul></li><li><p>四大步骤：</p><ol><li>定义内外网接口</li><li>匹配感兴趣流量</li><li>NAT转换集</li><li>默认路由</li></ol></li><li><p>easy IP思科配置：</p><ul><li>定义内外网接口  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cisco">int f0/0<br>ip nat inside/* f0/0接口定义为内网接口 */<br>int f0/1<br>ip nat outside/* f0/0接口定义为外网接口 */<br></code></pre></td></tr></table></figure></li><li>感兴趣流量（谁需要转换）  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cisco">access-list 1 permit 192.168.10.0 0.0.0.255/* 定义列表，1为ACL编号，permit同意列表，网段 + 反掩码，正掩码表示网络位，反掩码用于匹配主机位 */<br></code></pre></td></tr></table></figure></li><li>转换集  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cisco">ip nat inseide source list 1 interface f0/1 overload/* 列表1作为内网源地址，f0/1作为外网接口, overlaod端口复用，利用端口号实现多对一映射 */<br></code></pre></td></tr></table></figure></li><li>默认路由<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cisco">ip route 0.0.0.0 0.0.0.0 200.100.1.254/*全0代表所有IP地址中目的地未知的默认转发给200.100.1.254 */<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="VLAN虚拟局域网"><a href="#VLAN虚拟局域网" class="headerlink" title="VLAN虚拟局域网"></a>VLAN虚拟局域网</h1><p>在交换机中，默认存在一个vlan1，所有端口默认存在vlan1中</p><ul><li><p>VLAN思科配置：</p><ul><li><p>创建VLAN：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cisco">vlan 10/* 创建VLAN */<br>name JS/* 命名VLAN */<br></code></pre></td></tr></table></figure></li><li><p>查看VLAN：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cisco">show vlan<br></code></pre></td></tr></table></figure></li><li><p>接口模式：</p><ul><li><p>access-接入模式</p><p>用于接入<strong>终端设备</strong>，只允许一个VLAN的数据通过</p></li><li><p>trunk-主干模式</p><p>用于连接<strong>上行设备</strong>，允许多个&#x2F;所有VLAN数据通过</p></li></ul></li><li><p>设置模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cisco">switchport mode access/* 设备接口模式位access */<br>switchport mode trunk/* 二层交换机设置模式 */<br>sw trunk encapsulation dot1q/* 三层交换机设置模式，封装trunk */<br></code></pre></td></tr></table></figure></li><li><p>划分vlan：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cisco">switchport access vlan 10/* 将接口划分进VLAN10 */<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="单臂路由-实现VLAN间通信"><a href="#单臂路由-实现VLAN间通信" class="headerlink" title="单臂路由-实现VLAN间通信"></a>单臂路由-实现VLAN间通信</h1><p>在路由器的一个接口上通过配置子接口的方式，实现原来相互隔离的不同VLAN之间的互联互通</p><ul><li><p>单臂路由思科配置：</p><ul><li><p>进入子接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cisco">int f0/0.10<br></code></pre></td></tr></table></figure></li><li><p>封装指定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cisco">encapsulation dot1Q 10/* 将子接口与vlan10绑定 */<br>ip ad 192.168.1.1 24<br></code></pre></td></tr></table></figure></li><li><p>配置路由，可以是静态、动态路由，nat等，以默认路由为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cisco">ip route 0.0.0.0 0.0.0.0 z.z.z.z/* zzzz是下一跳地址 */<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="设备介绍"><a href="#设备介绍" class="headerlink" title="设备介绍"></a>设备介绍</h1><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>用于连接两个或多个网络的硬件设备，在网络中起网关作用，接口较少。</p><p>在家用路由器中有wan口和lan口，wan口用于连接运营商ISP，lan口用于连接本地设备</p><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>Switch，用于连接局域网的设备，接口多，可以用于扩展接口</p><ul><li><p>信息的传递过程：</p><ol><li><p>学习MAC地址表：</p><p>当设备发送消息后，交换机会将该设备的MAC地址与其连接的端口绑定，加入MAC表</p></li><li><p>泛洪：</p><p>当目标地址不在MAC表中，会进行泛洪（除了发送者，其他都转发），若成功找到，则将接受者的MAC地址与对应接口加入MAC地址表中</p></li></ol></li><li><p>交换机类型：</p><ul><li><p>二层交换机ASW（接入层交换机）：</p><p>主要用于接入终端设备，一般不做配置</p></li><li><p>三层交换机：</p><p>三层交换机具有一定的路由功能</p><ul><li><p>汇聚层交换机DSW：</p><p>用于汇聚所有接入层的数据，一般不做配置</p></li><li><p>核心层交换机HX：</p><p>进行部分数据处理</p></li></ul></li></ul></li></ul><h1 id="动态路由分类"><a href="#动态路由分类" class="headerlink" title="动态路由分类"></a>动态路由分类</h1><ul><li>IGP：<ul><li>距离矢量路由协议：<ul><li>RIP</li><li>EIGRP</li></ul></li><li>链路状态路由协议<ul><li>OSPF</li><li>IS-IS</li></ul></li></ul></li><li>EGP：<ul><li>距离矢量路由协议<ul><li>BGP</li></ul></li></ul></li></ul><h1 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h1><p>开放式最短路径优先，属于链路状态协议</p><ul><li><p>特点：</p><ul><li>对设别性能有要求</li><li>知道全网拓扑</li><li>适用于大型网络</li><li>自动适应拓扑的变更</li></ul></li><li><p>参数：</p><ul><li>LSA：链路状态通告<ul><li>接口信息</li><li>连接了哪些设备</li><li>接口带宽：</li><li>开销：10^8 &#x2F; 接口带框</li></ul></li><li>LSDB：链路状态数据库，对链路状态通告进行整合</li><li>SPF：计算出最短路径</li></ul></li><li><p>重点：</p><ul><li>三张表：<ul><li>邻居表：存放邻居信息</li><li>拓扑表：记录整个网络的拓扑</li><li>路由表：存放最优路由</li></ul></li><li>五个报文：<ul><li>Hello</li><li>DBD</li><li>LSR</li><li>LSU</li><li>LSack</li></ul></li><li>七个状态：<ul><li>down：未开启</li><li>init：一方接受Hello报文</li><li>2-way：双方都接受到Hello报文</li><li>exstart：单方面发送信息摘要</li><li>exchange：双方交换摘要，开始请求详细信息</li><li>loading：、</li><li>FULL：</li></ul></li></ul></li><li><p>思科配置：</p><pre><code class="cisco">router ospf 1/* 1为进程id，建议所有设备统一 *//* 宣告方式 */network  192.168.14.0 0.0.0.255 area 0 /* 网段、反掩码、域（0为主干区域） *//* 接口方式 */int f0/0ip ospf 1 area 0</code></pre></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python venv虚拟环境基础</title>
    <link href="/2024/07/22/python-venv%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
    <url>/2024/07/22/python-venv%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是虚拟环境"><a href="#什么是虚拟环境" class="headerlink" title="什么是虚拟环境"></a>什么是虚拟环境</h1><p>相当于给解释器复制了几个副本，在项目中使用这个副本进行包的安装和管理，在项目打包时，可以更方便的导出。对于多个项目也可以使用虚拟环境对环境进行区分，而不需要去更改全局环境。</p><p>python使用虚拟环境有多种方法，这里用venv（针对py3），如果有切换py版本的需求，还可以使用pyenv</p><h1 id="venv安装"><a href="#venv安装" class="headerlink" title="venv安装"></a>venv安装</h1><p>一般不需要安装，在安装python的时候会自带</p><h1 id="查看venv-help列表"><a href="#查看venv-help列表" class="headerlink" title="查看venv help列表"></a>查看venv help列表</h1><p>终端输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python -m venv -h<br></code></pre></td></tr></table></figure><p>返回结果如下：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">usage: venv [-h] [<span class="hljs-comment">--system-site-packages] [--symlinks | --copies] [--clear] [--upgrade] [--without-pip]</span><br>            [<span class="hljs-comment">--prompt PROMPT] [--upgrade-deps]</span><br>            ENV_DIR [ENV_DIR ...]<br><br>Creates virtual Python environments <span class="hljs-keyword">in</span> <span class="hljs-literal">one</span> <span class="hljs-keyword">or</span> more target <span class="hljs-built_in">directories</span>.<br><br>positional arguments:<br>  ENV_DIR               A <span class="hljs-built_in">directory</span> <span class="hljs-built_in">to</span> <span class="hljs-built_in">create</span> <span class="hljs-keyword">the</span> environment <span class="hljs-keyword">in</span>.<br><br>options:<br>  -h, <span class="hljs-comment">--help            show this help message and exit</span><br>  <span class="hljs-comment">--system-site-packages</span><br>                        Give <span class="hljs-keyword">the</span> virtual environment access <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">system</span> site-packages dir.<br>  <span class="hljs-comment">--symlinks            Try to use symlinks rather than copies, when symlinks are not the default for the platform.</span><br>  <span class="hljs-comment">--copies              Try to use copies rather than symlinks, even when symlinks are the default for the platform.</span><br>  <span class="hljs-comment">--clear               Delete the contents of the environment directory if it already exists, before environment</span><br>                        creation.<br>  <span class="hljs-comment">--upgrade             Upgrade the environment directory to use this version of Python, assuming Python has been</span><br>                        upgraded <span class="hljs-keyword">in</span>-place.<br>  <span class="hljs-comment">--without-pip         Skips installing or upgrading pip in the virtual environment (pip is bootstrapped by default)</span><br>  <span class="hljs-comment">--prompt PROMPT       Provides an alternative prompt prefix for this environment.</span><br>  <span class="hljs-comment">--upgrade-deps        Upgrade core dependencies: pip setuptools to the latest version in PyPI</span><br><br>Once <span class="hljs-keyword">an</span> environment has been created, you may wish <span class="hljs-built_in">to</span> activate <span class="hljs-keyword">it</span>, e.g. <span class="hljs-keyword">by</span> sourcing <span class="hljs-keyword">an</span> activate script <span class="hljs-keyword">in</span> its bin<br><span class="hljs-built_in">directory</span>.<br></code></pre></td></tr></table></figure><p>让GPT翻译翻译</p><ol><li><strong>–system-site-packages</strong><ul><li>这个选项允许虚拟环境访问系统的 site-packages 目录，即当前系统 Python 安装的库。默认情况下，虚拟环境是隔离的，不会访问系统安装的包。</li></ul></li><li><strong>–symlinks</strong><ul><li>当平台默认不是符号链接时，尝试使用符号链接而不是拷贝文件。符号链接可以节省空间并且更改后会同步更新，但不适用于所有平台。</li></ul></li><li><strong>–copies</strong><ul><li>即使平台默认使用符号链接，也尝试使用拷贝而不是符号链接。这个选项可以确保在所有平台上都使用拷贝，避免符号链接可能带来的兼容性问题。</li></ul></li><li><strong>–clear</strong><ul><li>如果指定了这个选项，并且目标环境目录已经存在，将会删除目录中的内容，然后重新创建环境。</li></ul></li><li><strong>–upgrade</strong><ul><li>这个选项用于升级已存在的虚拟环境目录，以适应当前使用的 Python 版本。这在你的系统 Python 升级后，想要更新虚拟环境时非常有用。</li></ul></li><li><strong>–without-pip</strong><ul><li>如果指定了这个选项，创建虚拟环境时将跳过安装或升级 pip。通常情况下，pip 是默认引导安装的。</li></ul></li><li><strong>–prompt PROMPT</strong><ul><li>这个选项允许你为虚拟环境提供一个自定义的提示符前缀，用于在激活虚拟环境后显示在命令行界面中。</li></ul></li><li><strong>–upgrade-deps</strong><ul><li>这个选项用于升级虚拟环境中的核心依赖项，如 pip 和 setuptools，到最新的 PyPI 版本。</li></ul></li></ol><h1 id="创建环境"><a href="#创建环境" class="headerlink" title="创建环境"></a>创建环境</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python -m venv &lt;环境名&gt;<br></code></pre></td></tr></table></figure><p>创建完成后，当前路径下会出现一个与环境名同名的目录，该目录目录结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">&lt;DIR&gt;          Include<br>&lt;DIR&gt;          Lib<br>pyvenv.cfg<br>&lt;DIR&gt;          Scripts<br></code></pre></td></tr></table></figure><h1 id="激活环境"><a href="#激活环境" class="headerlink" title="激活环境"></a>激活环境</h1><p>进入到同名目录的<code>Scripts</code>目录下，该目录有一个<code>activate</code>文件，在终端中运行它即可激活环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">activate<br></code></pre></td></tr></table></figure><p>之后终端的前面有带有一个括号，括号里是环境名，如：</p><p><code>(test) D:\code&gt;</code></p><p>在这个基础上输出<code>pip list</code>查看该环境下的包，可以发现，虚拟环境中并没有我们在真实环境过的包。说明成功了</p><p>激活的本质就是修改临时修改环境变量</p><p>如果不想激活也可以直接运行<code>Scripts</code>下的python也是可以的，或者是在IDE中指定解释器</p><h1 id="复制和保存虚拟环境"><a href="#复制和保存虚拟环境" class="headerlink" title="复制和保存虚拟环境"></a>复制和保存虚拟环境</h1><p>在pip中有一个<code>pip list</code>指令，可以查看当前环境安装的包，在通过<code>&gt;</code>可以将结果输出到文件中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip list &gt; requirements.txt<br></code></pre></td></tr></table></figure><p>这样就安装的包名与版本输出到文本文件中了</p><p>如果想要导入这个文件中的包，可以通过<code>pip install -r &lt;文件名&gt;</code>批量导入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install -r requirements.txt<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数</title>
    <link href="/2024/07/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    <url>/2024/07/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h1><h2 id="行列式的概念"><a href="#行列式的概念" class="headerlink" title="行列式的概念"></a>行列式的概念</h2><p>首先要知道几个概念：</p><ul><li><p><strong>逆序数：</strong></p><p>将1-n进行排序，枚举<strong>每对数字，若大数在小数前，则出现一个逆序，逆序的数量称为逆序数</strong></p></li><li><p><strong>奇偶排列：</strong>根据逆序数的奇偶，称为<strong>奇排列或偶排列</strong></p></li></ul><p>比如<code>23541</code>，枚举每对数字<code>23 25 24 21 35 34 31 ... 41</code>出现逆序的次数为5，则它的逆序数为5，5是个奇数，所以称为奇排列。</p><h1 id="了解了这几个概念，开始说行列式的定义，n阶行列式的定义为：-begin-vmatrix-a-11-amp-a-12-amp-…a-1n-a-21-amp-a-22-amp-…a-2n-a-31-amp-a-32-amp-…a-3n-…a-n1-amp-a-n2-amp-…a-nn-end-vmatrix"><a href="#了解了这几个概念，开始说行列式的定义，n阶行列式的定义为：-begin-vmatrix-a-11-amp-a-12-amp-…a-1n-a-21-amp-a-22-amp-…a-2n-a-31-amp-a-32-amp-…a-3n-…a-n1-amp-a-n2-amp-…a-nn-end-vmatrix" class="headerlink" title="了解了这几个概念，开始说行列式的定义，n阶行列式的定义为：$$\begin{vmatrix}a_{11} &amp; a_{12} &amp; …a_{1n} \a_{21} &amp; a_{22} &amp; …a_{2n} \a_{31} &amp; a_{32} &amp; …a_{3n} \…a_{n1} &amp; a_{n2} &amp; …a_{nn} \\end{vmatrix} "></a>了解了这几个概念，开始说行列式的定义，n阶行列式的定义为：<br>$$<br>\begin{vmatrix}<br>a_{11} &amp; a_{12} &amp; …a_{1n} \<br>a_{21} &amp; a_{22} &amp; …a_{2n} \<br>a_{31} &amp; a_{32} &amp; …a_{3n} \<br>…<br>a_{n1} &amp; a_{n2} &amp; …a_{nn} \<br>\end{vmatrix} </h1><p>\sum(-1)^{\tau(j_1j_2\cdots j_n)}a_{1j_1}a_{2j_2}\cdots a_{nj_n}<br>$$<br>行列式是一个n*n的数表。两边用竖线括起，行列式是一种运算，运算的方法为：</p><ul><li>从每行中取出一个元素，每行的元素都不同列，求出乘积</li><li>如果列标号是奇排序则加负号</li><li>把所有情况求和，就是行列式的结果</li></ul><p>比如现在有一个三阶行列式：<br>$$<br>\begin{vmatrix}<br>1&amp;2&amp;3\<br>4&amp;5&amp;6\<br>7&amp;8&amp;9<br>\end{vmatrix}<br>$$<br>那么每一行取不重复的一列，总共可以有6种取法：123，132，213，231，321，312</p><p>接下来算每种情况的乘积：</p><p>123对应1<em>5</em>9，相乘为45，123的逆序数为0，所以是偶排列 ，不需要负号，</p><p>132对应168，相乘 为48，逆序数为1，所以是奇排列，需要加负号，</p><p>…</p><p>将所有乘积算出后相加，得到行列式的结果为0</p><h2 id="特殊状态快速求解"><a href="#特殊状态快速求解" class="headerlink" title="特殊状态快速求解"></a>特殊状态快速求解</h2><p>通过基础概念去运算，可以看到非常的繁琐，而对于一些特殊的行列式，通过公式快速得出结果</p><ul><li><p>二阶行列式：</p><p>二阶行列式只有两种取法，12和21，而21的逆序数为1，是奇排列，需要加负号，所以二阶行列式的计算公式为：</p><blockquote><p><strong>主对角线乘积（从左上到右下）-副对角线乘积（从右上到左下）</strong></p></blockquote></li><li><p>有多个元素为0：</p><p>当有多个元素为0时，可以直接通过定义求值，因为0乘以任何数都为0，会去除很多种取值</p></li><li><p>对角度、上&#x2F;下三角行列式：</p><p>形如：<br>$$<br>\begin{vmatrix}a_{11}&amp;0&amp;…&amp;0\0&amp;a_{22}&amp;…&amp;0\\vdots&amp;\vdots&amp;\vdots\0&amp;0&amp;\cdots&amp;a_{nn}\end{vmatrix}&#x3D;\begin{vmatrix}a_{11}&amp;a_{12}&amp;\cdots&amp;a_{1n}\0&amp;a_{22}&amp;\cdots&amp;a_{2n}\\vdots&amp;\vdots&amp;\vdots\0&amp;0&amp;\cdots&amp;a_{m}\end{vmatrix}&#x3D;\begin{vmatrix}a_{11}&amp;0&amp;…&amp;0\a_{21}&amp;a_{22}&amp;\vdots&amp;0\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\a_{n1}&amp;a_{n2}&amp;\cdots&amp;a_{nn}\end{vmatrix}&#x3D;\prod a_{ii}<br>$$<br>如果主对角线下方是0，称为<strong>上三角行列式</strong>，下方是0称为<strong>下三角行列式</strong>（没写反，就是这样），全是0称为<strong>对角行列式</strong>。</p><p>对于这几种情况，有且只有一种取值，就是<strong>取在主对角线上</strong>，所以他们的结果为</p><blockquote><p><strong>对角线元素的乘积</strong></p></blockquote></li><li><p>非特殊：</p><p>没有0则创造0，可以通过行列式的性质进行转换，化简得到上下三角行列式</p></li></ul><h2 id="行列式的性质"><a href="#行列式的性质" class="headerlink" title="行列式的性质"></a>行列式的性质</h2><p>通过行列式的性质，可以对行列式进行转换，化简，行列式的性质有：</p><ul><li><p>转置不变：</p><p>将行和列调换，行列式的值不变，根据整个性质可知，以下性质同样适用于列</p></li><li><p><strong>逐行保数乘：</strong>（常用）</p><p>如果某一行有公因数k，可以提到行列式外面；如果整个行列式都是公因数k，提到外边将变成 k的n次方</p></li><li><p>逐行保加：</p><p>某一行拆成两个数的和，可据此拆成两个行列式的和。用的不多</p></li><li><p><strong>交错性：</strong></p><p>交换行列式的任意两行或两列，行列式的值变成相反数，交换两次则负负得正。</p></li><li><p><strong>倍加不变：</strong>（用的最多，重点）</p><p>把任意 一行乘以任意数加到另一行上，行列式的值不变</p></li><li><p><strong>同比化零：</strong>（从倍加不变推导）</p><p>两行成比例，整个行列式为0</p></li></ul><p>通过以上特性，可以将行列式转换为对角，上下三角行列式</p><h2 id="行列式展开定理"><a href="#行列式展开定理" class="headerlink" title="行列式展开定理"></a>行列式展开定理</h2><p>学会之后可以更开的求值。</p><p>在学习之前，需要先理解两个概念：<strong>余子式和代数余子式</strong>：</p><ul><li><p>余子式M<del>ij</del>：</p><p>对于元素a<del>jj</del>,把同行、同列的元素去掉，剩下的行列式称为它的**余子式M<del>ij</del>**。</p></li><li><p>代数余子式A<del>ij</del>:<br>$$<br>{A_{ij}}&#x3D;(-1)^{i+j} M_{ij}<br>$$</p></li></ul><p>了解之后，就能学习行列式的展开定理：</p><ul><li><p>n阶行列式等于它任意一行的所有元素与代数余子式的乘积之和：<br>$$<br>D&#x3D;a_{i1}A_{i1}+a_{i2}A_{i2}+\cdots+a_{in}A_{in}<br>$$</p></li><li><p>如果把余子式相应乘到另一行上，结果为0：<br>$$<br>D&#x3D;a_{k1}A_{i1}+a_{k2}A_{i2}+\cdots+a_{kn}A_{in} (i\neq k)<br>$$</p></li></ul><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="矩阵的概念"><a href="#矩阵的概念" class="headerlink" title="矩阵的概念"></a>矩阵的概念</h2><p>由m*n个数排成的矩形数表称为矩阵，记为：<br>$$<br>A_{m\times n}&#x3D;\left(a_{ij}\right)_{m\times n}<br>$$<br>矩阵本身用大写字母表示，矩阵中的元素则用小写字母表示。</p><p>只有形状相同（行列数相同）且对应元素都相同的矩阵才相等</p><p>对于一些特殊的矩阵，有特定的名称：</p><ul><li><p>方阵：行数等于列数称为方阵，只有方阵有对应的行列式</p></li><li><p>三角矩阵（针对方阵）：</p><ul><li>上三角矩阵：对角线左下方全为0</li><li>下三角矩阵：对角线右上方全为0</li><li>对角矩阵：只有对角线上的元素不是0，记为diag(a<del>11</del>,a<del>22</del>,…,a<del>nn</del>)</li></ul></li><li><p>向量：若矩阵只有一行，称为行矩阵或行向量；只有一列称为列矩阵或列向量</p></li><li><p>零矩阵：所有元素都是0，记为0或0<del>m*n</del>。且形状不同的零矩阵不相等</p></li><li><p>单位矩阵I<del>n</del>：对角元素都是1的对角矩阵</p></li><li><p>数量矩阵：对角元素都相等的对角矩阵</p></li><li><p>幂：</p><ul><li><p>只有A为方阵时，才有矩阵的幂A^k^，等于k个A相乘</p></li><li><p>矩阵幂运算的性质与实数类似：<br>$$<br>A^0&#x3D;I,A^k A^l&#x3D;A^{k+l},\left(A^k\right)^l&#x3D;A^{kl}\<br>但是<br>(AB)^{k}\neq A^{k}B^{k}<br>$$</p></li></ul></li><li><p>矩阵的转置：</p><ul><li><p>将矩阵A的行列颠倒，称为矩阵的转置，记为A^T^</p></li><li><p>矩阵转置的性质与乘方类似：<br>$$<br>(A^T)^T&#x3D;A,(A+B)^T&#x3D;A^T+B^T,(kA)^T&#x3D;kA^T,(AB)^T&#x3D;B^TA^T<br>$$</p></li><li><p>根据转置结果，有以下特殊矩阵且都是方阵：</p><ul><li>对称矩阵：A&#x3D;A^T^</li><li>反对称矩阵：转置后所有的元素变为相反数，A^T^&#x3D;-A，对角元素必然都是0（因为转置不影响对角线元素，0的相反数还是0）。</li></ul><p>若A、B是同阶的对称或反对称矩阵，则A+B、kA、kB也是对称或非对称矩阵，但AB不一定是</p></li></ul></li><li><p>矩阵的逆：若A为方阵，存在矩阵B使AB&#x3D;BA&#x3D;I，则成方阵A可逆，B是A的逆矩阵A^-1^</p><p>逆矩阵的性质有：</p><ul><li><p>若A可逆，则逆矩阵唯一</p></li><li><p>若A可逆，则A^-1^也可逆，(A^-1^)^-1^&#x3D;A</p></li><li><p>(AB)^-1^ &#x3D; B^-1^A^-1^</p></li><li><p>(A^T^)^-1^ &#x3D; (A^-1^)^T^</p></li><li><p>(kA)^-1^ &#x3D; k^-1^A^-1^</p></li><li><p>|A^-1^| &#x3D; |A|^-1^</p></li></ul><p>求逆矩阵的方法：</p><ul><li><p>待定系数法：麻烦没人用</p></li><li><p>伴随矩阵法：<br>伴随矩阵是指n阶方阵各元素代数余子式构成矩阵的转置，称为伴随矩阵A^<em>^<br>$$<br>AA^{</em>}&#x3D;A^{*}A&#x3D;|A|I<br>$$</p><p>矩阵可逆等价于<br>$$<br>|A|\neq0<br>$$</p><p>伴随矩阵的性质有：<br>$$<br>|A^*|&#x3D;|A|^{n-1} (A^T)^*&#x3D;(A^*)^T,(A^{-1})^*&#x3D;(A^*)^{-1}<br>$$</p></li><li><p>初等行变换法：</p><p>对矩阵【A|I】进行初等行变换，将A变换为一个单位矩阵（对角线全1其余0），同时I同步进行行变换。</p><p>如果成功则变换后的I就是要求的逆矩阵；如果A变换时出现全0行，则说明A不可逆</p></li></ul></li></ul><h2 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h2><ul><li><p>同型矩阵的线性运算：</p><ul><li>矩阵的加减乘、负矩阵：对应元素加减</li><li>数乘：所有元素都乘以这个数</li></ul><p>线性运算满足交换律、结合律、分配律</p></li><li><p>矩阵的乘法：</p><ul><li><p>可乘原则：前一个矩阵的列数&#x3D;后一个矩阵的行数（前列数&#x3D;后行数）只有满足这个条件才能相乘</p></li><li><p>乘积阶数：两个矩阵相乘后的大小为：前行数*后列数（左行右列中相等）<br>$$<br>A_{m\times n}\times B_{n\times p}&#x3D;C_{m\times p}<br>$$</p></li><li><p>乘积元素：C<del>ij</del>是A的第i行元素与B的第j列元素，对应相乘后，求和（左行右列中求和）<br>$$<br>AB&#x3D;\left(a_{ij}\right)<em>{m\times s}\cdot\left(b</em>{ij}\right)<em>{s\times n}&#x3D;\left(c</em>{ij}\right)<em>{m\times n}&#x3D;C, c</em>{ij}&#x3D;\sum a_{ik}b_{kj}<br>$$<br>比如两个2*2的矩阵相乘，一个为A(1,2|3,4)另一个为B(2,2|3,4)，则它们相乘的结果为2*2的矩阵C，则<br>$$<br>\begin{aligned}C_{11}&amp;&#x3D;A_{11}\times B_{21}+A_{12}\times B_{21}+A_{13}\times B_{31}\end{aligned}<br>$$</p><p>结果为8</p></li></ul></li></ul><h2 id="矩阵与行列式的关系"><a href="#矩阵与行列式的关系" class="headerlink" title="矩阵与行列式的关系"></a>矩阵与行列式的关系</h2><p>若A为方阵，则有对应的行列式，记为|A|或det(A)<br>$$<br>|kA|&#x3D;k^{n}A , |AB|&#x3D;|A||B| , |A^{k}|&#x3D;|A|^{k} , |A^{T}|&#x3D;|A|\<br>注意\<br>|A+B|\neq|A|+|B|<br>$$</p><h2 id="矩阵的初等行变换"><a href="#矩阵的初等行变换" class="headerlink" title="矩阵的初等行变换"></a>矩阵的初等行变换</h2><p>和行列式类似：</p><ul><li><p>对换：</p><p>交换i，j两行的位置，和行列式不一样，不需要加负号</p></li><li><p>倍乘：</p><p>将第i行变为C倍，c不等于0</p></li><li><p>倍加：</p><p>将第i行的k倍加到第j行</p></li></ul><h2 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h2><h3 id="矩阵的秩的概念"><a href="#矩阵的秩的概念" class="headerlink" title="矩阵的秩的概念"></a>矩阵的秩的概念</h3><p>k阶段子式：从矩阵A中任取k行k列，构成的行列式称为A的k阶子式</p><p>对于矩阵A，若存在r阶子式不为0，但所有r+1阶子式都为0，则r称为矩阵的秩，记为r(A)。零矩阵的秩是0</p><h3 id="矩阵的秩的求法"><a href="#矩阵的秩的求法" class="headerlink" title="矩阵的秩的求法"></a>矩阵的秩的求法</h3><p>对矩阵做初等行变换，变换为阶梯矩阵，并尽可能地把一行化为零。最终的阶梯矩阵的非零行数，就是矩阵的秩。</p><p>如：<br>$$<br>\left.A&#x3D;\left[\begin{array}{cccc}1&amp;2&amp;0&amp;3&amp;4\-1&amp;2&amp;-4&amp;1&amp;0\2&amp;1&amp;3&amp;-2&amp;-10\-2&amp;1&amp;-5&amp;1&amp;3\end{array}\right.\right]\to\left[\begin{array}{cccc}1&amp;2&amp;0&amp;3&amp;4\0&amp;1&amp;-1&amp;1&amp;1\0&amp;-3&amp;3&amp;-8&amp;-18\0&amp;5&amp;-5&amp;7&amp;11\end{array}\right]\to\left[\begin{array}{cccc}1&amp;2&amp;0&amp;3&amp;4\0&amp;1&amp;-1&amp;1&amp;1\0&amp;0&amp;0&amp;1&amp;3\0&amp;0&amp;0&amp;0&amp;0\end{array}\right]<br>$$<br>非零行有三行，故r(A)&#x3D;3</p><h3 id="矩阵的秩的性质"><a href="#矩阵的秩的性质" class="headerlink" title="矩阵的秩的性质"></a>矩阵的秩的性质</h3><ul><li><p>基本性质：<br>$$<br>0\leq r(A)\leq\min{m,n}<br>$$</p></li><li><p>满秩矩阵的性质</p><ul><li>可逆矩阵满秩r(A)&#x3D;n；不可逆矩阵不满秩r(A)&lt;n</li><li>初等变换不改变矩阵的秩，乘可逆矩阵不改变矩阵的秩</li><li>左乘列满秩、右行满秩矩阵，不改矩阵的秩</li></ul></li><li><p>矩阵运算的秩的性质</p><ul><li><p>$$<br>r({A+B})\leq r(A)+r(B)<br>$$</p></li><li><p>$$<br>r({kA})&#x3D;{r(A)}\quad(k\neq0)<br>$$</p></li><li><p>$$<br>&amp;\bullet r(A)+r(B)-n\leq r(\underline{AB})\leq\min{r(A),r(B)}(n\text{为A的列数、B的行数})\&amp;\bullet \text{若}AB&#x3D;0 , \text{则}r(A)+r(B)\leq n\&amp;\bullet \text{若}AB&#x3D;0 , \text{且}A\text{列满秩,则}B&#x3D;0 ; B \text{行满秩,则}A&#x3D;0\<br>$$</p></li><li><p>$$<br>r(A)&#x3D;r(\underline{A^T})&#x3D;r(AA^T)&#x3D;r(A^TA)<br>$$</p></li><li><p>$$<br>\text{对于n}\geq2\text{阶方阵,}r(\underline{A^*})&#x3D;\begin{cases} n r(A)&#x3D;n\ 1 r(A)&#x3D;n-1\ 0 r(A)\leqslant n-2\end{cases}<br>$$</p></li></ul></li></ul><h1 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h1><h2 id="线性方程组的概念"><a href="#线性方程组的概念" class="headerlink" title="线性方程组的概念"></a>线性方程组的概念</h2><ul><li><p>普通形式：<br>$$<br>\left.\left{\begin{array}{l}a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_n&#x3D;b_1\a_{21}x_1+a_{22}x_2+\cdots+a_{2n}x_n&#x3D;b_2\…\a_{m1}x_1+a_{m2}x_2+\cdots+a_{mn}x_n&#x3D;b_m\end{array}\right.\right.<br>$$<br>如果等式右边全为0，则称为<strong>齐次线性方程组，否则称为非齐次线性方程组</strong></p></li><li><p>矩阵形式：<br>$$<br>设A&#x3D; ( a_ij) _{m\times n}(即把未知数系数取出作为一个矩阵), \vec{X} &#x3D; ( x_1, x_2, \cdots , x_n) ^T(解x1到xn作为一个向量), \vec{b} &#x3D; ( b_1, b_2, \cdots , b_n) ^T(右边系数也写为一个向量),\<br>线性方程组可化为A\vec{X}&#x3D;\vec{b}\<br>其中，A称为系数矩阵，[A|b] 称为增广矩阵。如果A可逆，当然可以直接求解 \vec{X}&#x3D;A^{-1}\vec{b}<br>$$</p></li></ul><h2 id="线性方程组的求解"><a href="#线性方程组的求解" class="headerlink" title="线性方程组的求解"></a>线性方程组的求解</h2><p>利用初等行变换，将增广矩阵化为阶梯矩阵</p><ul><li><p>若系数矩阵某行为0，但结果不为0，比如“0 0 0 | 1”，无解</p></li><li><p>若系数矩阵有全0行，且结果同样为0，比如“0 0 0 | 0”，有解</p><ul><li>当有解时，若未知数个数&#x3D;非0行数（也就是秩），有限解，直接写出结果</li><li>当有解时，若未知数个数&gt;非0行数（也就是秩），无穷解，需要写出通解</li></ul></li></ul><h1 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h1><h2 id="向量的概念："><a href="#向量的概念：" class="headerlink" title="向量的概念："></a>向量的概念：</h2><ul><li>n*1矩阵称为列向量，反之行向量</li><li>向量a一般默认为列向量</li><li>向量的长度为所有元素的平方和去开根</li><li>所有分量为0的向量称为零向量，长度为1的向量称为单位向量</li><li>m*n的矩阵可以看成m个行向量组成或n个列向量组成</li></ul><h2 id="向量的运算"><a href="#向量的运算" class="headerlink" title="向量的运算"></a>向量的运算</h2><ul><li><p>线性运算</p><p>n维向量的加、乘只需逐元素运算即可，且满足交换律、分配律、结合律</p></li></ul><h1 id="特征值和特征向量"><a href="#特征值和特征向量" class="headerlink" title="特征值和特征向量"></a>特征值和特征向量</h1><h2 id="特征值和特征向量的概念"><a href="#特征值和特征向量的概念" class="headerlink" title="特征值和特征向量的概念"></a>特征值和特征向量的概念</h2><p>对于n阶<strong>方阵</strong>，若存在数k和非零向量X，使得AX&#x3D;kX</p><p>则称k是A的特征值，X是A的属于特征值k的特征向量</p><h2 id="特征值与特征向量的计算"><a href="#特征值与特征向量的计算" class="headerlink" title="特征值与特征向量的计算"></a>特征值与特征向量的计算</h2><p>使用公式<br>$$<br>f_A(k)&#x3D;|kI-A|&#x3D;0<br>$$<br>其中I是单位矩阵，kI即为：<br>$$<br>\left.\left[\begin{matrix}k&amp;0&amp;0\0&amp;k&amp;0\0&amp;0&amp;k\end{matrix}\right.\right]<br>$$<br>化简后求出值即为特征值</p><p>之后将各个依次特征值带入方程算出对应的特征向量即可<br>$$<br>(k I-A)X&#x3D;0<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python数学建模学习</title>
    <link href="/2024/07/12/python%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/07/12/python%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="python必备库"><a href="#python必备库" class="headerlink" title="python必备库"></a>python必备库</h1><ul><li><p>numpy：</p><p>科学计算的基础包</p></li><li><p>pandas：</p><p>建立在 NumPy 数组之上的数据分析工具</p></li><li><p>matplotlib：</p><p>用于绘制各种类型图表</p></li></ul><h1 id="评价决策类"><a href="#评价决策类" class="headerlink" title="评价决策类"></a>评价决策类</h1><p>通过对比多个指标，做出适合的决策，比如买衣服，指标可能会有价格、颜色、样式设计等，这些指标需要进行一定的处理才能使用</p><p><strong>归一化处理</strong>：</p><p>当有多个指标时，每个指标的数量级不同（比如明星的粉丝数几万和作品数只有十几个），如果直接将指标相加进行比较容易忽略数量级较小的指标。</p><p><strong>让指标处于同一数量级，且保证在同一指标下差距不变，就是归一化处理</strong>。</p><p>比如：对于三种决策，同一指标下的指标数组<code>[a,b,c]</code>，归一化处理得到<code>[a/(a+b+c), b/(a+b+c), c/(a+b+c)]</code></p><p>每个指标就统一为了(0,1)之间</p><p><strong>每个指标的重要性是不同的，需要根据情况加上权重</strong></p><p>比如：每个决策有2个指标，1个更重要，那么可以把他权重设为0.2，另一个权重为0.1，在归一化处理的时候乘以权重</p><h2 id="两两分析法"><a href="#两两分析法" class="headerlink" title="两两分析法"></a>两两分析法</h2><p>可以使用两两比较法确定指标重要性，绘制一个表格，行列为各个指标，表格元素为两个指标的重要性之比且比值满足下表</p><table><thead><tr><th>尺度</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>A比B影响相同</td></tr><tr><td>3</td><td>A比B影响稍强</td></tr><tr><td>5</td><td>A比B影响强</td></tr><tr><td>7</td><td>A比B影响明显的强</td></tr><tr><td>9</td><td>A比B影响绝对的强</td></tr><tr><td>2，4，6，8</td><td>处于上述比值之间</td></tr><tr><td>1，1&#x2F;2…</td><td>与上述互反</td></tr></tbody></table><h2 id="层次分析法"><a href="#层次分析法" class="headerlink" title="层次分析法"></a>层次分析法</h2><p>简称AHP，是对一些较为复杂、模糊的问题作出决策的简易方法，它特别适合<strong>难以完全定量分析的问题</strong></p><h3 id="层次分析法模型"><a href="#层次分析法模型" class="headerlink" title="层次分析法模型"></a>层次分析法模型</h3><p>在应用AHP分析决策问题时，首先要把问题<strong>条理化、层次化</strong>，构造出一个有层次的结构模型</p><ul><li><strong>目标层：</strong>只有一个元素，一般是分析问题的<strong>预定目标或理想结果</strong></li><li><strong>准则层：</strong>包含了<strong>目标所涉及的中间环节</strong>，可以包含若干个层次，包括所需考虑的准则、子准则</li><li><strong>方案层：</strong>包含了为实现目标可供选择的<strong>各种措施、决策方案</strong></li></ul><h3 id="一致矩阵"><a href="#一致矩阵" class="headerlink" title="一致矩阵"></a>一致矩阵</h3><p>通过两两分析法可以获得一个矩阵，如果该矩阵合理则称为一致性矩阵，比如a<del>12</del>&#x3D;2:1,a<del>13</del>=5,那么t应该有：a<del>23</del>=a<del>21</del>*a<del>13</del>&#x3D;5&#x2F;2，但由于在比较时是两两比较的，就可能出现不一致的情况。所以矩阵构建后需要进行<strong>一致性检验</strong></p><h4 id="一致性检验"><a href="#一致性检验" class="headerlink" title="一致性检验"></a>一致性检验</h4><p>一致性矩阵有两个性质：</p><ul><li>A的秩1，A的唯一非零特征根为n</li><li>A的任一列向量都是对于特征根n</li></ul><p>一致性的检验方法：</p><ol><li>A的秩1，A的唯一非零特征值为n</li><li>A的任一列向量都是对于特征值n的特征向量</li><li>A不为一致矩阵时，其最大特征值k<del>max</del>&gt;n，且相差越大，其不一致程度越大</li></ol><p>计算一致性指标公式：<br>$$<br>CI&#x3D;\frac{\lambda_{\max}-n}{n-1},:CI&#x3D;\begin{cases}0\text{,有完全一致性}\\text{接近}0\text{,满意的一致性}\\text{越大,一致性越差}\end{cases}<br>$$<br>为了衡量CI的大小，引入了随机一致性指标RI，常用的RI如下表</p><table><thead><tr><th>n</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th></tr></thead><tbody><tr><td>RI</td><td>0</td><td>0</td><td>0.58</td><td>0.90</td><td>1.12</td><td>1.24</td><td>1.32</td><td>1.41</td><td>1.45</td><td>1.49</td><td>1.51</td></tr></tbody></table><p>定义一致性比例:<br>$$<br>CR&#x3D;\frac{CI}{RI}<br>$$<br>如果CR&lt;0.1，则判断一致性可以接受</p><h4 id="一致性矩阵权重计算"><a href="#一致性矩阵权重计算" class="headerlink" title="一致性矩阵权重计算"></a>一致性矩阵权重计算</h4><ul><li><p>对于一致性矩阵，可以将指标归一化处理得出权重，比如：</p><table><thead><tr><th></th><th>a</th><th>b</th></tr></thead><tbody><tr><td>a</td><td>1</td><td>2</td></tr><tr><td>b</td><td>1&#x2F;2</td><td>1</td></tr></tbody></table><p>那么a的权重即为1&#x2F;(1+0.5)，b的权重为0.5&#x2F;(1+0.5)</p></li><li><p>对于非一致性矩阵，由于各列不成比例，所以需要计算每一列的权重，算出算术平均值作为最后的权重，如：</p><table><thead><tr><th></th><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr><td>a</td><td>1</td><td>2</td><td>5</td></tr><tr><td>b</td><td>1&#x2F;2</td><td>1</td><td>2</td></tr><tr><td>c</td><td>1&#x2F;5</td><td>1&#x2F;2</td><td>1</td></tr></tbody></table><p>对于第一列：a<del>1</del>&#x3D;1&#x2F;(1+0.5+0.25),b<del>1</del>&#x3D;0.5&#x2F;(1+0.5+0.25),c<del>1</del>&#x3D;0.25&#x2F;(1+0.5+0.25)</p><p>对于第二列：a<del>2</del>&#x3D;2&#x2F;(2+1+0.5),b<del>2</del>&#x3D;1&#x2F;(2+1+0.5),c<del>2</del>&#x3D;0.5&#x2F;(2+1+0.5)</p><p>对于第三列:……</p><p>所以a的权重&#x3D;(a<del>1</del>+a<del>2</del>+a<del>3</del>)&#x2F;3,b的权重……</p></li><li><p><strong>通用方法：特征值求权重</strong>：</p><p>当矩阵通过一致性检验后，算出矩阵的最大特征值对应的特征向量，对该特征向量进行归一化处理</p></li></ul><h3 id="层次分析法PYTHON"><a href="#层次分析法PYTHON" class="headerlink" title="层次分析法PYTHON"></a>层次分析法PYTHON</h3><h4 id="一致性检验-1"><a href="#一致性检验-1" class="headerlink" title="一致性检验"></a>一致性检验</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-comment"># 定义矩阵</span><br>A = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>], [<span class="hljs-number">1</span>/<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>/<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>/<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>/<span class="hljs-number">5</span>, <span class="hljs-number">1</span>/<span class="hljs-number">2</span>, <span class="hljs-number">1</span>/<span class="hljs-number">2</span>, <span class="hljs-number">1</span>]])<br>eig_val, eig_vec = np.linalg.eig(A)     <span class="hljs-comment"># 求出特征值和特征向量</span><br><br><br>n = A.shape[<span class="hljs-number">0</span>]      <span class="hljs-comment"># 获取A的行，0改为1则是A的列，shape是获取形状信息</span><br>n<br></code></pre></td></tr></table></figure><p>​    4</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">Max_eig = <span class="hljs-built_in">max</span>(eig_val)  <span class="hljs-comment"># 求出最大特征值</span><br>CI = (Max_eig - n) / (n-<span class="hljs-number">1</span>)<br>RI = [<span class="hljs-number">0</span>, <span class="hljs-number">0.0001</span>, <span class="hljs-number">0.52</span>, <span class="hljs-number">0.89</span>, <span class="hljs-number">1.12</span>, <span class="hljs-number">1.26</span>, <span class="hljs-number">1.36</span>, <span class="hljs-number">1.41</span>, <span class="hljs-number">1.46</span>, <span class="hljs-number">1.49</span>, <span class="hljs-number">1.52</span>, <span class="hljs-number">1.54</span>, <span class="hljs-number">1.56</span>, <span class="hljs-number">1.58</span>, <span class="hljs-number">1.59</span>]    <span class="hljs-comment"># 随机一致性指标，最大支持15</span><br><br>CR = CI / RI[n-<span class="hljs-number">1</span>]<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;一致性指标CI=&quot;</span>,CI)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;一致性比例CR=&quot;</span>,CR)<br><br><span class="hljs-keyword">if</span> CR &lt; <span class="hljs-number">0.10</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;一致性可接受&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;一致性不可接受&quot;</span>)<br></code></pre></td></tr></table></figure><p>​    一致性指标CI&#x3D; (0.03761001273071566+0j)<br>​    一致性比例CR&#x3D; (0.04225844127046704+0j)<br>​    一致性可接受<br>​    </p><h4 id="三种方法求权重"><a href="#三种方法求权重" class="headerlink" title="三种方法求权重"></a>三种方法求权重</h4><ol><li>算数平均法求权重</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 定义判断矩阵A</span><br>A = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>], [<span class="hljs-number">1</span>/<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>/<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>/<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>/<span class="hljs-number">5</span>, <span class="hljs-number">1</span>/<span class="hljs-number">2</span>, <span class="hljs-number">1</span>/<span class="hljs-number">2</span>, <span class="hljs-number">1</span>]])<br><br><span class="hljs-comment"># 计算每列的和</span><br><span class="hljs-comment"># 通过np.sum可以计算一维数组中所有元素的和</span><br><span class="hljs-comment"># 还可以通过 axis 参数来计算多维数组的某个维度上的元素总和，例如在二维数组中，axis=0 表示按列计算总和，1 表示按行计算总和</span><br>ASum = np.<span class="hljs-built_in">sum</span>(A, axis=<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 获取A的行和列</span><br>n = A.shape[<span class="hljs-number">0</span>]<br><br><span class="hljs-comment"># 归一化，二维数组除以一维数组会自动将一维数组扩展，然后逐元素进行出除法运算</span><br>Stand_A = A / ASum<br><br><span class="hljs-comment"># 各列相加到同一行</span><br>ASumr = np.<span class="hljs-built_in">sum</span>(Stand_A, axis=<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 计算权重向量</span><br>weights = ASumr / n<br><br><span class="hljs-built_in">print</span>(weights)<br></code></pre></td></tr></table></figure><p>​    [0.48885991 0.18192996 0.2318927  0.09731744]<br>​    </p><ol start="2"><li>几何平均法求权重</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 定义判断矩阵A</span><br>A = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>], [<span class="hljs-number">1</span>/<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>/<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>/<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>/<span class="hljs-number">5</span>, <span class="hljs-number">1</span>/<span class="hljs-number">2</span>, <span class="hljs-number">1</span>/<span class="hljs-number">2</span>, <span class="hljs-number">1</span>]])<br><br><span class="hljs-comment"># 获取A的行和列</span><br>n = A.shape[<span class="hljs-number">0</span>]<br><br><span class="hljs-comment"># 将A中每一行元素相乘得到一列向量</span><br><span class="hljs-comment"># np.prod 函数可以计算一维数组中所有元素的乘积</span><br><span class="hljs-comment"># 还可以通过 axis 参数来计算多维数组的某个维度上的元素总和，例如在二维数组中，axis=0 表示按列计算乘积，1 表示按行计算乘积</span><br>prod_A = np.prod(A, axis=<span class="hljs-number">1</span>)<br><br><br><span class="hljs-comment"># 将新的向量的每个分量开n次方等价求1/n次方</span><br><span class="hljs-comment"># np.power 用于对数组中的元素进行幂运算</span><br><span class="hljs-comment"># np.power(a, b) 表示对a中的所有元素进行b指数运算</span><br>prod_n_A = np.power(prod_A, <span class="hljs-number">1</span>/n)<br><br><span class="hljs-comment"># 归一化处理</span><br>re_prod_A = prod_n_A / np.<span class="hljs-built_in">sum</span>(prod_n_A)<br><br><span class="hljs-built_in">print</span>(re_prod_A)<br><br></code></pre></td></tr></table></figure><p>​    [0.49492567 0.17782883 0.22724501 0.1000005 ]<br>​    </p><ol start="3"><li>特征值求权重</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 定义判断矩阵A</span><br>A = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>], [<span class="hljs-number">1</span>/<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>/<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>/<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>/<span class="hljs-number">5</span>, <span class="hljs-number">1</span>/<span class="hljs-number">2</span>, <span class="hljs-number">1</span>/<span class="hljs-number">2</span>, <span class="hljs-number">1</span>]])<br><br><span class="hljs-comment"># 获取A的行和列</span><br>n = A.shape[<span class="hljs-number">0</span>]<br><br><span class="hljs-comment"># 获取特征值和特征向量</span><br>eig_val, eig_vec = np.linalg.eig(A)<br><br><span class="hljs-comment"># 找出最大特征值的索引</span><br>max_index = np.argmax(eig_val)<br><br><span class="hljs-comment"># # 找出对应的特征向量</span><br>max_vec = eig_vec[:, max_index]<br><br><span class="hljs-comment"># # 对特征向量进行归一化处理</span><br>weights = max_vec / np.<span class="hljs-built_in">sum</span>(max_vec)<br><br><span class="hljs-built_in">print</span>(weights)<br><br></code></pre></td></tr></table></figure><p>[0.4933895 +0.j 0.17884562+0.j 0.230339  +0.j 0.09742588+0.j]</p><h2 id="Topsis算法"><a href="#Topsis算法" class="headerlink" title="Topsis算法"></a>Topsis算法</h2><p>可以翻译为<strong>逼近理想解排序法</strong>，也常简称为<strong>优劣解距离法</strong>，简单而言就是考虑方案距离最优方案（各个属性值都达到<strong>备选方案中最好的值</strong>）、最劣方案的距离（各个属性值都达到<strong>备选方案中最坏的值</strong>）。</p><p>将备选方案与理想解、负理想解对比，若其中一个最接近理想解同时又远离负理想解，则该方案是备选方案中最好的方案。</p><h3 id="Topsis模型"><a href="#Topsis模型" class="headerlink" title="Topsis模型"></a>Topsis模型</h3><p>就是计算出各方案与理想解的距离，也就是贴近度，贴近度取值为0-1，越接近1表示越接近理想解，反之则接近负理想解</p><p>它的基本步骤如下：</p><ul><li><p>原始矩阵正向化</p><p>对于不同指标，最优解有多种可能，最大的、最小的、接近某个值的、处于某个区间的</p><p>正向化就是将各指标与最优解的距离转化为<strong>极大型指标</strong>，极大型指标越大表示越接近最优解</p></li><li><p>正向矩阵标准化</p><p>主要目的是去除量纲的影响，保证不同指标出去同一数量级，且数据<strong>大小排序不变</strong></p></li><li><p>计算得分并归一化<br>$$<br>S_i&#x3D;\frac{D_i^-}{D_i^++D_i^-}\quad\text{其中}S_i\text{为得分,}D_i^+\text{为评价对象与最大值的距离,}D_i^-\text{为评价对象与最小值的距离}<br>$$</p></li><li></li></ul><h3 id="原始矩阵正向化"><a href="#原始矩阵正向化" class="headerlink" title="原始矩阵正向化"></a>原始矩阵正向化</h3><p>正向化就是将所有指标类型统一转化为<strong>极大型指标</strong>（极大型指标即越大越好的指标），其他指标类型有：极小型、中间型、区间型，他们转化为极大型的公式如下：</p><ul><li><p>极大型指标：、</p><p>不需要转换</p></li><li><p>极小型指标：<br>$$<br>\hat{x}&#x3D;max-x\text{,}\hat{x}\text{为转化后指标,}max\text{为指标最大值,}x\text{为指标值}<br>$$</p></li><li><p>中间型指标：<br>$$<br>{x_{i}}\text{是一组中间型序列,最优值是}x_{best}\M&#x3D;max{|x_{i}-x_{best}|}, \hat{x}<em>{i}&#x3D;1-\frac{|x</em>{i}-x_{best}|}{M}<br>$$<br>比如指标x<del>i</del>&#x3D;[5,8,10]，则：</p><p>最优解就是x<del>best</del>&#x3D;7，</p><p>M&#x3D;max{|5-7|，|8-7|，|10-7|}&#x3D;3，</p><p>转换后的指标分别是：1-|5-7|&#x2F;3, 1-|8-7|&#x2F;3, 1-|10-7|&#x2F;3，</p><p>易得在三个值中，8最接近最优7</p></li><li><p>区间型指标：<br>$$<br>{x_{i}}\text{是一组区间型序列,最佳区间为}\left[a,b\right],\text{ 正向化公式如下}\M&#x3D;max{a-min{x_{i}}, max{x_{i}}-b}, \widetilde{x}<em>{i}&#x3D;\begin{cases}1-\frac{a-x</em>{i}}{M}, x_{i}&lt;a\1, a\leq x_{i}\leq b\1-\frac{x_{i}-b}{M}, x_{i}&gt;b\end{cases}<br>$$</p></li></ul><h3 id="正向矩阵标准化"><a href="#正向矩阵标准化" class="headerlink" title="正向矩阵标准化"></a>正向矩阵标准化</h3><p>标准化的目的是<strong>消除不同指标量纲的</strong>影响<br>$$<br>\begin{aligned}<br>&amp;X&#x3D;\begin{bmatrix}x_{11}&amp;\cdots&amp;x_{1m}\\vdots&amp;\ddots&amp;\vdots\x_{n1}&amp;\cdots&amp;x_{nm}\end{bmatrix} \<br>&amp;\text{那么,对其标准化的矩阵记为}Z\text{,}Z\text{中的每一个元素}: \<br>&amp;z_{ij}&#x3D;\frac{x_{ij}}{\sqrt{\Sigma_{i&#x3D;1}^{n}x_{ij}^{2}}}(\text{每一个元素}&#x2F;\sqrt{\text{其所在列的元素的平方和}})<br>\end{aligned}<br>$$<br>标准化后，还需要给不同指标加上权重</p><h3 id="计算得分并归一化"><a href="#计算得分并归一化" class="headerlink" title="计算得分并归一化"></a>计算得分并归一化</h3><ul><li><p>$$<br>定义最大值 ( Z^+ &#x3D; (Z_1^+, Z_2^+, …, Z_m^+) &#x3D; ( \max{z_{11}, z_{21}, …, z_{n1}}, \max{z_{12}, z_{22}, …, z_{n2}}, …, \max{z_{1m}, z_{2m}, …, z_{nm}} )<br>$$</p></li><li><p>$$<br>定义最小值 Z^- &#x3D; (Z_1^-, Z_2^-, …, Z_m^-) &#x3D; ( \min{z_{11}, z_{21}, …, z_{n1}}, \min{z_{12}, z_{22}, …, z_{n2}}, …, \min{z_{1m}, z_{2m}, …, z_{nm}})<br>$$</p></li><li><p>$$<br>定义第 i  (i &#x3D; 1, 2, …, n)个评价对象与最大值的距离D_i^+ &#x3D; \sqrt{\sum_{j&#x3D;1}^m (Z_j^+ - z_{ij})^2}<br>$$</p></li><li><p>$$<br>定义第i(i &#x3D; 1, 2, …, n) 个评价对象与最小值的距离D_i^- &#x3D; \sqrt{\sum_{j&#x3D;1}^m (Z_j^- - z_{ij})^2}<br>$$</p></li><li><p>$$<br>那么，我们可以计算出第i( i &#x3D; 1, 2, …, n) 个评价对象未归一化的得分：S_i &#x3D; \frac{D_i^-}{D_i^+ + D_i^-}<br>$$</p></li><li><p>$$<br>很明显0 \leq S_i \leq 1，且S_i越大D_i^- 越小，即越接近最大值<br>$$</p></li><li><p>$$<br>\text{我们可以将得分归一化并换成百分制:}\widetilde{S}<em>\mathrm{i}&#x3D;\frac{S_\mathrm{i}}{\sum</em>{i&#x3D;1}^nS_\mathrm{i}}\times\underline{1}00<br>$$</p></li></ul><h3 id="python代码实现"><a href="#python代码实现" class="headerlink" title="python代码实现"></a>python代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输入参评数目:&quot;</span>)<br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输入指标数目&quot;</span>)<br>m = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输入矩阵类型，用空格分隔:1极大，2极小，3中间，4区间&quot;</span>)<br>kind = <span class="hljs-built_in">input</span>().split(<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输入矩阵&quot;</span>)<br>A = np.zeros(shape=(n,m))       <span class="hljs-comment"># 初始化n行m列的零矩阵A</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    A[i] = <span class="hljs-built_in">input</span>().split(<span class="hljs-string">&quot; &quot;</span>)<br>    A[i] = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">float</span>, A[i]))       <span class="hljs-comment"># 将接受的到的字符串转为浮点数列表</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输入矩阵为，\n&#123;&#125;&quot;</span>, <span class="hljs-built_in">format</span>(A))<br></code></pre></td></tr></table></figure><p>​    输入参评数目:3<br>​    输入指标数目:4<br>​    输入矩阵类型，用空格分隔:1极大，2极小，3中间，4区间<br>​    1 2 3 4<br>​    输入矩阵<br>​    输入矩阵为，<br>​    {} [[  9.  10. 175. 120.]<br>​     [  8.   7. 164.  80.]<br>​     [  6.   3. 157.  90.]]<br>​    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 极小指标转极大指标函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">minTomax</span>(<span class="hljs-params">maxx, x</span>):<br>    x = <span class="hljs-built_in">list</span>(x)     <span class="hljs-comment"># 将输入的指标数据转化为列表</span><br>    ans = [[maxx-e] <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> x]     <span class="hljs-comment"># 计算最大值与每个指标值的差，并放入新列表中</span><br>    <span class="hljs-keyword">return</span> np.array(ans)        <span class="hljs-comment"># 将列表转换为numpy数组并返回</span><br><br><br><span class="hljs-comment"># 中间型转极大指标函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">midTomax</span>(<span class="hljs-params">bestx, x</span>):<br>    x = <span class="hljs-built_in">list</span>(x)<br>    h = [<span class="hljs-built_in">abs</span>(e-bestx) <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> x]<br>    M = <span class="hljs-built_in">max</span>(h)<br>    <span class="hljs-keyword">if</span> M == <span class="hljs-number">0</span>:<br>        M = <span class="hljs-number">1</span>       <span class="hljs-comment"># 防止最大差值为0的情况</span><br>    ans = [[(<span class="hljs-number">1</span>-e/M)] <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> h]        <span class="hljs-comment"># 计算每个差值占最大差值的比例，并从1中减去，得到新指标值</span><br>    <span class="hljs-keyword">return</span> np.array(ans)<br><br><br><span class="hljs-comment"># 区间型转极大指标函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">regTomax</span>(<span class="hljs-params">lowx, hightx, x</span>):<br>    x = <span class="hljs-built_in">list</span>(x)<br>    M = <span class="hljs-built_in">max</span>(lowx-<span class="hljs-built_in">min</span>(x), <span class="hljs-built_in">max</span>(x)-hightx)     <span class="hljs-comment"># 计算指标值超出区间的最大距离</span><br>    <span class="hljs-keyword">if</span> M == <span class="hljs-number">0</span>:<br>        M = <span class="hljs-number">1</span>       <span class="hljs-comment"># 防止最大距离为0的情况</span><br>    ans = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x)):<br>        <span class="hljs-keyword">if</span> x[i]&lt;lowx:<br>            ans.append([<span class="hljs-number">1</span>-(lowx-x[i])/M])<br>        <span class="hljs-keyword">elif</span> x[i]&gt;hightx:<br>            ans.append([(<span class="hljs-number">1</span>-(x[i]-hightx)/M)])<br>        <span class="hljs-keyword">else</span>:<br>            ans.append([<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> np.array(ans)<br><span class="hljs-comment"># 统一指标类型，将所有指标转化为极大型指标</span><br>X = np.zeros(shape=(n,<span class="hljs-number">1</span>))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>    <span class="hljs-keyword">if</span> kind[i]==<span class="hljs-string">&quot;1&quot;</span>:        <span class="hljs-comment"># 极大型</span><br>        v = np.array(A[:, i])<br>    <span class="hljs-keyword">elif</span> kind[i]==<span class="hljs-string">&quot;2&quot;</span>:      <span class="hljs-comment"># 极小型</span><br>        maxA = <span class="hljs-built_in">max</span>(A[:, i])<br>        v = minTomax(maxA, A[:, i])<br>    <span class="hljs-keyword">elif</span> kind[i]==<span class="hljs-string">&quot;3&quot;</span>:      <span class="hljs-comment"># 中间型</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请输入最优值:&quot;</span>)<br>        bestA = <span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>())<br>        v = midTomax(bestA, A[:, i])<br>    <span class="hljs-keyword">elif</span> kind[i]==<span class="hljs-string">&quot;4&quot;</span>:      <span class="hljs-comment"># 区间型</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请输入区间[a,b]值a:&quot;</span>)<br>        lowA = <span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>())<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请输入区间[a,b]值b:&quot;</span>)<br>        hightA = <span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>())<br>        v = regTomax(lowA, hightA, A[:, i])<br>    <span class="hljs-keyword">if</span> i==<span class="hljs-number">0</span>:<br>        X = v.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)        <span class="hljs-comment"># 如果是第一个指标，直接替换X数组</span><br>    <span class="hljs-keyword">else</span>:<br>        X = np.hstack([X, v.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)])        <span class="hljs-comment"># 如果不是第一个指标，则将新指标拼接到X数组上</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;统一指标后矩阵为,\n&#123;&#125;&quot;</span>, <span class="hljs-built_in">format</span>(X))<br><br></code></pre></td></tr></table></figure><p>​    请输入最优值:<br>​    请输入区间[a,b]值a:<br>​    请输入区间[a,b]值b:<br>​    统一指标后矩阵为,<br>​    {} [[9.  0.  0.  0. ]<br>​     [8.  3.  0.9 0.5]<br>​     [6.  7.  0.2 1. ]]<br>​    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 对同一指标后的矩阵X进行标准化处理</span><br>X = X.astype(<span class="hljs-string">&#x27;float&#x27;</span>)       <span class="hljs-comment">#  确保X矩阵的数据类型为浮点数</span><br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>    X[:, j] = X[:, j]/np.sqrt(<span class="hljs-built_in">sum</span>(X[:, j]**<span class="hljs-number">2</span>))      <span class="hljs-comment"># 对每一列进行归一化处理</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;标准化矩阵为:\n &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(X))<br></code></pre></td></tr></table></figure><p>​    标准化矩阵为:<br>​     [[0.66896473 0.         0.         0.        ]<br>​     [0.59463532 0.3939193  0.97618706 0.4472136 ]<br>​     [0.44597649 0.91914503 0.21693046 0.89442719]]<br>​    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 最大值最小值距离的计算</span><br>x_max = np.<span class="hljs-built_in">max</span>(X, axis=<span class="hljs-number">0</span>)       <span class="hljs-comment"># 计算标准化矩阵每列的最大值</span><br>x_min = np.<span class="hljs-built_in">min</span>(X, axis=<span class="hljs-number">0</span>)       <span class="hljs-comment"># 计算标准化矩阵每列的最小值</span><br>d_z = np.sqrt(np.<span class="hljs-built_in">sum</span>(np.square((X - np.tile(x_max, (n, <span class="hljs-number">1</span>)))), axis=<span class="hljs-number">1</span>))      <span class="hljs-comment"># 计算每个参评对象与最优情况的距离d+</span><br>d_f = np.sqrt(np.<span class="hljs-built_in">sum</span>(np.square((X - np.tile(x_min, (n,<span class="hljs-number">1</span>)))), axis=<span class="hljs-number">1</span>))       <span class="hljs-comment"># 计算每个参评对象与最劣情况的距离d-</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;每个指标的最大值:&quot;</span>, x_max)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;每个指标的最小值:&quot;</span>, x_min)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;d+向量:&quot;</span>, d_z)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;d-向量:&quot;</span>, d_f)<br></code></pre></td></tr></table></figure><p>​    每个指标的最大值: [0.66896473 0.91914503 0.97618706 0.89442719]<br>​    每个指标的最小值: [0.44597649 0.         0.         0.        ]<br>​    d+向量: [1.61175952 0.69382053 0.79132442]<br>​    d-向量: [0.22298824 1.15334862 1.30072534]<br>​    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 计算每个参评对象的得分排名</span><br>s = d_f/(d_z+d_f)<br>Score = <span class="hljs-number">100</span>*s/<span class="hljs-built_in">sum</span>(s)    <span class="hljs-comment"># 得分转百分制</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(Score)):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;第<span class="hljs-subst">&#123;i+<span class="hljs-number">1</span>&#125;</span>个标准化后百分制得分为:<span class="hljs-subst">&#123;Score[i]&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>​    第1个标准化后百分制得分为:8.886366735657832<br>​    第2个标准化后百分制得分为:45.653341055701134<br>​    第3个标准化后百分制得分为:45.46029220864103<br>​    </p><h2 id="熵权算法"><a href="#熵权算法" class="headerlink" title="熵权算法"></a>熵权算法</h2><p>熵是系统无序&#x2F;混乱程序的一个度量，可以用来衡量指标的离散程度，<strong>如果某项指标的值全部相等，则在评价中不起作用，权重也就是变小</strong></p><p>熵权法是一种<strong>客观的赋权方法</strong>，它可以靠数据本身得出权重</p><p><strong>指标的变异程度越小，所反映的信息就越少，对用的权值也应该越低</strong></p><h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><ul><li><p>矩阵正向化</p><p>和topsis一样</p></li><li><p>数据标准化<br>$$<br>\text{对标准化的矩阵记为}Z\text{,则 z}<em>{ij}&#x3D;\frac{x</em>{ij}}{\sqrt{\sum_{i&#x3D;1}^nx_{ij}^2}}\quad\text{如果}x_{ij}\text{存在负数,则标准矩阵}\quad\tilde{Z}&#x3D;\frac{x-min{x_{1j},x_{2j},…,x_{nj}}}{max{x_{1j},x_{2j},…,x_{nj}}-min{x_{1j},x_{2j},…,x_{nj}}}<br>$$</p></li><li><p>计算概率矩阵P<br>$$<br>\text{计算第 j项指标下第 i个样本所占的比重 }p_{ij}&#x3D;\frac{\tilde{z}<em>{ij}}{\sum</em>{i&#x3D;1}^{n}\tilde{z}_{ij}}<br>$$</p></li><li><p>计算熵权<br>$$<br>e_j&#x3D;-\frac{1}{\ln n}\sum_{i&#x3D;1}^np_{ij}\ln(p_{ij})(j&#x3D;1,2,…,m)\quad d_j&#x3D;1-e_j\quad W_j&#x3D;\frac{a_j}{\sum_{j&#x3D;1}^md_j}<br>$$</p></li><li></li></ul><h3 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 定义一个对数函数，用于处理输入数组中的0元素</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mylog</span>(<span class="hljs-params">p</span>):<br>    n = <span class="hljs-built_in">len</span>(p)      <span class="hljs-comment"># 获取向量p的长度</span><br>    lnp = np.zeros(n)       <span class="hljs-comment"># 创建一个长度n，元素为0的新数组lnp</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):      <span class="hljs-comment"># 遍历向量的每个元素</span><br>        <span class="hljs-keyword">if</span> p[i] == <span class="hljs-number">0</span>:<br>            lnp[i] = <span class="hljs-number">0</span>      <span class="hljs-comment"># 在lnp中设置为0，因为log(0)未定义，这里规定为0</span><br>        <span class="hljs-keyword">else</span>:<br>            lnp[i] = np.log(p[i])     <span class="hljs-comment"># 不为0则计算后存入lnp</span><br>    <span class="hljs-keyword">return</span> lnp<br><br><br><span class="hljs-comment"># 定义一个指标矩阵X</span><br>X = np.array([[<span class="hljs-number">9</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], [<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0.9</span>,<span class="hljs-number">0.5</span>], [<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0.2</span>,<span class="hljs-number">1</span>]])<br><br><span class="hljs-comment"># 对矩阵X进行标准化，得到标准化矩阵Z</span><br>Z = X / np.sqrt(np.<span class="hljs-built_in">sum</span>(X*X, axis=<span class="hljs-number">0</span>))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;标准化矩阵Z为：&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(Z))<br><br></code></pre></td></tr></table></figure><p>​    标准化矩阵Z为：[[0.66896473 0.         0.         0.        ]<br>​     [0.59463532 0.3939193  0.97618706 0.4472136 ]<br>​     [0.44597649 0.91914503 0.21693046 0.89442719]]<br>​    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 计算熵权所需的变量和矩阵初始化</span><br>n, m = Z.shape      <span class="hljs-comment"># 获取Z的行数和列数</span><br>D = np.zeros(m)     <span class="hljs-comment"># 初始化一个长度m的数组D，用于保存每个指标的信息效用值</span><br><br><br><span class="hljs-comment"># 计算每个指标的信息效用值</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):      <span class="hljs-comment"># 遍历Z的每一列</span><br>    x = Z[:,i]      <span class="hljs-comment"># 获取Z的第i列</span><br>    p = x / np.<span class="hljs-built_in">sum</span>(x)       <span class="hljs-comment"># 对第i个指标归一化，得到概率分布p</span><br>    <span class="hljs-comment"># 计算对数</span><br>    e = -np.<span class="hljs-built_in">sum</span>(p * mylog(p)) / np.log(n)       <span class="hljs-comment"># 根据熵的定义计算第i个指标的信息熵e</span><br>    D[i] = <span class="hljs-number">1</span> - e        <span class="hljs-comment"># 根据信息效用值的定义计算D[i]</span><br><br><span class="hljs-comment"># 根据信息效用值计算各指标的权重</span><br>W = D / np.<span class="hljs-built_in">sum</span>(D)       <span class="hljs-comment"># 将信息效用值D归一化，得到各指标的权重W</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;权重W=&quot;</span>)<br><span class="hljs-built_in">print</span>(W)<br><br></code></pre></td></tr></table></figure><p>​    权重W&#x3D;<br>​    [-0.28664984  0.12885848  0.45522308  0.70256829]<br>​    </p><h2 id="模糊综合评价"><a href="#模糊综合评价" class="headerlink" title="模糊综合评价"></a>模糊综合评价</h2><p>对于性别、身高、体重可以很容易的得到答案，这些是<strong>确定性概念</strong>。</p><p>但对于胖瘦美丑这些就不好确定了，多胖算胖，怎么样算好看，这些就是<strong>模糊性概念</strong></p><h3 id="模糊集合和隶属函数"><a href="#模糊集合和隶属函数" class="headerlink" title="模糊集合和隶属函数"></a>模糊集合和隶属函数</h3><ul><li><p>模糊集合：</p><p>用来描述模糊性概念的集合（美丑高低胖瘦）</p></li><li><p>隶属函数：</p><p>模糊集合用隶属函数来刻画，确定X上的一个模糊集合A，u<del>A</del>叫做A的隶属函数，u<del>A</del>(x)叫做x对模糊集A的隶属度</p></li></ul><p>举个例子，模糊集合A&#x3D;“年轻”，X&#x3D;（0，150）表示年龄的集合</p><p>定义隶属函数<br>$$<br>\mu_A\left(x\right)&#x3D;\begin{cases}1,0&lt;x&lt;20\\frac{40-x}{20},20\leq x\leq40\0,40&lt;x&lt;150\end{cases}<br>$$<br>意思是：小于20岁必定属于年轻；处于20到40之间的，随着年龄加大，与模糊集合A的隶属度越来越低，其中30岁为50%最为模糊；大于40则一定不属于年轻</p><ul><li><p>模糊集合的表示方式：</p><ol><li><p>zadeh表示法<br>$$<br>A&#x3D;\sum_{i&#x3D;1}^n\frac{\mu_A\left(i\right)}{x_i}&#x3D;\frac{\mu_A\left(x_1\right)}{x_1}+\frac{\mu_A\left(x_2\right)}{x_2}+\cdots+\frac{\mu_A\left(x_n\right)}{x_n}\<br>\text{注:“}\Sigma\text{”和“}+\text{”不是求和的意思,只是概括集合的记号}\\frac{\mu_A(i)}{x_i}\text{也不是分数,它表示点}x_i\text{对模糊集A的隶属度是}\mu_A(x)<br>$$</p></li><li><p>序偶表示法<br>$$<br>A&#x3D;{(x_1,\mu_A(x_1)),(x_2,\mu_A(x_2)),…,(x_n,\mu_A(x_n))}<br>$$</p></li><li><p>向量表示法<br>$$<br>A&#x3D;\begin{pmatrix}\mu_A(x_1),\mu_A(x_2),…,\mu_A(x_n)\end{pmatrix}<br>$$</p></li><li><p>当X为无限集时，X上的模糊集A可以写成<br>$$<br>A&#x3D;\int\limits_{x\in X}\frac{\mu_A(x)}x\quad {注:“ \int ”不是积分的意思,}\frac{\mu_A(x_i)}x{也不是分数}<br>$$</p></li></ol></li><li><p>隶属函数的确定：</p><ol><li><p>模糊统计法：</p><p>找多个人对同一个模糊概念进行描述，用<strong>隶属频率</strong>去定义隶属度。</p><p>例如：30岁相对于年轻的隶属度，询问n个人，其中m个人认为30岁属于年轻，则隶属度为m&#x2F;n</p></li><li><p>借助已有的客观尺度：</p><p>某些模糊概念，可以用<strong>已有的指标</strong>去衡量隶属度。</p><p>例如：小康家庭，可以用“恩格尔系数（食品支出&#x2F;总支出）”去衡量，所以“1-恩格尔系数”看成隶属度</p></li><li><p>指派法：</p><p>主观性较强，在确定模糊集合的所属分类后，给它指派一个隶属函数，指派的隶属函数可以在常用的模糊分布中找</p><p><img src="https://img-blog.csdnimg.cn/20190506222358274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5ODMxMTYz,size_16,color_FFFFFF,t_70"></p></li></ol></li></ul><h3 id="评价问题"><a href="#评价问题" class="headerlink" title="评价问题"></a>评价问题</h3><p>在模糊综合评价中，引入三个集合：</p><ol><li>因素集（评价指标集）U</li><li>评语集（评价的结果）V</li><li>权重集（指标的权重）A</li></ol><p>例如：评价一名学生的表现</p><p>U&#x3D;{专业排名，课外实践，志愿服务，竞赛成绩}</p><p>V&#x3D;{优，良，差}</p><p>A&#x3D;{0.4，0.2，0.1，0.3}</p><h3 id="一级模糊综合评价"><a href="#一级模糊综合评价" class="headerlink" title="一级模糊综合评价"></a>一级模糊综合评价</h3><ol><li><p>确定因素集U</p></li><li><p>确定评语集V</p></li><li><p>确定各因素权重A</p></li><li><p>确定模糊综合判断矩阵R</p><p>矩阵R每一行代表一个因素，行内的各个元素表示该因素对各个评语的隶属度</p><p>比如：</p><p>员工的综合评分，因素可以是政治表现，工作态度，评语是优良差，那么：</p><p>第一行【0.1 0.5 0.4】表示则政治表现对于优的隶属度为0.1，良的隶属度是0.5，差的隶属度是0.4</p><p>第二行【…】表示工作态度对于……</p></li><li><p>进行矩阵合成运算<br>$$<br>B&#x3D;A*R<br>$$<br>得到一个行向量，这个行向量就是该员工对于评语集的隶属度，最大隶属度对应的评语就是该员工的评价。</p></li></ol><h3 id="多层次模糊综合评价"><a href="#多层次模糊综合评价" class="headerlink" title="多层次模糊综合评价"></a>多层次模糊综合评价</h3><ol><li><p>给出被评价的对象集合X</p></li><li><p>确定因素（指标）集U，如果有较多因素，可以将因素按<strong>某些属性</strong>分为s个子集，U<del>i</del>表示第i个子集，u^(i)^<del>1</del>表示第i个子集中的第1个元素，这些子集满足以下条件：</p><ol><li>子集个数为s</li><li>所有子集取并集，为因素集U</li><li>任意两个子集取交集，为空集</li></ol></li><li><p>确定评语集V</p></li><li><p>由子集U<del>i</del>与评语集V获得评价矩阵R<del>i</del></p></li><li><p>对每一个U<del>i</del>，分别做出综合决策：</p><p>设U<del>i</del>中的各个因素权重分配为A<del>i</del>，可得到一级评价向量：<br>$$<br>B_{i}&#x3D;A_{i}\times R_{i}<br>$$</p></li><li><p>U的单元素判断矩阵为：<br>$$<br>R&#x3D;\begin{bmatrix}B_1\B_2\\vdots\B_s\end{bmatrix}&#x3D;\begin{bmatrix}b_{11}&amp;b_{12}&amp;\cdots&amp;b_{1m}\\vdots&amp;\vdots&amp;\vdots&amp;\vdots\\vdots&amp;\vdots&amp;\vdots&amp;\vdots\b_{s1}&amp;b_{s2}&amp;\cdots&amp;b_{sm}\end{bmatrix}<br>$$<br>每个U<del>i</del>作为U的一部分，反映了U的某种属性，可以按重要性给出权重分配A</p><p>接着得到二级模糊综合评价<br>$$<br>B&#x3D;A \times R<br>$$<br>若U<del>i</del>仍有较多因素，可以进行在划分，得到更高级的模型，计算方式与二级一致，从最低级算起</p></li></ol><h3 id="模糊综合评价PYTHON实现"><a href="#模糊综合评价PYTHON实现" class="headerlink" title="模糊综合评价PYTHON实现"></a>模糊综合评价PYTHON实现</h3><h4 id="一级模糊综合评价-1"><a href="#一级模糊综合评价-1" class="headerlink" title="一级模糊综合评价"></a>一级模糊综合评价</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 一级模糊综合评价</span><br><span class="hljs-comment"># 各因素的单元素评价矩阵</span><br>R23 = np.array(<br>    [<br>        [<span class="hljs-number">0.18</span>, <span class="hljs-number">0.14</span>, <span class="hljs-number">0.18</span>, <span class="hljs-number">0.14</span>, <span class="hljs-number">0.13</span>, <span class="hljs-number">0.23</span>],<br>        [<span class="hljs-number">0.15</span>, <span class="hljs-number">0.20</span>, <span class="hljs-number">0.15</span>, <span class="hljs-number">0.25</span>, <span class="hljs-number">0.10</span>, <span class="hljs-number">0.15</span>],<br>        [<span class="hljs-number">0.25</span>, <span class="hljs-number">0.12</span>, <span class="hljs-number">0.13</span>, <span class="hljs-number">0.12</span>, <span class="hljs-number">0.18</span>, <span class="hljs-number">0.20</span>],<br>        [<span class="hljs-number">0.16</span>, <span class="hljs-number">0.15</span>, <span class="hljs-number">0.21</span>, <span class="hljs-number">0.11</span>, <span class="hljs-number">0.20</span>, <span class="hljs-number">0.17</span>],<br>        [<span class="hljs-number">0.23</span>, <span class="hljs-number">0.18</span>, <span class="hljs-number">0.17</span>, <span class="hljs-number">0.16</span>, <span class="hljs-number">0.15</span>, <span class="hljs-number">0.11</span>],<br>        [<span class="hljs-number">0.19</span>, <span class="hljs-number">0.13</span>, <span class="hljs-number">0.12</span>, <span class="hljs-number">0.12</span>, <span class="hljs-number">0.11</span>, <span class="hljs-number">0.33</span>],<br>        [<span class="hljs-number">0.17</span>, <span class="hljs-number">0.16</span>, <span class="hljs-number">0.15</span>, <span class="hljs-number">0.08</span>, <span class="hljs-number">0.25</span>, <span class="hljs-number">0.19</span>],<br>    ]<br>)<br><br><span class="hljs-comment"># 权重分配为</span><br>A23 = np.array([<span class="hljs-number">0.20</span>, <span class="hljs-number">0.15</span>, <span class="hljs-number">0.10</span>, <span class="hljs-number">0.10</span>, <span class="hljs-number">0.20</span>, <span class="hljs-number">0.15</span>, <span class="hljs-number">0.10</span>])<br><span class="hljs-comment"># 评价结果</span><br><span class="hljs-comment"># np.dot 函数用于计算两个数组的点积，对于一维数组，计算的是两个数组的内积</span><br><span class="hljs-comment"># 对于二维数组，计算的是矩阵乘法</span><br>B23 = np.dot(A23, R23)<br><br><span class="hljs-built_in">print</span>(B23)<br></code></pre></td></tr></table></figure><p>  [0.191  0.1565 0.1595 0.1465 0.1505 0.196 ]</p><h4 id="多级模糊评价"><a href="#多级模糊评价" class="headerlink" title="多级模糊评价"></a>多级模糊评价</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 产品情况的二级评判如下</span><br>R1 = np.array(<br>    [<br>        [<span class="hljs-number">0.12</span>, <span class="hljs-number">0.18</span>, <span class="hljs-number">0.17</span>, <span class="hljs-number">0.23</span>, <span class="hljs-number">0.13</span>, <span class="hljs-number">0.17</span>],<br>        [<span class="hljs-number">0.15</span>, <span class="hljs-number">0.13</span>, <span class="hljs-number">0.18</span>, <span class="hljs-number">0.25</span>, <span class="hljs-number">0.12</span>, <span class="hljs-number">0.17</span>],<br>        [<span class="hljs-number">0.14</span>, <span class="hljs-number">0.13</span>, <span class="hljs-number">0.16</span>, <span class="hljs-number">0.18</span>, <span class="hljs-number">0.20</span>, <span class="hljs-number">0.19</span>],<br>        [<span class="hljs-number">0.12</span>, <span class="hljs-number">0.14</span>, <span class="hljs-number">0.15</span>, <span class="hljs-number">0.17</span>, <span class="hljs-number">0.19</span>, <span class="hljs-number">0.23</span>],<br>        [<span class="hljs-number">0.16</span>, <span class="hljs-number">0.12</span>, <span class="hljs-number">0.13</span>, <span class="hljs-number">0.25</span>, <span class="hljs-number">0.18</span>, <span class="hljs-number">0.16</span>],<br>    ]<br>)<br>A1 = np.array([<span class="hljs-number">0.15</span>, <span class="hljs-number">0.40</span>, <span class="hljs-number">0.25</span>, <span class="hljs-number">0.10</span>, <span class="hljs-number">0.10</span>])<br>B1 = np.dot(A1, R1)<br><br><span class="hljs-comment"># 销售能里二级评价如下</span><br>R2 = np.array(<br>    [<br>        [<span class="hljs-number">0.13</span>, <span class="hljs-number">0.15</span>, <span class="hljs-number">0.14</span>, <span class="hljs-number">0.18</span>, <span class="hljs-number">0.16</span>, <span class="hljs-number">0.25</span>],<br>        [<span class="hljs-number">0.12</span>, <span class="hljs-number">0.16</span>, <span class="hljs-number">0.13</span>, <span class="hljs-number">0.17</span>, <span class="hljs-number">0.19</span>, <span class="hljs-number">0.23</span>],<br>        B23,<br>        [<span class="hljs-number">0.14</span>, <span class="hljs-number">0.13</span>, <span class="hljs-number">0.15</span>, <span class="hljs-number">0.16</span>, <span class="hljs-number">0.18</span>, <span class="hljs-number">0.24</span>],<br>        [<span class="hljs-number">0.16</span>, <span class="hljs-number">0.15</span>, <span class="hljs-number">0.15</span>, <span class="hljs-number">0.17</span>, <span class="hljs-number">0.18</span>, <span class="hljs-number">0.19</span>],<br>    ]<br>)<br>A2 = np.array([<span class="hljs-number">0.2</span>, <span class="hljs-number">0.15</span>, <span class="hljs-number">0.25</span>, <span class="hljs-number">0.25</span>, <span class="hljs-number">0.15</span>])<br>B2 = np.dot(A2, R2)<br><br><span class="hljs-comment"># 市场需求的二级评价</span><br>R3 = np.array(<br>    [[<span class="hljs-number">0.15</span>, <span class="hljs-number">0.14</span>, <span class="hljs-number">0.13</span>, <span class="hljs-number">0.18</span>, <span class="hljs-number">0.14</span>, <span class="hljs-number">0.26</span>], [<span class="hljs-number">0.16</span>, <span class="hljs-number">0.15</span>, <span class="hljs-number">0.18</span>, <span class="hljs-number">0.14</span>, <span class="hljs-number">0.16</span>, <span class="hljs-number">0.21</span>]]<br>)<br>A3 = np.array([<span class="hljs-number">0.55</span>, <span class="hljs-number">0.45</span>])<br>B3 = np.dot(A3, R3)<br><br><br><span class="hljs-comment"># 三级模糊综合评判</span><br>R = np.array([B1, B2, B3])<br>A = np.array([<span class="hljs-number">0.4</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.3</span>])<br>B = np.dot(A, R)<br><br><span class="hljs-built_in">print</span>(B)<br><br></code></pre></td></tr></table></figure><p>  [0.147975  0.1427875 0.1561625 0.1862875 0.1575375 0.20985  ]</p><h1 id="控制预测类"><a href="#控制预测类" class="headerlink" title="控制预测类"></a>控制预测类</h1><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p><strong>线性回归</strong>指的是确定<strong>两种或两种以上变量间互相依赖的定量关系</strong>。根据涉及变量的多少，分为<strong>一元回归</strong>和<strong>多元回归</strong>；按照因变量的多少，可分为<strong>简单回归</strong>和<strong>多重回归分析</strong>;按照自变量和因变量之间的关系类型，可以分为<strong>线性回归</strong>和<strong>非线性回归</strong>。所以回归分析一般包括四个方向：<strong>一元线性回归分析、多元线性回归分析、一元非线性回归分析、多元非线性回归分析</strong></p><p>回归分析的一般步骤为：</p><ul><li>确定回归方程中的解释变量和被解释变量（自变量因变量）</li><li>确定回归模型、建立回归方程</li><li>对回归方程进行检验</li><li>利用回归方程进行预测</li></ul><p>回归模型基本概念：</p><ul><li>自变量：预测或解释因变量和一个或多个变量，用x表示</li><li>因变量：被预测或解释的变量，用y表示</li><li>描述y如何依赖于x和误差项€的方程称为回归模型</li></ul><p>以一元线性回归分析为例：<br>$$<br>\begin{aligned}<br>&amp;\bullet\text{ 对于只涉及一个自变量的一元线性回归模型可表示为} \<br>&amp;y&#x3D;\beta_0+\beta_1x+\epsilon \<br>&amp;在这个模型里: \<br>&amp;&amp;\text{一} \<br>&amp;\begin{aligned}&amp;\checkmark\quad x\text{叫做自变量或解释变量}\&amp;\checkmark\quad\beta_0\text{表示截距}\&amp;\checkmark\quad\beta_1\text{表示斜率}\end{aligned} \</p><p>&amp;{\epsilon\text{表示误差项,反映除}x\text{和}y\text{之间的线性关系之外的随机因素对}y}\text{的影响,是不可避免的}<br>\end{aligned}<br>$$</p><h3 id="回归方程"><a href="#回归方程" class="headerlink" title="回归方程"></a>回归方程</h3><p>描述因变量的<strong>期望值</strong>如何依赖于自变量的方程称为回归方程，对一元线性回归模型假设，可得到他的回归方程为：<br>$$<br>E(y)&#x3D;\beta_0+\beta_1x<br>$$<br>如果回归方程中的参数已知，对于给定的x，利用回归方程就能计算出y的期望值</p><p>用样本统计量代替回归方程中的未知参数，就能得到估计的回归方程，即回归直线</p><p>参数可以用<strong>最小二乘法</strong>估计，它是使观察值y与估计值之间的离差平方和<strong>达到最小</strong>来求解的：<br>$$<br>Q&#x3D;\sum(y-\hat{y})^2&#x3D;\sum(y-\hat{\beta}_0-\hat{\beta}_1x)^2&#x3D;\<br>\sum y^2+n\hat{\beta}_0^2+\hat{\beta}_1^2\Sigma x^2+2\hat{\beta}_0\hat{\beta}_1\Sigma x-2\hat{\beta}_0\sum y-2\hat{\beta}_1\Sigma xy<br>$$</p><p>可得：<br>$$<br>\begin{cases}\hat{\beta}_1&#x3D;\frac{n\sum xy-\sum x\sum y}{n\sum x^2-(\sum x)^2}\\hat{\beta}_0&#x3D;\bar{y}-\hat{\beta}_1\bar{x}\end{cases}<br>$$</p><p>利用回归直线就可以对数据进行预测，预测分为<strong>点估计和区间估计</strong></p><p>计算<strong>估计标准差</strong>：</p><p>为了度量回归方程的可靠性，通常计算<strong>估计标准差</strong>，它度量观察值回绕着回归直线的变化程度或离散程度<br>$$<br>S_e&#x3D;\sqrt{\frac{\sum(y-\hat{y})^2}{n-2}}<br>$$<br>估计标准差<strong>越大</strong>，则数据点围绕回归直线的离散程度就<strong>越大</strong>，回归方程的代表性就<strong>越小</strong></p><p>估计标准差<strong>越小</strong>，则数据点围绕回归直线的离散程度就<strong>越小</strong>，回归方程的代表性就<strong>越大</strong>，越<strong>可靠</strong></p><p><strong>置信区间和预测区间</strong>的计算：<br>$$<br>\text{ 置信区间: } \widehat{y}<em>0\pm t</em>{\frac{\alpha}{2}}s_e\sqrt{\frac{1}{n}+\frac{(x_0-\bar{x})^2}{\sum(x-\bar{x})^2}}\<br>t_{\frac{\alpha}{2}}是通过查t分布表(或者t分布工具计算，自由度为残差自由度即样本个数-自变量个数-1)获得，{\alpha}表示显著性水平，一般默认0.05,1-{\alpha}表示置信水平<br>$$</p><p>$$<br>\text{预测区间:}\widehat{y}<em>0\pm t</em>{\frac\alpha2}s_e\sqrt{1+\frac1n+\frac{(x_0-\bar{x})^2}{\sum(x-\bar{x})^2}}<br>$$</p><p><strong>回归模型</strong>的验证：</p><p>回归直线与各观测点的接近程度称为<strong>回归直线对数据的拟合优度</strong>：</p><ul><li><p>总平方和（TSS）:反映因变量的n个观察值与其均值的总离差<br>$$<br>TSS&#x3D;\sum y_i^2&#x3D;\sum({y_i}-{\bar{y_i}})^2<br>$$</p></li><li><p>回归平方和（ESS&#x2F;SSR）：反映y的总变差中，由于x与y之间的线性关系引起的y的变化部分<br>$$<br>ESS&#x3D;\sum\hat{y}_i^2&#x3D;\sum(\hat{y}_i-\bar{y}_i)^2<br>$$</p></li><li><p>残差平方和（RSS&#x2F;SSE）：反映了除了x对y的线性影响之外的其他因素对y变差的作用，是不能由回归直线来解释的y的变差部分<br>$$<br>RSS&#x3D;\sum e_i^2&#x3D;\sum(y_i-\hat{y}_i)^2<br>$$<br>三者存在关系：<br>$$<br>TSS&#x3D;ESS+RSS<br>$$</p></li></ul><p><strong>判定系数R^2^</strong>:</p><p>R^2^表示<strong>回归平方和与总平方和的比例</strong>，其值在0-1之间：<br>$$<br>R^{2}&#x3D;\frac{\mathrm{ESS}}{TSS}&#x3D;1-\frac{\mathrm{RSS}}{TSS}&#x3D;\frac{\sum(\hat{y}<em>{i}-\bar{y}</em>{i})^{2}}{\sum(y_{i}-\bar{y}<em>{i})^{2}}&#x3D;1-\frac{\sum(y</em>{i}-\hat{y}<em>{i})^{2}}{\sum(y</em>{i}-\bar{y}_{i})^{2}}<br>$$<br>为0：说明y的变化与x无关，x完全无助于解释y的变差</p><p>为1：说明残差平方和为0，拟合是完全的，y的变化只与x有关</p><p><strong>显著性检验：</strong></p><ul><li><p>线性关系检验：</p><p>用来<strong>检验自变量x和因变量y之间的线性关系是否显著</strong></p><p>将<strong>均方回归（MSR）同均方残差（MSE）加以比较</strong>，应用F检验来分析二者之间的差别是否显著</p><ul><li>均方回归（MSR）：回归平方和（ESS）除以相应的回归自由度（自变量个数k）</li><li>均方残差（MSE）：残差平方和（RSS）除以相应的残差自由度（n-k-1）</li></ul><p><strong>H<del>0</del>（原假设）：</strong>β<del>1</del>&#x3D;0，回归系数与0无显著差异，y与x的线性关系不显著</p><p>**H<del>1</del>**：β<del>1</del>≠0，回归显著，认为y与x存在线性关系，所求的线性回归方程有意义</p><p>通过计算<strong>检验统计量F</strong>可以判断哪种成立：<br>$$<br>H_0\text{成立时,}F&#x3D;\frac{ESS&#x2F;1}{RSS&#x2F;(n-2)}&#x3D;\frac{MSR}{MSE}{\sim}F(k,n-k-1)\<br>\text{若}F&gt;F_{1-\alpha}(k,n-k-1)\text{,拒绝}H_0\text{否则接受}H_0\<br>\text{F分布可以通过查表或计算工具得出,}\alpha\text{为显著性水平}<br>$$</p></li><li><p>回归系数检验：<br>$$<br>{\hat{\beta}_1\text{是根据最小二乘法求出的样本统计量,服从正态分布}}\<br>{\hat{\beta}_1\text{的分布具有如下性质}:} \<br>\text{数学期望:}E(\hat{\beta}<em>1)&#x3D;\beta_1 \<br>\text{标准差:}\sigma</em>{\widehat{\beta}<em>1}&#x3D;\frac\sigma{\sqrt{\sum x_i^2-\frac1n(\sum x_i)^2}} \<br>\text{,由于}\sigma\text{未知,需用其估计量}S</em>{\mathrm{e}}\text{来代替得到}\hat{\beta}<em>1\text{的估计标准差} \<br>S</em>{\widehat{\beta}_1}&#x3D;\frac{S_e}{\sqrt{\sum x_i^2-\frac1n(\sum x_i)^2}}\quad\text{, }S_e&#x3D;\sqrt{\frac{\sum(y_i-\hat{y}_i)^2}{n-k-1}}&#x3D;\sqrt{MSE} \<br>\quad t\text{检验的统计量:}\quad t&#x3D;\frac{\widehat{\beta}<em>1-\beta_1}{s</em>{\widehat{\beta}_1}}\thicksim{(n-k-1)}<br>\text{如果服从则接受原假设}\beta&#x3D;0\text{,否则拒绝，说明有显著的线性关系}<br>$$</p></li></ul><h3 id="多元线性回归分析"><a href="#多元线性回归分析" class="headerlink" title="多元线性回归分析"></a>多元线性回归分析</h3><p>$$<br>\begin{gathered}<br>\bullet\text{ 一般称由}y&#x3D;\beta_0+\beta_1x_1+\cdotp\cdotp\cdotp+\beta_kx_k\text{确定的模型}: \<br>\begin{cases}Y&#x3D;X\beta+\epsilon\E(\epsilon)&#x3D;0,COV(\epsilon,\epsilon)&#x3D;\sigma^2I_n\end{cases} \<br>\text{为}k\text{元线性回归模型,并简记为}(Y,X\beta,\sigma^2I_n) \<br>\bullet Y&#x3D;\begin{bmatrix}y_1\y_2\…\y_n\end{bmatrix} ,X&#x3D;\begin{bmatrix}1&amp;x_{11}&amp;x_{12}&amp;…&amp;x_{1k}\1&amp;x_{21}&amp;x_{22}&amp;…&amp;x_{2k}\…&amp;…&amp;…&amp;…&amp;…\1&amp;x_{n1}&amp;x_{n2}&amp;…&amp;x_{nk}\end{bmatrix} ,\beta&#x3D;\begin{bmatrix}\beta_0\\beta_1\…\\beta_k\end{bmatrix} ,\epsilon&#x3D;\begin{bmatrix}\epsilon_1\\epsilon_2\…\\epsilon_n\end{bmatrix} \<br>\bullet{y&#x3D;\beta_0+\beta_1x_1+\cdots+\beta_kx_k}\text{称为回归平面方程}<br>\end{gathered}<br>$$</p><p>用<strong>最小二乘法</strong>求β：离差平方和最小：<br>$$<br>Q&#x3D;\sum_{i&#x3D;1}^n(y_i-\beta_0-\beta_1x_{i1}-\cdots-\beta_kx_{ik})^2<br>$$</p><p>$$<br>\hat{\beta}&#x3D;(X^{T}X)^{-1}(X^{T}Y)<br>$$<br><strong>多元回归模型和回归系数的检验：</strong></p><ul><li><p>F检验法：<br>$$<br>\text{当}H_0\text{成立时;}F&#x3D;\frac{U&#x2F;k}{Q_e&#x2F;(n-k-1)}{\sim}F(k,n-k-1) \<br>\bullet\text{ 如果}F&gt;F_{1-\alpha}(k,n-k-1),\text{ 则拒绝}H_0,\text{ 认为}y\text{与}x_1,\cdotp\cdotp\cdotp,x_k\text{之间显著地有线性关系};\text{ 否则就接受}H_0, \<br>\text{认为}y\text{与}x_1,\cdotp\cdotp\cdotp,x_k\text{之间线性关系不显著。} \<br>\bullet\text{ 其中}U&#x3D;\sum_{i&#x3D;1}^n(\hat{y}<em>i-\bar{y})^2(\text{回归平方和}) \<br>\text{n为样本个数，k为变量个数}\<br>Q</em>{e}&#x3D;\sum_{i&#x3D;1}^{n}(y_{i}-\hat{y}_{i})^{2} (\text{残差平方和})<br>$$<br>F分布可以通过查表或者计算工具获得</p></li><li><p>r检验法：<br>$$<br>R&#x3D;\sqrt{\frac U{L_{yy}}}&#x3D;\sqrt{\frac U{U+Q_e}}<br>$$</p></li></ul><p>R越接近1，说明线性关系越好、</p><p>R和F是等效的，用其中一个进行检验即可</p><p><strong>多元线性回归模型的预测：</strong></p><ul><li><p>点预测：<br>$$<br>\begin{aligned}&amp;\bullet\text{ 求出回归方程}\hat{y}&#x3D;\hat{\beta}_0+\hat{\beta}_1x_1+\cdots+\hat{\beta}_kx_k,\text{ 对于给定自变量的值}x_1^*,\cdots,x_k^<em>\text{,用}\hat{y}^</em>&#x3D;\hat{\beta}_0+\hat{\beta}_1x_1^*+\cdots+\&amp;\hat{\beta}_kx_k^<em>\text{来预测}y^</em>&#x3D;\beta_0+\beta_1x_1^*+\cdots+\beta_kx_k^*+\epsilon,\text{ 称}\hat{y}^<em>\text{为}y^</em>\text{的点预测}\end{aligned}<br>$$</p></li><li><p>区间预测：<br>$$<br>\bullet\text{ y的}1-\alpha\text{的预测区间(置信)区间为}(\hat{y}<em>1,\hat{y}<em>2),\text{ 其中}\\begin{cases}\widehat{y}<em>1&#x3D;\widehat{y}-\widehat{\sigma}<em>e\sqrt{1+\sum</em>{i&#x3D;0}^k\sum</em>{j&#x3D;0}^kc</em>{ij}x_ix_jt</em>{1-\frac\alpha2}(n-k-1)}\\hat{y}<em>2&#x3D;\widehat{y}+\widehat{\sigma}<em>e\sqrt{1+\sum</em>{i&#x3D;0}^k\sum</em>{j&#x3D;0}^kc_{ij}x_ix_jt_{1-\frac\alpha2}(n-k-1)}\end{cases}\<br>\bullet\quad C&#x3D;L^{-1}&#x3D;\left(c_{ij}\right),L&#x3D;X^{\prime}X<br>$$</p></li></ul><p><strong>多元线性回归的逐步回归</strong>：</p><p>“最优”的回归方程就是包含所有对Y有影响的变量，而不包含对Y影响不显著的变量回归方程</p><p>思路：</p><ul><li>从一个自变量开始，根据自变量对Y作用的显著程度（F的大小），从大到小的依次逐个引入回归方程</li><li>当引入的自变量由于后引入的自变量而变得不显著时，要将其剔除掉</li><li>引入或剔除一个自变量为逐步回归的一步</li><li>对于每一步都要进行Y值检验，以确保每次引入新的显著性变量前回归方程中只包含对Y的作用显著的变量</li><li>反复进行，直到满足“最优”</li></ul><h2 id="非线性回归"><a href="#非线性回归" class="headerlink" title="非线性回归"></a>非线性回归</h2><p>对于非线性的关系，需要先<strong>画出散点图</strong>，然后根据散点图<strong>选配曲线</strong>，常见的曲线有：</p><ul><li><p>双曲函数曲线<br>$$<br>\begin{aligned}<br>&amp;\bullet\text{公式：}\<br>&amp;\begin{cases}\widehat{y}&#x3D;\frac{x}{a+bx}\\widehat{y}&#x3D;\frac{a+bx}{x}\\widehat{y}&#x3D;\frac{1}{a+bx}\end{cases}\<br>&amp;\bullet\text{ 变换方式:}\&amp;\hat{y}&#x3D;\frac x{a+bx},\text{ 两边取倒数后,令}y^{\prime}&#x3D;\frac x{\hat{y}},\text{得}y^{\prime}&#x3D;a\underline{x}+b\&amp;\hat{y}&#x3D;\frac{a+bx}x,\text{令}y^{\prime}&#x3D;\hat{y}x\&amp;\text{得}y^{\prime}&#x3D;ax+b\text{ ; }\hat{y}&#x3D;\frac1{a+bx},\text{两边取倒数后}\text{令}y^{\prime}&#x3D;\frac1y,\text{得}y^{\prime}&#x3D;ax+b\end{aligned}<br>$$</p></li><li><p>幂函数曲线<br>$$<br>\widehat{y}&#x3D;ax^b\<br>\text{当 }a&gt;0\text{、}b&gt;1\text{时,}y\text{随}x\text{的增大而增大(增长),是凹曲线}; \<br>\text{当 }a&gt;0\text{、}0&lt;b&lt;1\text{时,}y\text{随}x\text{的增大而增大(增长),但变化缓慢,是凸曲线;} \<br>\text{当 }a&gt;0\text{、}b&lt;0\text{时,}y\text{随}x\text{的增大而减小,且以}x,y\text{轴为渐近线,是凹曲线。}\<br>\bullet\text{ 变换方式: 两边取对数,令}y^{\prime}&#x3D;ln\hat{y},x^{\prime}&#x3D;lnx,a^{\prime}&#x3D;lna,\text{得}y^{\prime}&#x3D;a^{\prime}+bx^{\prime}<br>$$</p></li><li><p>指数函数曲线<br>$$<br>\begin{aligned}<br>&amp;\begin{cases}\hat{y}&#x3D;ae^{bx}\\hat{y}&#x3D;ab^x\end{cases}\<br>&amp;\hat{y}&#x3D;ae^{bx} \<br>&amp;\text{参数b一般用来描述增长或衰减的速度。} \<br>&amp;\text{当 }a&gt;0\mathrm{、}b&gt;0\text{时,}y\text{随}x\text{的增大而增大(增长),是凹曲线}; \<br>&amp;\text{当 }a&gt;0\mathrm{、}b&lt;0\text{时,}y\text{随}x\text{的增大而减小(衰减),是凹曲线。} \<br>\end{aligned}<br>$$</p></li><li><p>倒指数曲线<br>$$<br>\widehat{y}&#x3D;ae^{\frac bx},\text{其中}a&gt;0\<br>\begin{aligned}<br>&amp;\text{当 }a&gt;0\text{、}b&gt;0\text{时,}y\text{随}x\text{的增大而减小(衰减),是凹曲线}; \<br>&amp;当a&gt;0、b&lt;0时,y随x的增大而增大(增长),是先凹后凸曲线。<br>\end{aligned}\<br>\bullet\text{ 变换方式:两边取对数,令}y^{\prime}&#x3D;ln\widehat{y},a^{\prime}&#x3D;lna,x^{\prime}&#x3D;\frac1x\text{ ,得}y^{\prime}&#x3D;a^{\prime}+bx^{\prime}<br>$$</p></li><li><p>对数函数曲线<br>$$<br>\widehat{y}&#x3D;a+blnx(x&gt;0)\<br>\begin{aligned}&amp;\bullet\text{ 对数函数表示: }x\text{变数的较大变化可引起}y\text{变数的较小变化。}\&amp;b&gt;0\text{时,}y\text{随}x\text{的增大而增大,是凸曲线;}\&amp;b&lt;0\text{时,}y\text{随}x\text{的增大而减小,是凹曲线。}\end{aligned}\<br>\bullet\text{ 变换方式:令}x^{\prime}&#x3D;lnx,\text{得}\hat{y}&#x3D;a+bx^{\prime}.<br>$$</p></li><li><p>S型曲线</p><p>又称<strong>生长曲线</strong>，可以描述植物的生长过程，传染病的发展趋势等。</p><p>特点是<strong>先缓慢增长，而在以后的某一范围内迅速增长，达到一定限制后又缓慢下来</strong><br>$$<br>\widehat{y}&#x3D;\frac k{1+ae^{-bx}}(a\text{、}b\text{、}k\text{均大于}0)\x&#x3D;0 ,\widehat{y}&#x3D;\frac k{1+a} ; x\to\infty ,\widehat{y}&#x3D;k\<br>\bullet\text{ 变换方式:两边取倒数再取对数后,}y^{\prime}&#x3D;ln(\frac{k-\hat{y}}{\hat{y}}),a^{\prime}&#x3D;lna,\text{得}y^{\prime}&#x3D;a^{\prime}+bx<br>$$</p></li></ul><p><strong>当六类曲线都配对不上时，，可以使用以下方法：</strong></p><ul><li>回归多项式：<br>$$<br>\begin{aligned}<br>&amp;\text{设变量x、Y的回归模型为} \<br>&amp;Y&#x3D;\beta_0+\beta_1x+\beta_2x^2+\cdots+\beta_px^p+\epsilon \<br>&amp;\text{,} \text{其中}p\text{是已知的,}\beta_i(i&#x3D;1,2,\cdotp\cdotp\cdotp,p)\text{是未知参数,}\epsilon\text{服从正态分布}N(0,\sigma) \<br>&amp;Y&#x3D;\beta_0+\beta_1x+\beta_2x^2+\cdots+\beta_px^p \<br>&amp;\text{称为回归多项式,上面的回归模型称为多项式回归。}<br>\end{aligned}<br>$$</li></ul><h2 id="灰色预测模型"><a href="#灰色预测模型" class="headerlink" title="灰色预测模型"></a>灰色预测模型</h2><p>灰色系统用<strong>颜色深浅反映信息量的多少</strong>，一个系统是黑色的，就是这个系统是黑洞洞的，信息量太少；一个系统是白色的，就是这个系统的清楚的，信息量充足的。处于黑白之间的系统，就是信息不完全的系统，称为灰色系统或灰系统。</p><p>灰色预测适用情况：</p><ul><li><strong>适合以年份度量的非负数据</strong>（月份或季度适合时间序列模型）</li><li>数据能经过指数规律校验（除了前两期外，后面至少90%的期数的光滑比要低于0.5）</li><li>数据的<strong>期数较短</strong>且<strong>和其他数据之间的关联性不强</strong>，期数小于等于10，太短也不行，如果期数较长一般用传统的时间序列模型</li></ul><h3 id="GM-1-1-模型"><a href="#GM-1-1-模型" class="headerlink" title="GM(1,1)模型"></a>GM(1,1)模型</h3><p>GM表示Greay Model灰色模型，（1，1）表示只含有一个变量的一阶微分方程模型</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul><li><p>根据原始的离散非负数据列，通过累加等方式削弱随机性，获得有规律的<strong>离散数据列</strong><br>$$<br>设x^(0)&#x3D;(x^{(0)}(1),x^{(0)}(2),…,x^{(0)}(n))是最初的非负数据列，我们可以对其累加，得到新的数\<br>据列$\chi^{(1)}$\<br>\chi^{(1)}&#x3D;\left(\chi^{(1)}(1),\chi^{(1)}(2),…,\chi^{(1)}(n)\right)\<br>其中：x^{(1)}(m)&#x3D;\sum_{\mathrm{i}&#x3D;1}^{\mathrm{m}}x^{(0)}(i),m&#x3D;1,2,…,n<br>$$</p></li><li><p>建立相应的<strong>微分方程模型</strong>，得到离散点处的解</p></li><li><p>再通过累减求得的<strong>原始数据的估计值</strong>，从而对原始数据预测</p></li></ul><h2 id="时间序列模型"><a href="#时间序列模型" class="headerlink" title="时间序列模型"></a>时间序列模型</h2><p>时间序列也称动态序列，时间分析大致可分三大部分：描述过去、分析规律、预测未来，时间序列常用<strong>ARIMA模型</strong></p><p>时间序列根据时间和数值性质的不同，可以分为<strong>时期时间序列</strong>和<strong>时点时间序列</strong></p><h4 id="ARIMA模型"><a href="#ARIMA模型" class="headerlink" title="ARIMA模型"></a>ARIMA模型</h4><p>ARIMA(p,d,q)模型指：</p><ul><li><p>ARMA(p,q)模型：</p><ul><li><p>AR(p)：</p><p>描述当前值和历史值之间的关系，用变量自身的历史数据对自身进行预测，其必须要满足平衡性要求<br>$$<br>\bullet\quad p\text{阶自回归过程的公式定义:}\quad y_t&#x3D;\mu+\sum_{i&#x3D;1}^p\gamma_iy_{t-i}+\epsilon_t\text{,}p\text{表示用几期的历史值来预测}\\bullet\quad y_t\text{是当前值}\quad\mu\text{是常数项}\quad p\text{是阶数}\quad\gamma_i\text{是自相关系数}<br>$$</p></li></ul></li><li><p>MA(q):</p><p>该模型关注的是自回归模型中误差项的累计<br>  $$<br>  q\text{阶自回归过程的公式定义:} y_{t}&#x3D;\mu+\epsilon_{t}+\sum_{i&#x3D;1}^{q}\theta_{i}\epsilon_{t-i}\<br>  即时间序列当前值与历史值没有关系，而只依赖于历史白噪声的线性组合\<br>  能有效消除预测中的随机波动<br>  $$</p><p>  将两个模型结合得到ARMA(p,q)模型<br>  $$<br>  \bullet\text{ 公式定义: }y_t&#x3D;\mu+\sum_{i&#x3D;1}^p\gamma_iy_{t-i}+\epsilon_t+\sum_{i&#x3D;1}^q\theta_i\epsilon_{t-i}<br>  $$</p></li><li><p>I(d)模型</p></li></ul><p>p是自回归项，q为移动平均项数，d为时间序列成为平稳时所做的差分次数</p><ul><li><p>步骤：</p><ul><li>对序列绘图，进行平稳性校验，对非平稳时间序列要先进行d阶差分转化为平稳时间序列</li><li>对平稳时间序列分别求得其自相关系数（ACF）和偏自系数（PACF），通过对自相关图和偏自相关图的分析，得到阶数p，q</li><li>由上得到d、p、q，建立ARIMA模型，然后开始对得到的模型进行模型检验</li></ul></li><li><p>平稳性：</p><p>平稳性就是要求经由样本时间序列得到的拟合曲线在未来的一段时间内仍然能够按照现有的形态延续下去</p><p>平稳性要求序列的<strong>均值</strong>和<strong>方差</strong>不发生明显变化</p><ul><li>严平稳：序列所有统计性质（期望、方差）都不会随着时间而发生改变</li><li>宽平稳：期望与相关系数（依赖性）不变，就是说t时刻的值X依赖于过去的信息</li></ul><p>如果一个时间序列不是平稳的，通常通过<strong>差分</strong>进行转换</p></li><li><p>差分法：</p><p>时间序列在t和t-1时刻的差值。将非平稳序列变平稳。<br>$$<br>\Delta yx&#x3D;y(x+1)-y(x),(x&#x3D;0,1,2,…)\<br>比如一组数列[0,1,2,3,4,5,6,7]\<br>进行差分后就会得到新数列[1,1,1,1,1,1]<br>$$</p></li><li><p>自相关系数（ACF）<br>$$<br>公式：$ACF( k) &#x3D; \rho <em>{\mathrm{k} }&#x3D; \frac {\mathrm{Cov}( \mathrm{y_t, y</em>{t- k}}) }{Var( y_t) }$ 取值范围为[-1,1]<br>$$</p></li><li><p>偏自相关系数（PACF）<br>$$<br>公式：$PACF(k)&#x3D;\frac{COV[(Z_{t}-\bar{Z}<em>{t}),(Z</em>{t-k}-\bar{Z}<em>{t-k})]}{\sqrt{var(Z</em>{t}-\bar{Z}<em>{t})}\sqrt{var(Z</em>{t-k}-\bar{Z}_{t-k})}}$<br>$$</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>python</tag>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git学习</title>
    <link href="/2024/06/07/git%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/06/07/git%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h1><h2 id="获取本地仓库"><a href="#获取本地仓库" class="headerlink" title="获取本地仓库"></a>获取本地仓库</h2><p>新建目录，右键进入git bash命令行</p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git init <br></code></pre></td></tr></table></figure><p>就可以将当前目录初始化为一个git仓库，成功后会多出一个<code>.git</code>文件夹（有些时候会隐藏，在资源管理器的查看中设置）</p><h2 id="仓库基本提交逻辑"><a href="#仓库基本提交逻辑" class="headerlink" title="仓库基本提交逻辑"></a>仓库基本提交逻辑</h2><p>在我们提交修改时候，文件会经过三个区域<strong>工作区（workspace）、暂存区（index）、仓库（respository）</strong></p><p>当我们在工作区新建&#x2F;修改文件时，文件会进入<strong>未跟踪&#x2F;未暂存</strong>状态，通过<code>git add</code>指令，将这两种状态添加到<strong>暂存区</strong>，状态变为<strong>已暂存</strong>，最后通过<code>git commit</code>提交到仓库成为一次提交记录</p><p>可以通过<code>git status</code>查看文件的提交状态</p><h2 id="仓库的基本操作"><a href="#仓库的基本操作" class="headerlink" title="仓库的基本操作"></a>仓库的基本操作</h2><h3 id="查看文件提交状态"><a href="#查看文件提交状态" class="headerlink" title="查看文件提交状态"></a>查看文件提交状态</h3><p>在工作目录下新建一个文件，进入git bash输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git status<br></code></pre></td></tr></table></figure><p>可以看到文件的提交状态</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ git status<br>On branch master<br><br>No commits yet<br><br>Untracked <span class="hljs-built_in">files</span>:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> <span class="hljs-built_in">to</span> <span class="hljs-built_in">include</span> <span class="hljs-keyword">in</span> what will be committed)<br>        <span class="hljs-number">1.</span>txt<br><br>nothing added <span class="hljs-built_in">to</span> commit but untracked <span class="hljs-built_in">files</span> present (use <span class="hljs-string">&quot;git add&quot;</span> <span class="hljs-built_in">to</span> track)<br><br></code></pre></td></tr></table></figure><p>显示为<code>Untracked</code>为跟踪</p><h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><p>在查看文件状态中，我们新建了一个文件，他的状态为<code>Untracked</code></p><p>我们可以<code>add</code>文件名将他添加到暂存区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git add fileNam<br></code></pre></td></tr></table></figure><p>也可以用通配符<code>.</code>将所有文件添加到暂存区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git add .<br></code></pre></td></tr></table></figure><p>接着通过<code>commit</code>提交到仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git commit -m &quot;提交注释&quot;<br></code></pre></td></tr></table></figure><p>最后通过<code>log</code>查看日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git log<br></code></pre></td></tr></table></figure><p>出现了提交记录</p><h3 id="查看记录"><a href="#查看记录" class="headerlink" title="查看记录"></a>查看记录</h3><p>可以通过<code>log</code>查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git log<br></code></pre></td></tr></table></figure><p>log还有很多个参数比如<code>--all</code>等</p><p>下面是常用的一个</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">git log</span> <span class="hljs-literal">--</span><span class="hljs-comment">pretty=oneline</span> <span class="hljs-literal">--</span><span class="hljs-comment">abbrev</span><span class="hljs-literal">-</span><span class="hljs-comment">commit</span>  <span class="hljs-literal">--</span><span class="hljs-comment">graph</span><br></code></pre></td></tr></table></figure><p>意思为：提交信息显示一行，简短模式，以图形式显示</p><h3 id="版本切换与回退"><a href="#版本切换与回退" class="headerlink" title="版本切换与回退"></a>版本切换与回退</h3><p>在log中我们可以看到很多commitID，可以在git bash中选中，git会自动复制，在使用鼠标中键粘贴，不需要是完整的，在简短模式下显示的后7位也行</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard  commitID</span><br></code></pre></td></tr></table></figure><p>比如我现在有两个提交</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>3437f03 (HEAD -&gt; master) 修改<br><span class="hljs-bullet">* </span>32d66d4 我的注释<br></code></pre></td></tr></table></figure><p>现在我希望回退到修改前，也就是我刚提交“我的注释”这个时候，那么就reset + 我的注释的id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git reset --hard 32d66d4<br></code></pre></td></tr></table></figure><p>再次查看，发现提交的修改没了，只有一个“我的注释”，文件里新加的内容也没了</p><p>回退了，但是并没有删除，我们还是可以通过“修改”的ID重新找回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git reset --hard 3437f03<br></code></pre></td></tr></table></figure><p>想要找到这个ID可以用<code>reflog</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git reflog<br></code></pre></td></tr></table></figure><p>可以看到历史记录</p><p><code>reset</code> 有三种用法，分别是<code>--soft,--hard,--mixed(默认)</code>，下面是三种用法的不同</p><ul><li><p><code>--soft</code>:软回退</p><p>表示回退到某个版本，且保留工作区和暂存区的所有修改内容</p></li><li><p><code>--haed:</code>硬回退</p><p>表示回退到某个版本，且丢弃工作区和暂存区的所有修改内容</p></li><li><p><code>--mixed:</code>混合回退</p><p>表示回退到某个版本，保留工作区的修改内容并丢弃暂存区的修改内容</p></li></ul><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>我们有些文件可能不需要纳入GIT管理，而当我们使用<code>git add .</code>的时候会把该文件提交，如果用<code>git add filename</code>一个个加又太慢了</p><p>这时我们可以创建一个<code>.gitignore</code>文件，在其中放入我们希望忽略的文件名，支持正则。</p><p>比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs .gitignore">*.a<br></code></pre></td></tr></table></figure><p>会把所有文件扩展名为a的文件忽略</p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>border受缩放影响</title>
    <link href="/2024/06/01/border%E5%8F%97%E7%BC%A9%E6%94%BE%E5%BD%B1%E5%93%8D/"/>
    <url>/2024/06/01/border%E5%8F%97%E7%BC%A9%E6%94%BE%E5%BD%B1%E5%93%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>今天放了一行的盒子，缩放了一下发现最后一个盒子掉下去了，用F12一看发现盒子的大小居然发生了改变，而设置的样式却依旧生效。而当我去掉了<code>border</code>之后，发现再怎么缩放盒子的大小也不会改变了，所以<code>border</code>会受缩放的影响。</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>为什么会发生这种事情呢？在我搜索了一番后还是不能理解，一种说法是说：在缩放时，浏览器会将<code>border</code>等比例放大，当放大之后的大小不是整数时会发生精度的丢失。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ol><li>预留空白，不使用border<br>在盒子之间预留空白，而不直接使用border进行分割。</li><li>使用<code>box-sizing</code>属性<br>先来看看什么是<code>box-sizing</code><br><code>box-sizing</code>属性有三个值<br><code>inherit</code>:从父级继承此属性</li></ol><ul><li><code>content-box</code>:默认值，在计算<code>width</code>和<code>height</code>的时候不计算<code>border</code>、<code>padding</code>、<code>margin</code>。宽高都只是内容高度</li><li><code>border-box</code>:<code>width</code>和<code>height</code>属性包括内外边距<code>border</code>、<code>padding</code>，但不包括外边距<code>margin</code><br>只要使用<code>box-sizing:border-box</code>将边框纳入宽高的计算，就可以保证盒子大小不变</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>前端</tag>
      
      <tag>小玩意</tag>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python Django后端学习笔记</title>
    <link href="/2024/05/19/django%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/05/19/django%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>终端输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">django-admin startproject project<br></code></pre></td></tr></table></figure><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">project<br>manage.py           项目工具（启动、创建app需要用）<br>├─project<br>│  │  settings.py   配置文件，如数据库连接，跨域等（重要）<br>│  │  urls.py       路由，将接口导向视图函数 （重要）<br>│  │  views.py      用于编写视图函数处理请求（重要）<br>│  │  __init__.py   告诉解释器，所在目录是一个包<br>│  │<br>│  ├─templates      模板用于生成静态网页<br>│  │      ron.html<br></code></pre></td></tr></table></figure><h1 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h1><p><code>runserver</code>运行，可选 ip 和端口号，默认<code>http://127.0.0.1:8000/</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python ./manage.py runserver &lt;ip:port&gt;<br></code></pre></td></tr></table></figure><p>启动后浏览器输入对应地址进入 django 默认页面</p><h1 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h1><p>项目可以由多个 app 应用组成，<strong>在创建项目时会自动生成一个和项目同名的应用</strong><br>创建应用可以通过 manage 工具创建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python manage.py startapp myapp<br></code></pre></td></tr></table></figure><p>会创建一个名为<code>myapp</code>的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">├─mysql<br>│  │  admin.py<br>│  │  apps.py<br>│  │  models.py     模型，用于连接数据库<br>│  │  views.py      视图<br>│  │  __init__.py<br></code></pre></td></tr></table></figure><h1 id="Hello-World-接口"><a href="#Hello-World-接口" class="headerlink" title="Hello World 接口"></a>Hello World 接口</h1><h2 id="新建-hello-应用"><a href="#新建-hello-应用" class="headerlink" title="新建 hello 应用"></a>新建 hello 应用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python manage.py startapp hello<br></code></pre></td></tr></table></figure><p>出现<code>hello</code>目录</p><h2 id="编写视图函数"><a href="#编写视图函数" class="headerlink" title="编写视图函数"></a>编写视图函数</h2><p>编写<code>hello/views.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.shortcuts <span class="hljs-keyword">import</span> render<br><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> HttpResponse  <span class="hljs-comment"># 用于返回Http响应</span><br><span class="hljs-comment"># Create your views here.</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">req</span>):<br>    <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&#x27;Hello World!&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="设置路由"><a href="#设置路由" class="headerlink" title="设置路由"></a>设置路由</h2><p>在主应用（与项目同名）中<code>project/url.py</code>编写路由</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><span class="hljs-keyword">from</span> hello <span class="hljs-keyword">import</span> views <span class="hljs-keyword">as</span> hello_views  <span class="hljs-comment"># 引入hello应用的视图</span><br><br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;admin/&#x27;</span>, admin.site.urls),<br>    path(<span class="hljs-string">&#x27;hello/&#x27;</span>, hello_views.hello),  <span class="hljs-comment"># 添加hello接口的路由</span><br>]<br></code></pre></td></tr></table></figure><h2 id="启动项目-1"><a href="#启动项目-1" class="headerlink" title="启动项目"></a>启动项目</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python ./manage.py runserver<br></code></pre></td></tr></table></figure><p>在浏览器输入<code>http://127.0.0.1:8000</code>可以看见默认页面，页面上有我们的所有路由<br>浏览器输入<code>http://127.0.0.1:8000/hello</code>或者使用其他工具向该地址发送 GET 请求，可以看到<code>Hello World</code></p><h1 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h1><h2 id="修改-settings-配置"><a href="#修改-settings-配置" class="headerlink" title="修改 settings 配置"></a>修改 settings 配置</h2><p>在<code>project/settings</code>文件中，有<code>DATABASES</code>字段，可以这里配置数据库名、用户、密码等信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">DATABASES = &#123;<br>    <span class="hljs-string">&#x27;default&#x27;</span>: &#123;<br>        <span class="hljs-string">&#x27;ENGINE&#x27;</span>: <span class="hljs-string">&#x27;django.db.backends.mysql&#x27;</span>,  <span class="hljs-comment"># 数据库类型</span><br>        <span class="hljs-string">&#x27;NAME&#x27;</span>: <span class="hljs-string">&quot;mysql&quot;</span>,  <span class="hljs-comment"># 连接名</span><br>        <span class="hljs-string">&#x27;USER&#x27;</span>: <span class="hljs-string">&quot;root&quot;</span>,  <span class="hljs-comment"># 数据库用户名</span><br>        <span class="hljs-string">&#x27;PASSWORD&#x27;</span>: <span class="hljs-string">&quot;12345&quot;</span>,  <span class="hljs-comment"># 数据库密码</span><br>        <span class="hljs-string">&#x27;HOST&#x27;</span>: <span class="hljs-string">&quot;localhost&quot;</span>,  <span class="hljs-comment"># 主机ip</span><br>        <span class="hljs-string">&#x27;PORT&#x27;</span>: <span class="hljs-string">&quot;3306&quot;</span>,  <span class="hljs-comment"># 端口号</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="编写模型类"><a href="#编写模型类" class="headerlink" title="编写模型类"></a>编写模型类</h2><p>在<code>hello/models.py</code>文件中编写模型，在其中写的每一个类，都会对应数据库中的表，成员变量则是表的字段</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><br><br><span class="hljs-comment"># Create your models here.</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(models.Model):<br>    name = models.CharField(max_length=<span class="hljs-number">100</span>)  <span class="hljs-comment"># 字段名为name，类型为char，长度限制100</span><br>    age = models.IntegerField()  <span class="hljs-comment"># 字段名为age，类型为int</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.name<br></code></pre></td></tr></table></figure><p>创建好之后数据库还不会出现对应的表，还需要进行<strong>迁移</strong></p><h2 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h2><p><strong>需要先安装 mysqlclients</strong></p><p>迁移需要先生成<strong>迁移文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python ./manage.py makemigrations &lt;app_name&gt;<br></code></pre></td></tr></table></figure><p>不写应用名则全部<br>有了迁移文件，就可以进行数据库迁移</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python ./manage.py migrate &lt;app_name&gt;<br></code></pre></td></tr></table></figure><p>查看数据库，多出表名带有<code>django</code>的表和<code>hello_person</code>即成功</p><h2 id="数据库的增删改查"><a href="#数据库的增删改查" class="headerlink" title="数据库的增删改查"></a>数据库的增删改查</h2><p>django 中可以通过 ORM 对数据库进行操作，使开发者不需要关系数据库的类型及语法，只需要操作 model 即可</p><ul><li>查：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">obj1 = models.Person.objects.get(name=<span class="hljs-string">&quot;lihua&quot;</span>)  <span class="hljs-comment"># 返回一个对象，如果筛选结果不唯一则报错（0也会报错）</span><br>obj2 = models.Person.objects.<span class="hljs-built_in">filter</span>(name=<span class="hljs-string">&quot;lihua&quot;</span>)  <span class="hljs-comment"># 返回一个对象，含有符合条件的所有数据（无论多少都不报错）</span><br>obj3 = obj2.first()  <span class="hljs-comment"># 集合的第一个</span><br>obj4 = models.Person.objects.<span class="hljs-built_in">all</span>()  <span class="hljs-comment"># 返回全部</span><br></code></pre></td></tr></table></figure></li><li>增：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">models.Person.objects.create(name=<span class="hljs-string">&quot;xiaoming&quot;</span>,age=<span class="hljs-number">10</span>)  <span class="hljs-comment"># 增加数据</span><br></code></pre></td></tr></table></figure></li><li>删：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">models.Person.objects.<span class="hljs-built_in">all</span>().delete()  <span class="hljs-comment"># 删除，可以批量删除，删库必备</span><br></code></pre></td></tr></table></figure></li><li>改：<br>改可以通过<code>update</code>(批量修改)和赋值单数据修改<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">obj1 = models.Person.objects.get(name=<span class="hljs-string">&quot;lihua&quot;</span>)  <span class="hljs-comment"># 获取单条数据</span><br>obj1.age = <span class="hljs-number">20</span>  <span class="hljs-comment"># 修改数据</span><br>obj1.save()  <span class="hljs-comment"># 保存数据</span><br></code></pre></td></tr></table></figure><code>update</code>可以批量修改，但是只能用于数据集，不能用于单条数据（但是可以用于只有一条数据的数据集）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">obj1 = models.Person.objects.<span class="hljs-built_in">filter</span>(age=<span class="hljs-number">10</span>)<br>obj1.update(age=<span class="hljs-number">11</span>)  <span class="hljs-comment"># 批量修改，会自动保存，不需要save</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>python</tag>
      
      <tag>Django</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合约漏洞</title>
    <link href="/2024/05/14/%E5%90%88%E7%BA%A6%E6%BC%8F%E6%B4%9E/"/>
    <url>/2024/05/14/%E5%90%88%E7%BA%A6%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h1 id="重入攻击"><a href="#重入攻击" class="headerlink" title="重入攻击"></a>重入攻击</h1><p>重入攻击是指攻击者通过在合约的回调函数中重新调用原合约，造成意外的行为或重入漏洞。<br>重入攻击的一个攻击点就是合约转账ETH的地方：转账ETH的目标地址如果是合约，会触发对方合约的<code>fallback（回退）</code>函数，从而造成循环调用的可能。<br>攻击流程大致为:</p><ol><li>攻击者合约调用被攻击合约</li><li>被攻击合约向调用者转账(msg.sender.call{value:amount}(“”))，此时msg.sender为攻击者合约地址</li><li>攻击者合约收到被攻击者合约的转账，触发fallback函数，再fallback中再次调用被攻击合约</li><li>2,3步骤循环</li></ol><p>解决方案就是使用重入锁：在进行转账前修改状态变量，转账完成后，再修改回来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">bool internal locked;   // 定义状态变量表示重入锁<br><br>modifer noReentrant() &#123;<br>    require(!locked, &quot;重入攻击!&quot;);<br>    // 进行转账前<br>    locked = true;<br>    _; <br>    locked = false; <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="溢出攻击"><a href="#溢出攻击" class="headerlink" title="溢出攻击"></a>溢出攻击</h1><p>每个数据类型都有它的取值范围，如果计算范围超出最大值或小于最小值，则会出现<strong>上溢</strong>和<strong>下溢</strong>。比如<code>uint8</code>的范围是[0,255]，如果用它计算0-1则会出现<strong>下溢</strong>，变为最大值255；如果用它计算255+1则会出现<strong>上溢</strong>，变为最小值0。</p><p>溢出在0.8以下时不会报错，&gt;&#x3D;0.8溢出则会报错</p><p>解决方案就是使用0.8及以上版本(0.8版本自带<code>SafeMath</code>库)，或者导入<code>SafeMath</code>库</p><h1 id="自毁函数攻击"><a href="#自毁函数攻击" class="headerlink" title="自毁函数攻击"></a>自毁函数攻击</h1><p>自毁函数<code>selfdestruct</code>是solidity的一个特殊函数，它能将合约销毁，并将合约余额转给目标地址，攻击者可以利用它向其他合约<strong>强制转账</strong>，如果该合约的运行逻辑依赖于合约余额，强制转入可能会造成意外行为<br>比如一个合约有个函数，用来接收以太币并使用<code>address(this).balance()</code>对余额进行判断。攻击者合约通过<code>selfdestruct</code>绕过该函数强制转账，将不触发余额判断。</p><p>解决方案就是不使用真实余额<code>address(this).balance</code>，而是定义一个状态变量<code>uint public balance;</code>，这样只有通过调用函数才会添加balance，<code>selfdestruct</code>强制发送不会计入</p><h1 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h1><p>随机数的随机种子可以从区块变量中，也可以从预言机获取<br>常见的区块变量有：</p><blockquote><p>block.basefee(uint)：当前区块的基本费用</p><p>block.chainid(uint)：当前链 id</p><p>block.coinbase()：当前区块矿工地址 address payable</p><p>block.difficulty(uint)：当前区块难度</p><p>block.gaslimit(uint)：当前区块 gaslimit</p><p>block.number(uint)：当前区块号</p><p>block.timestamp(uint)：自 Unix 纪元以来的当前区块时间戳（以秒为单位）</p><p>blockhash(uint blockNumber) returns (bytes32)：给定区块的哈希，仅适用于 256 个最近的区块</p></blockquote><p>区块变量可以限制普通用户对随机数的预测，但不能阻止矿工，矿工在打包交易时可以选取自己想要的进行打包，从而影响随机数。</p><p>预言机是专门用于产生随机数的服务，预言机不仅能使用链上数据做随机种子，还能从链下的现实世界获取数据。</p><h1 id="拒绝服务攻击DOS"><a href="#拒绝服务攻击DOS" class="headerlink" title="拒绝服务攻击DOS"></a>拒绝服务攻击DOS</h1><p>通过某些手段，对服务进行干涉，使得目标可用性降低或失去可用性而拒绝服务，称为拒绝服务攻击。</p><p>拒绝服务攻击包括但不限于以下：</p><ol><li><p>基于代码逻辑的攻击：<br> 这种一般是由于合约不严谨导致的，比如：当合约未对传入的映射或数组做限制时，攻击者可以通过输入超长映射或数组 消耗大量的Gas，使得这笔交易的Gas溢出，最后使该合约暂时或永久不可用</p></li><li><p>基于外部调用的攻击：<br> 一般是合约对外部调用处理不严谨导致的</p></li><li><p>基于运营管理的攻击：<br> 比如合约的管理者被盗号</p></li></ol><p>其中最常用的就是基于外部调用的攻击，例如：<br>有个合约A用于竞选最富有的人，其定义了一个函数用于接收以太币，然后将接收的以太币与当前最富有者发送的以太币对比，如果产生了新富豪，则将上一个富豪发送的以太币用<code>address.call&#123;value:account&#125;()</code>原路返回，如果返还以太币失败则会使用<code>require</code>退出。<br>这个合约的攻击点在于返回以太币与接收以太币都在同一个函数中，现在有一个攻击合约B，B中只有一个函数，接收以太币并调用A的竞选函数。<br>当B成为富豪后，其他人想竞选将会失败，这是因为B合约中没有<code>payable</code>修饰的<code>fallback</code>函数，使得B无法接收<code>B.call&#123;value: account&#125;()</code>这样的空调用转账，所以A对B的转账会一直失败，使得B成为了永久的富豪。</p><p>解决方案：<br>定义新函数单独处理退款，用<strong>取回模式代替发送模式</strong>，这样就算有人恶意拒收也只能影响到自己。</p><h1 id="tx-origin钓鱼攻击"><a href="#tx-origin钓鱼攻击" class="headerlink" title="tx.origin钓鱼攻击"></a>tx.origin钓鱼攻击</h1><p><code>tx.origin</code>和<code>msg.sender</code>类似，都是用于获取发送者地址，但<code>msg.sender</code>获取的是上层调用者的地址，<code>tx.origin</code>获取的是启动交易的原始地址<br>假设一个合约定义了状态状态变量<code>owner</code>用于存储合约部署者，在之后的函数中使用<code>reuqire(owern == tx.origin)</code>进行判断<br>由于使用的是<code>tx.origin</code>，那么攻击者可以通过伪造一个钓鱼合约，诱导被攻击者去调用，然后再在合约中调用被攻击者的合约，这样<code>tx.origin</code>就指向了被攻击者，成功越权。</p><p>解决方案：<br><code>tx.origin</code> 目前仅适用于校验 <code>msg.sender </code>是否是 EOA 地址(账户地址)，不适用于做权限的校验，需要使用<code>msg.sender</code>来进行权限校验。</p><h1 id="移花接木"><a href="#移花接木" class="headerlink" title="移花接木"></a>移花接木</h1><p>用户以为的调用路径：</p><p>部署合约 A 传入合约 B 地址，这样调用路径为正常路径。</p><p>实际的调用路径：</p><p>部署合约 A 传入合约 C 地址，这样调用路径为非正常路径。</p><p>B为开源的正常合约，C为恶意合约，黑客宣传B合约能赚钱，并把C合约的地址当做B合约让用户调用，用户只检查了B合约认为没问题便落入了陷阱</p><h1 id="delegatecall调用"><a href="#delegatecall调用" class="headerlink" title="delegatecall调用"></a>delegatecall调用</h1><p>低级调用有：<code>call</code>,<code>delegatecall</code>,<code>callcode</code>，三种都用于调用外部合约或函数，但又有点不同</p><ul><li><p>call:<br><code>msg</code>指向的是调用者合约，<code>this</code>指向被调用合约，执行环境为被调用者合约的运行环境，合约之间状态变量互相独立不影响。<br>比如A调用了B，则<code>msg</code>指向了A，而<code>this</code>仍为B，B的代码交给B自己执行</p></li><li><p>delegatecall：<br><code>msg</code>指向的是调用者（不是调用者合约，而是调用者本人），<code>this</code>指向调用合约，执行环境为调用者合约的运行环境，合约之间的状态变量会根据声明顺序一一对应，会影响调用者状态变量的值。<br>比如caller部署了A，并用A调用了B，则<code>msg</code>指向的是caller，<code>this</code>指向的是A。假设A按以下顺序定义了<code>int a1; int a2</code>，而B按以下顺序定义了<code>int b1; int b2;</code>，同时在调用B的过程中，修改了<code>b1 = 1; b2 = 2</code>，则运行结束后，A中的<code>a1 == 1; a2 == 2</code>。<br>相当于将B的代码交给A执行</p></li><li><p>callcode：<br>在0.5.0以后被禁用，相当于上面二者的结合，<code>msg</code>指向调用者合约，<code>this</code>指向调用者合约，运行环境为调用者合约的运行环境</p></li></ul><p>案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Lib &#123;<br>    uint public someNumber;<br><br><br>    function doSomething(uint _num) public &#123;<br>        someNumber = _num;<br>    &#125;<br>&#125;<br><br><br>contract HackMe &#123;<br>    address public lib;<br>    address public owner;<br>    uint public someNumber;<br><br><br>    constructor(address _lib) &#123;<br>        lib = _lib;<br>        owner = msg.sender;<br>    &#125;<br><br><br>    function doSomething(uint _num) public &#123;<br>        lib.delegatecall(abi.encodeWithSignature(&quot;doSomething(uint256)&quot;, _num));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.13;<br><br><br>contract Attack &#123;<br>    // Make sure the storage layout is the same as HackMe<br>    // This will allow us to correctly update the state variables<br>    address public lib;<br>    address public owner;<br>    uint public someNumber;<br><br><br>    HackMe public hackMe;<br><br><br>    constructor(HackMe _hackMe) &#123;<br>        hackMe = HackMe(_hackMe);<br>    &#125;<br><br><br>    function attack() public &#123;<br>        // override address of lib<br>        hackMe.doSomething(uint(uint160(address(this))));<br>        // pass any number as input, the function doSomething() below will<br>        // be called<br>        hackMe.doSomething(1);<br>    &#125;<br><br><br>    // function signature must match HackMe.doSomething()<br>    function doSomething(uint _num) public &#123;<br>        owner = msg.sender;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>攻击流程：</p><ol><li>攻击合约调用<code>hackMe.doSomething</code>并传入自己的地址</li><li><code>hackMe.doSomething</code>通过<code>delegatecall</code>调用<code>lib.doSomething</code></li><li>由于<code>delegatecall</code>的特性，lib中<code>someNumber</code>状态变量的修改会同步到hackMe中的<code>lib</code>状态变量，lib指向了攻击合约</li><li>攻击合约继续调用<code>hackMe.doSomething</code>，由于<code>hackMe.lib</code>被修改，故<code>hackMe.doSomething</code>将会调用攻击合约中的<code>doSomething</code>，将owner修改为攻击者</li></ol><p>解决方案：</p><ol><li>在使用 delegatecall 时应注意被调用合约的地址不能是可控的</li><li>在较为复杂的合约环境下需要注意变量的声明顺序以及存储位置。因为使用 delegatecall 进行外部调用时会根据被调用合约的数据结构来修改本合约相应 slot 中存储的数据</li></ol><h1 id="选择器碰撞"><a href="#选择器碰撞" class="headerlink" title="选择器碰撞"></a>选择器碰撞</h1><p>solidity在调用函数时，会通过函数选择器找到对应函数，函数选择器就是函数签名哈希值的前4个字节<br>函数签名是一个字符串，包含了函数名和参数类型形如<code>&quot;functionName(uint256)&quot;</code>，选择器就是<code>bytes4(keccak256(bytes(&quot;functionName(type1,type2)&quot;)))</code><br>选择器碰撞是指两个不同的函数具有相同的选择器，比如<code>LOCK8605463013()</code>和<code>uWjK9(uint256)</code>，他们的选择器都是<code>0xffffffff</code><br>选择器碰撞可以通过这个网址查询<a href="https://www.4byte.directory/">“Ethereum Signature Database”</a></p><p>参考资料：<br><a href="https://learnblockchain.cn/people/420">“登链-慢雾科技”</a> 智能合约安全审计入门篇 各大篇</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区块链</tag>
      
      <tag>solidity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js快速搭建WebSocket前后端及语法基础</title>
    <link href="/2024/04/28/js%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAWebSocket%E5%89%8D%E5%90%8E%E7%AB%AF%E5%8F%8A%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/04/28/js%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAWebSocket%E5%89%8D%E5%90%8E%E7%AB%AF%E5%8F%8A%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-WebSocket"><a href="#什么是-WebSocket" class="headerlink" title="什么是 WebSocket"></a>什么是 WebSocket</h1><p>WebSocket 是一种网络传输协议。在传统模式中，客户端实现实时推送需要通过<strong>轮询</strong>（每个一段时间发起一次请求），而 WebSocket 就是为了解决这个问题而诞生，WebSocket 的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话</p><h1 id="node-js-搭建-WebSocket-服务端"><a href="#node-js-搭建-WebSocket-服务端" class="headerlink" title="node.js 搭建 WebSocket 服务端"></a>node.js 搭建 WebSocket 服务端</h1><ul><li>创建项目</li></ul><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> init -y<br></code></pre></td></tr></table></figure><ul><li>安装 ws</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> ws<br></code></pre></td></tr></table></figure><ul><li>新建 index.js 并导入库</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">WebSocket</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;ws&quot;</span>);<br></code></pre></td></tr></table></figure><p>下面是个简单的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">WebSocket</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;ws&quot;</span>);<br><br><span class="hljs-comment">// 创建webcocket服务器</span><br><span class="hljs-keyword">const</span> wss = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>.<span class="hljs-title class_">WebSocketServer</span>(&#123; <span class="hljs-attr">port</span>: <span class="hljs-number">8080</span> &#125;);<br><br><span class="hljs-comment">// 监听连接事件</span><br>wss.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-keyword">function</span> <span class="hljs-title function_">connection</span>(<span class="hljs-params">ws</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;New connection&quot;</span>);<br><br>  <span class="hljs-comment">// 监听消息事件</span><br>  ws.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[Client]: <span class="hljs-subst">$&#123;message&#125;</span>`</span>);<br>    <span class="hljs-comment">// 发送消息给客户端</span><br>    ws.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;ok&quot;</span>);<br>  &#125;);<br><br>  <span class="hljs-comment">// 监听关闭事件</span><br>  ws.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;close&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Disconnected&quot;</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>然后在终端输入</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">index</span>.js<br></code></pre></td></tr></table></figure><p>启动服务器</p><h1 id="客户端连接"><a href="#客户端连接" class="headerlink" title="客户端连接"></a>客户端连接</h1><p>如果想在浏览器中连接客户端，js 原生支持 WebSocket，也可以使用 sockeio 或其他的库。如果想要在 node 中以终端的形式运行，也可以继续使用上面的 ws</p><hr><p>这里先讲在 node 下运行服务端<br>新建一个 client.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//导入ws</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">WebSocket</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;ws&quot;</span>);<br><br><span class="hljs-comment">// 新建连接</span><br>ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&quot;ws://localhost:8080&quot;</span>);<br><br><span class="hljs-comment">// 监听open连接事件</span><br>ws.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;open&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 发送消息给服务端</span><br>  ws.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;ok?&quot;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 监听消息接收事件:</span><br>ws.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">message</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[SERVER]:<span class="hljs-subst">$&#123;message&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>终端输入命令运行</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">client</span>.js<br></code></pre></td></tr></table></figure><hr><p>如果要在浏览器中连接，可以直接用原生的 WebSocket</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>WebSocket连接<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;input&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;send()&quot;</span>&gt;</span>发送消息<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// 新建WebSocket对象并建立连接</span></span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&quot;ws://localhost:8080&quot;</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// 监听连接事件</span></span><br><span class="language-javascript">  ws.<span class="hljs-property">onopen</span> = <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;连接成功&quot;</span>);</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// 监听消息接收事件</span></span><br><span class="language-javascript">  ws.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message.<span class="hljs-property">data</span>);</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">//发送消息</span></span><br><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">send</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> message = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;input&quot;</span>).<span class="hljs-property">value</span>;</span><br><span class="language-javascript">    ws.<span class="hljs-title function_">send</span>(message);</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="制作一个简单的聊天室"><a href="#制作一个简单的聊天室" class="headerlink" title="制作一个简单的聊天室"></a>制作一个简单的聊天室</h1><p>服务端 index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">WebSocket</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;ws&quot;</span>);<br><br><span class="hljs-keyword">var</span> clients = [];<br><br><span class="hljs-comment">// 创建WebSocket服务器</span><br><span class="hljs-keyword">const</span> wss = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>.<span class="hljs-title class_">Server</span>(&#123; <span class="hljs-attr">port</span>: <span class="hljs-number">8080</span> &#125;);<br><br><span class="hljs-comment">// 监听连接事件</span><br>wss.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;connection&quot;</span>, <span class="hljs-keyword">function</span> <span class="hljs-title function_">connection</span>(<span class="hljs-params">ws, req</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;New connection&quot;</span>);<br><br>  <span class="hljs-comment">// 监听消息事件</span><br>  ws.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Received: %s&quot;</span>, message);<br>    <span class="hljs-comment">// 如果消息以用户名开头，则解析用户名</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">String</span>(message).<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&quot;[username]&quot;</span>)) &#123;<br>      <span class="hljs-keyword">const</span> index = clients.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function">(<span class="hljs-params">client</span>) =&gt;</span> client.<span class="hljs-property">ws</span> === ws);<br>      <span class="hljs-comment">// 如果不是新用户则修改名字</span><br>      <span class="hljs-keyword">if</span> (index != -<span class="hljs-number">1</span>) &#123;<br>        clients[index].<span class="hljs-property">name</span> = message;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果是新用户，则加入列表</span><br>        <span class="hljs-keyword">const</span> username = message.<span class="hljs-title function_">slice</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 去掉 &#x27;[username]&#x27; 前缀</span><br>        clients.<span class="hljs-title function_">push</span>(&#123; ws, username &#125;);<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 否则，将消息发送给除发送者外的所有客户端</span><br>      <span class="hljs-keyword">let</span> index = clients.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function">(<span class="hljs-params">client</span>) =&gt;</span> client.<span class="hljs-property">ws</span> == ws);<br>      <span class="hljs-keyword">let</span> username = clients[index].<span class="hljs-property">username</span>;<br>      clients.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">client</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (client.<span class="hljs-property">ws</span> !== ws) &#123;<br>          client.<span class="hljs-property">ws</span>.<span class="hljs-title function_">send</span>(<span class="hljs-string">`  [<span class="hljs-subst">$&#123;username&#125;</span>]：<span class="hljs-subst">$&#123;message&#125;</span>`</span>);<br>        &#125;<br>      &#125;);<br>    &#125;<br>  &#125;);<br><br>  <span class="hljs-comment">// 监听关闭事件</span><br>  ws.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;close&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 从列表删除用户</span><br>    <span class="hljs-keyword">const</span> index = clients.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function">(<span class="hljs-params">client</span>) =&gt;</span> client.<span class="hljs-property">ws</span> === ws);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[<span class="hljs-subst">$&#123;clients[index].username&#125;</span>]Disconnected`</span>);<br>    clients.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>客户端 client.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs Javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">WebSocket</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;ws&quot;</span>);<br><span class="hljs-keyword">const</span> readline = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;readline&quot;</span>);<br><br><span class="hljs-keyword">const</span> rl = readline.<span class="hljs-title function_">createInterface</span>(&#123;<br>  <span class="hljs-attr">input</span>: process.<span class="hljs-property">stdin</span>,<br>  <span class="hljs-attr">output</span>: process.<span class="hljs-property">stdout</span><br>&#125;);<br><br><span class="hljs-comment">// WebSocket 连接的函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&quot;ws://localhost:8080&quot;</span>);<br><br>  ws.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;open&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;连接成功&quot;</span>);<br>    ws.<span class="hljs-title function_">send</span>(<span class="hljs-string">`[username]<span class="hljs-subst">$&#123;name&#125;</span>`</span>);<br>  &#125;);<br><br>  ws.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;收到消息:%s&quot;</span>, message);<br>  &#125;);<br><br>  <span class="hljs-comment">// 发送消息的函数</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">send</span>(<span class="hljs-params"></span>) &#123;<br>    rl.<span class="hljs-title function_">question</span>(<span class="hljs-string">&quot;发送:&quot;</span>, <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> &#123;<br>      ws.<span class="hljs-title function_">send</span>(message);<br>      <span class="hljs-title function_">send</span>(); <span class="hljs-comment">// 再次调用，继续监听用户输入</span><br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">send</span>(); <span class="hljs-comment">// 启动发送消息功能</span><br>&#125;<br><br><span class="hljs-comment">// 第一个问题输入用户名</span><br>rl.<span class="hljs-title function_">question</span>(<span class="hljs-string">&quot;你的名字:&quot;</span>, <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">connect</span>(name); <span class="hljs-comment">// 开始 WebSocket 连接并启动消息发送</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>打开三个终端，启动一次 index.js 和两个 client.js</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">idnex</span>.js<br><span class="hljs-keyword">node</span> <span class="hljs-title">client</span>.js<br><span class="hljs-keyword">node</span> <span class="hljs-title">client</span>.js<br></code></pre></td></tr></table></figure><p>在输入名字后就可以发送和接收消息了</p><h1 id="原生-WebSocket-简单语法"><a href="#原生-WebSocket-简单语法" class="headerlink" title="原生 WebSocket 简单语法"></a>原生 WebSocket 简单语法</h1><p>只讲一些常用、简单的内容，具体内容请参考官方文档<br><code>WebSocket</code> 对象提供了用于创建和管理 <code>WebSocket</code> 连接，以及可以通过该连接发送和接收数据的 API。</p><hr><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">var aWebSocket = <span class="hljs-keyword">new</span> <span class="hljs-constructor">WebSocket(<span class="hljs-params">url</span>[, <span class="hljs-params">protocols</span>])</span>;<br></code></pre></td></tr></table></figure><ul><li>参数<ul><li><code>url</code>：要连接的服务器 URL</li></ul></li></ul><h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><h3 id="binaryType"><a href="#binaryType" class="headerlink" title="binaryType"></a>binaryType</h3><p><code>WebSocket.binaryType</code>返回 websocket 连接所传输二进制数据的类型</p><ul><li>返回值<br>返回一串 String - “blob”:传输的是 blob 类型的数据 - “arraybuffer”:传输的是 ArrayBuffer 类型的数据</li></ul><h3 id="bufferedAmount"><a href="#bufferedAmount" class="headerlink" title="bufferedAmount"></a>bufferedAmount</h3><p><code>WebSocket.bufferedAmount</code>是一个只读属性，用于返回已经被<code>send()</code>方法放入队列但还没有发送的数据的字节数，当全部数据被发送完后就会被重置为 0，如果传输中途连接中断则不会重置</p><h3 id="readyState"><a href="#readyState" class="headerlink" title="readyState"></a>readyState</h3><p><code>WebSocket.readyState</code>是一个只读属性，返回 WebSocket 的链接状态</p><ul><li>返回值<br>0-3 的数字用于表示不同的状态 <ul><li>0(WebSocket.CONNETION):正在连接中 </li><li>1(WebSocket.OPEN):已经连接并且可以通讯 </li><li>2(WebSocket.CLOSE):连接正在关闭 </li><li>3(WebSocket.CLOSED):连接已经关闭或连接没有成功</li></ul></li></ul><h3 id="url"><a href="#url" class="headerlink" title="url"></a>url</h3><p><code>WebSocket.url</code>是一个只读属性，返回构造函数创建<code>WebSocket</code>实例对象时URL的绝对路线</p><ul><li>返回值<br>string类型</li></ul><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h3><p><code>WebSocket.close([code][,reason])</code>关闭连接</p><ul><li>参数<ul><li>可选<code>code</code>：一个数字状态码，解释了连接关闭的原因，不传默认1005（表示没有收到预期的状态码），其他状态码可以查看官方文档</li><li>可选<code>reason</code>：一个人类可读的字符串，解释连接关闭的原因，这个UTF-8编码的字符串不能超过123个字节</li></ul></li><li>抛出异常<ul><li><code>INVALID_ACCESS_ERR</code>：一个无效的code</li><li><code>SYNTAX_ERR</code>：reason字符串太长</li></ul></li></ul><h3 id="send"><a href="#send" class="headerlink" title="send()"></a>send()</h3><p><code>WebSocket.send(data)</code>,将 需要发送的数据 添加到队列中，并根据所需要传输的data bytes的大小自行增加<code>bufferedAmount</code>的值。</p><ul><li>参数<ul><li><code>data</code>：传输至服务器的数据，必须是以下类型<ul><li>USVString：文本字符串</li><li>ArrayBuffer：类型化数组对象发送底层二进制数据</li><li>Blob：Blob 类型将队列 blob 中的原始数据以二进制中传输</li><li>ArrayBufferView：你可以以二进制帧的形式发送任何 JavaScript 类数组对象</li></ul></li></ul></li><li>异常<ul><li><code>INVALID_STATE_ERR</code>：连接未处于open状态</li><li><code>SYNTAX_ERR</code>：数据是一个包含未配对代理的字符串</li></ul></li></ul><p>未配对代理 (unpaired surrogates) 指的是在字符串中存在不匹配的 Unicode 代理项。Unicode 中的代理项用于表示一些特殊字符，而代理项对通常是成对出现的，例如表示表情符号的代理对。如果一个字符串中的代理项没有配对，就会出现未配对代理的情况。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>响应事件可以用WebSocket中的属性或者使用js监听器</p><h3 id="close-1"><a href="#close-1" class="headerlink" title="close"></a>close</h3><p><code>WebSocket.onclose</code>属性返回一个事件监听器，当连接变为<code>CLOSED</code>的时候会被调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">WebSocket</span>.<span class="hljs-property">onclose</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event)<br>&#125;<br></code></pre></td></tr></table></figure><p>event中包含了时间戳、url、关闭的code等消息</p><h3 id="error"><a href="#error" class="headerlink" title="error"></a>error</h3><p>当websocket的连接由于一些错误事件的发生 (例如无法发送一些数据) 而被关闭时，一个error事件将被引发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&quot;ws://localhost:8080&quot;</span>);<br>socket.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event)<br>&#125;)<br>socket.<span class="hljs-property">onerror</span> = ...<br></code></pre></td></tr></table></figure><h3 id="message"><a href="#message" class="headerlink" title="message"></a>message</h3><p>接收新消息时触发</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">socket.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event)<br>&#125;<br>socket.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;message&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event)<br>&#125;)<br></code></pre></td></tr></table></figure><p>event中包含了接收的消息data</p><h3 id="open"><a href="#open" class="headerlink" title="open"></a>open</h3><p>建立连接时触发</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">socket.<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>WebSocket</tag>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js同步异步</title>
    <link href="/2024/04/26/js%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5/"/>
    <url>/2024/04/26/js%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是同步异步"><a href="#什么是同步异步" class="headerlink" title="什么是同步异步"></a>什么是同步异步</h1><ul><li><p>同步编程</p><p>同步，指同一时序线、同一线程，多个操作按顺序进行，默认情况下，很多语言都是同步进行的，而当我们遇到执行较长的代码时，同步会让我们的程序造成阻塞</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义一个阻塞函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-params">milliSeconds</span>)&#123;<br>    <span class="hljs-keyword">var</span> startTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>()   <br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>() &lt; startTime + milliSeconds)<br>&#125;<br><span class="hljs-comment">// 阻塞3s</span><br><span class="hljs-title function_">sleep</span>(<span class="hljs-number">3000</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">123</span>)<br></code></pre></td></tr></table></figure><p>执行，发现等待3s后，控制台才有输出。程序发生了阻塞</p></li><li><p>异步编程</p><p>同理，异步就是不在同一线程、时许线上，相当于俩边同时进行，但是我们知道，js是单线程的，单线程要怎么做到异步呢？</p><p>虽然js是单线程的，但浏览器不是，浏览器在接受到异步请求后会交给其他线程执行，执行完成后返回。</p></li></ul><h1 id="异步的实现方式"><a href="#异步的实现方式" class="headerlink" title="异步的实现方式"></a>异步的实现方式</h1><p>在js中异步有两种实现方式：</p><ul><li><p><strong>回调函数</strong></p><p>比如<code>setTiemoUt()</code>函数，我们可以输入一个回调函数和一个时间作为参数，执行<code>setTimeout()</code>的时候会立即返回，执行下方的代码，在计时结束后会返回回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">setTiemout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;我是回调&quot;</span>)<br>&#125;,<span class="hljs-number">3000</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;我会比回调先执行&quot;</span>)<br></code></pre></td></tr></table></figure><p>回调函数非常简单好理解，但如果我们需要依次执行异步操作，就会被写成这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;等3s&quot;</span>)<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;再等3s&quot;</span>)<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;还等3s&quot;</span>)<br>    &#125;,<span class="hljs-number">3000</span>)<br>  &#125;,<span class="hljs-number">3000</span>)<br>&#125;,<span class="hljs-number">3000</span>)<br></code></pre></td></tr></table></figure><p>这种被称为函数瀑布，回调地狱，为了解决这个问题，ES6引入了<strong>promise</strong>类</p></li><li><p><strong>Promise</strong></p><p>直译为承诺，也就是先承诺，再通过回调兑现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>  <span class="hljs-comment">// 异步操作</span><br>  <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;成功信息&quot;</span>)<br>  <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;错误信息&quot;</span>)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>)=&gt;</span>&#123;<br>  <span class="hljs-comment">// 操作成功后</span><br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>)=&gt;</span>&#123;<br>  <span class="hljs-comment">// 操作失败后</span><br>&#125;).<span class="hljs-title function_">finally</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-comment">// 无论成功失败都会调用</span><br>&#125;)<br></code></pre></td></tr></table></figure><p><code>Promise</code>的构造函数接受一个回调函数作为参数，回调函数的参数有两个：<code>resoleve</code>和<code>reject</code></p><p>在promise中，**一定要调用<code>resolve()</code>或<code>reject()</code>**，<code>resolve()</code>用于返回成功信息，<code>reject()</code>用于返回错误信息，在执行后会对应的进入到<code>then()</code>方法或<code>catch()</code>方法，如果不写，promise会一直处于<code>pending</code>等待状态</p><p><code>Promise</code>的方法有</p><ul><li>then()：用于处理成功状态的回调</li><li>catch()：用于处理失败状态的回调</li><li>finally()：无论成功失败都会执行的回调</li></ul><p>而对于上面的回调地狱，promise提供了<strong>promise链</strong>来实现，将左右方向延申变为了上下方向</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;3s&quot;</span>);<br>        <span class="hljs-title function_">resolve</span>();<br>    &#125;, <span class="hljs-number">3000</span>);<br>&#125;)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 返回一个promise对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;又3s&quot;</span>);<br>            <span class="hljs-title function_">resolve</span>();<br>        &#125;, <span class="hljs-number">3000</span>);<br>    &#125;);<br>&#125;)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;还3s&quot;</span>);<br>    &#125;, <span class="hljs-number">3000</span>);    <br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;他们是异步，我是第一个执行的&quot;</span>);<br><br></code></pre></td></tr></table></figure></li><li><p><strong>async&#x2F;await</strong>语法糖</p><p>这是基于<code>Promise</code>的语法糖，通过<code>async</code>关键字可以将函数标记为异步函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>而<code>await</code>关键字用于<code>async</code>内部，用于等待另一个<code>promise</code>函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javas">const delay = (ms) =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms));<br><br>async function ff() &#123;<br>    await delay(3000);<br>    // 等待上面异步结束后才执行<br>    console.log(&quot;3s过去了&quot;);<br>&#125;<br><br>ff();<br>console.log(&quot;我最先执行&quot;);<br></code></pre></td></tr></table></figure></li></ul><p>​</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>eth向合约地址转账</title>
    <link href="/2024/04/15/eth%E5%90%91%E5%90%88%E7%BA%A6%E5%9C%B0%E5%9D%80%E8%BD%AC%E8%B4%A6/"/>
    <url>/2024/04/15/eth%E5%90%91%E5%90%88%E7%BA%A6%E5%9C%B0%E5%9D%80%E8%BD%AC%E8%B4%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="转账给普通账户"><a href="#转账给普通账户" class="headerlink" title="转账给普通账户"></a>转账给普通账户</h1><p>我们可以通过web3.js的接口进行转账</p><p>通过web3.js进行转账</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">web3.<span class="hljs-property">eth</span>.<span class="hljs-title function_">sendTransaction</span>(&#123;<span class="hljs-attr">from</span>: accounts[<span class="hljs-number">0</span>], <span class="hljs-attr">to</span>: accounst[<span class="hljs-number">1</span>],<span class="hljs-attr">value</span>: <span class="hljs-number">10</span>&#125;);<br></code></pre></td></tr></table></figure><p>在truffle中使用test脚本转账</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyContract</span> = artifacts.<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;MyContarct&quot;</span>);<br><br><span class="hljs-title function_">contract</span>(<span class="hljs-string">&quot;MyContract&quot;</span>, <span class="hljs-keyword">async</span> ()=&gt; &#123;<br>  <span class="hljs-title function_">it</span>(<span class="hljs-string">&quot;should transfer ether to specified address using Web3.js&quot;</span>, <span class="hljs-keyword">async</span> ()=&gt;&#123;<br>    <span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">await</span> <span class="hljs-title class_">MyContract</span>.<span class="hljs-title function_">deployed</span>(); <span class="hljs-comment">// 部署你的合约或者获取已部署的实例</span><br><br>        <span class="hljs-comment">// 设置转账目标地址和金额</span><br>        <span class="hljs-keyword">const</span> senderAddress = <span class="hljs-string">&quot;0x8b2e442DE68731F84bb8DF9da2a923Fd1aC9E80a&quot;</span>; <span class="hljs-comment">// 使用测试账户进行转账</span><br>        <span class="hljs-keyword">const</span> receiverAddress = <span class="hljs-string">&quot;0x502a65667b84f1f9E7C2E73D266b4a48783da25f&quot;</span>; <span class="hljs-comment">// 接收者地址</span><br>        <span class="hljs-keyword">const</span> amountToSend = web3.<span class="hljs-property">utils</span>.<span class="hljs-title function_">toWei</span>(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;ether&quot;</span>); <span class="hljs-comment">// 转账金额：1 ETH</span><br><br>        <span class="hljs-comment">// 获取发送者账户余额</span><br>        <span class="hljs-keyword">const</span> senderBalanceBefore = <span class="hljs-keyword">await</span> web3.<span class="hljs-property">eth</span>.<span class="hljs-title function_">getBalance</span>(senderAddress);<br><br>        <span class="hljs-comment">// 使用 Web3.js 进行转账</span><br>        <span class="hljs-keyword">await</span> web3.<span class="hljs-property">eth</span>.<span class="hljs-title function_">sendTransaction</span>(&#123;<br>        <span class="hljs-attr">from</span>: senderAddress,<br>        <span class="hljs-attr">to</span>: receiverAddress,<br>        <span class="hljs-attr">value</span>: amountToSend<br>        &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="转账给合约账户"><a href="#转账给合约账户" class="headerlink" title="转账给合约账户"></a>转账给合约账户</h1><p>在eth中，并不支持给合约用户转账，即使将合约地址带入如上方法，也会出现回滚，转账失败。</p><p>我们可以通过在合约中定义一个<code>pay() public payable</code>函数，在调用时转账给合约账户</p><p>在test中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyContract</span> = artifacts.<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;MyContract&quot;</span>);<br><br><span class="hljs-title function_">contract</span>(<span class="hljs-string">&quot;MyContract&quot;</span>, <span class="hljs-title function_">async</span>()=&gt;&#123;<br>  <span class="hljs-title function_">it</span>(<span class="hljs-string">&quot;transfer to contract&quot;</span>, <span class="hljs-keyword">async</span> ()=&gt; &#123;<br>    <span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">await</span> <span class="hljs-title class_">MyContract</span>.<span class="hljs-title function_">deployed</span>();<br>    <span class="hljs-keyword">const</span> amountToSend = web3.<span class="hljs-property">utils</span>.<span class="hljs-title function_">toWei</span>(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;ether&quot;</span>); <span class="hljs-comment">// 转账金额：1 ETH</span><br>    <span class="hljs-keyword">await</span> instance.<span class="hljs-title function_">pay</span>(&#123;<span class="hljs-attr">from</span>: <span class="hljs-string">&quot;0x68090f81670Ba7D7F5f439004e02BB9683631AE8&quot;</span>,<span class="hljs-attr">value</span>: amountToSend&#125;)<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>在gangache中查询交易，可以获得合约地址，并通过合约地址查询到对应的余额</p>]]></content>
    
    
    
    <tags>
      
      <tag>区块链</tag>
      
      <tag>truffle</tag>
      
      <tag>web3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>truffle基础</title>
    <link href="/2024/04/12/truffle%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/04/12/truffle%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="truffle-是什么"><a href="#truffle-是什么" class="headerlink" title="truffle 是什么"></a>truffle 是什么</h1><p>Truffle 是一个在以太坊进行 DApp 开发的世界级开发环境、测试框架。可以合约的编译、部署、管理，通过命令控制台直接与智能合约进行交互等功能。</p><h1 id="truffle-安装"><a href="#truffle-安装" class="headerlink" title="truffle 安装"></a>truffle 安装</h1><p>首先需要安装 NodeJS v8.9.4 或 之后的版本，然后通过 npm 安装 truffle</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g truffle<br></code></pre></td></tr></table></figure><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><ol><li><p>创建项目文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> project<br></code></pre></td></tr></table></figure></li><li><p>创建空项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> project<br>truffle init<br></code></pre></td></tr></table></figure></li><li><p>创建实例代码和项目模板，init 创建的是一个空项目，如果需要创建模板，可以 <code>Truffle Box</code> 进行下载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">truffle unbox &lt;box-name&gt;<br></code></pre></td></tr></table></figure></li><li><p>项目结构</p><ul><li><code>contracts/</code>：存放合约</li><li><code>migrations/</code>：部署脚本文件目录</li><li><code>test/</code>：测试脚本目录</li><li><code>truffle-config.js</code>：配置文件</li></ul></li></ol><h1 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h1><p>配置文件自带注释，这里只讲简单的修改</p><ul><li><p><code>networks-development</code>：用于设置连接的网络，以 ganache 为例子,在 ganache 顶部有相关参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">development</span>: &#123;<br>  <span class="hljs-attr">host</span>: <span class="hljs-string">&quot;127.0.0.1&quot;</span>,<br>  <span class="hljs-attr">port</span>: <span class="hljs-number">7545</span>,<br>  <span class="hljs-attr">network_id</span>: <span class="hljs-number">5777</span>,<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>compilers-solc-version</code>：编译器版本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">compilers</span>: &#123;<br>  <span class="hljs-attr">sole</span>: &#123;<br>    <span class="hljs-attr">versioin</span>: <span class="hljs-string">&quot;0.8.21&quot;</span>,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="项目全过程"><a href="#项目全过程" class="headerlink" title="项目全过程"></a>项目全过程</h1><h2 id="连接到-Ganache"><a href="#连接到-Ganache" class="headerlink" title="连接到 Ganache"></a>连接到 Ganache</h2><p>略</p><h2 id="编写合约"><a href="#编写合约" class="headerlink" title="编写合约"></a>编写合约</h2><p>在<code>contracts/</code>文件夹中编写合约</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: UNLICENSED<br>pragma solidity ^0.8;<br>contract MyContract &#123;<br>    struct Flag &#123;<br>        string title;<br>        string content;<br>        address owner;<br>        uint ts;<br>    &#125;<br>    Flag[] public flags;<br><br>    // 添加评论<br>    function set(string memory title , string memory content) public &#123;<br>        flags.push(Flag(title, content, msg.sender, block.timestamp));<br>    &#125;<br><br>获取评论数量<br>    function getLength() public view returns(uint) &#123;<br>        return flags.length;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="编写迁移脚本"><a href="#编写迁移脚本" class="headerlink" title="编写迁移脚本"></a>编写迁移脚本</h2><p>迁移脚本文件，也可以叫迁移文件，是放在<code>migrations/</code>文件夹中的 js 文件，以数字开头，用于部署合约</p><p>如<code>1_deploy_MyContract.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyContract</span> = artifacts.<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;MyContract&quot;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">deployer</span>) &#123;<br>  <span class="hljs-comment">// 部署迁移合约</span><br>  deployer.<span class="hljs-title function_">deploy</span>(<span class="hljs-title class_">MyContract</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>MyContract</code>是合约名，而不是文件名，一个文件可以有多个合约,当有多个合约需要<strong>依次</strong>部署时，可以使用异步</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyContract</span> = artifacts.<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;MyContract1&quot;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyContract</span> = artifacts.<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;MyContract2&quot;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">deployer, network, accounts</span>) &#123;<br>  <span class="hljs-comment">// 部署合约</span><br>  <span class="hljs-keyword">await</span> deployer.<span class="hljs-title function_">deploy</span>(<span class="hljs-title class_">MyContract1</span>);<br>  <span class="hljs-comment">// 获取部署后的合约实例</span><br>  <span class="hljs-keyword">const</span> myContract1Instance = <span class="hljs-keyword">await</span> <span class="hljs-title class_">MyContract1</span>.<span class="hljs-title function_">deployed</span>();<br>  <span class="hljs-comment">// 获取合约地址</span><br>  <span class="hljs-keyword">const</span> contract1Address = myContract1Instance.<span class="hljs-property">address</span>;<br>  <span class="hljs-comment">// 利用合约地址部署合约(需要的话)</span><br>  <span class="hljs-keyword">await</span> deployer.<span class="hljs-title function_">deploy</span>(<span class="hljs-title class_">MyContract2</span>, contract1Address);<br>  <span class="hljs-comment">// 获取部署后的合约实例</span><br>  <span class="hljs-keyword">const</span> myContract2Instance = <span class="hljs-keyword">await</span> <span class="hljs-title class_">MyContract2</span>.<span class="hljs-title function_">deployed</span>();<br>  <span class="hljs-comment">// 获取合约地址</span><br>  <span class="hljs-keyword">const</span> contract2Address = myContract2Instance.<span class="hljs-property">address</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="部署合约"><a href="#部署合约" class="headerlink" title="部署合约"></a>部署合约</h2><p>终端输入 (<code>truffle complie</code>和<code>truffle migrate</code>) 或 <code>truffle migrate --reset</code> 进行合约的编译部署或重部署</p><p>如果出现了<code>hit an invalid opcode while deploying</code>这样的报错，需要修改<code>truffle-config.js</code>配置文件中版本 solc 版本，和合约对应。（这里是 0.8.0）</p><p>部署成功后出现下面类似信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">1_deploy_MyContract.js<br>======================<br><br>   Deploying &#x27;MyContract&#x27;<br>   ----------------------<br><span class="hljs-meta prompt_">   &gt; </span><span class="language-bash">transaction <span class="hljs-built_in">hash</span>:    0xa0516507693bd555e0b6bf49ee2fc0f3ea41041f1db897d0ea7481beb5978b09</span><br><span class="hljs-meta prompt_">   &gt; </span><span class="language-bash">Blocks: 0            Seconds: 0</span><br><span class="hljs-meta prompt_">   &gt; </span><span class="language-bash">contract address:    0x1E5e59B3FeD2030F8D6b7B2ec1D0D53E441f23a9</span><br><span class="hljs-meta prompt_">   &gt; </span><span class="language-bash">block number:        1</span><br><span class="hljs-meta prompt_">   &gt; </span><span class="language-bash">block timestamp:     1713065479</span><br><span class="hljs-meta prompt_">   &gt; </span><span class="language-bash">account:             0x9d3f59003Da03D71e647eE10294395Aba69C87Ae</span><br><span class="hljs-meta prompt_">   &gt; </span><span class="language-bash">balance:             99.998420554</span><br><span class="hljs-meta prompt_">   &gt; </span><span class="language-bash">gas used:            467984 (0x72410)</span><br><span class="hljs-meta prompt_">   &gt; </span><span class="language-bash">gas price:           3.375 gwei</span><br><span class="hljs-meta prompt_">   &gt; </span><span class="language-bash">value sent:          0 ETH</span><br><span class="hljs-meta prompt_">   &gt; </span><span class="language-bash">total cost:          0.001579446 ETH</span><br><br><span class="hljs-meta prompt_">   &gt; </span><span class="language-bash">Saving artifacts</span><br>   -------------------------------------<br><span class="hljs-meta prompt_">   &gt; </span><span class="language-bash">Total cost:         0.001579446 ETH</span><br></code></pre></td></tr></table></figure><h2 id="调用合约"><a href="#调用合约" class="headerlink" title="调用合约"></a>调用合约</h2><p>调用合约的方法有三种：通过 test 脚本调用，通过网页 js 调用，使用 truffle 控制台</p><ul><li><p>使用 truffle 控制台<code>truffle console</code></p><p>在终端中输入<code>truffle console</code>可以启动控制台，在控制台中，可以输入 js 语句对合约进行调用，且注意，一定要用异步方法</p><p>首先要实例化合约</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取合约实例</span><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">MyContract</span> = <span class="hljs-keyword">await</span> <span class="hljs-title class_">MyContract</span>.<span class="hljs-title function_">deployed</span>()<br></code></pre></td></tr></table></figure><p>接着就可以通过实例调用合约了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 调用合约的set方法</span><br><span class="hljs-keyword">await</span> <span class="hljs-title class_">MyContract</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;title&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>)<br></code></pre></td></tr></table></figure><p>此时在 ganache 的<code>transaction</code>中会出现<code>CONTRACT CALL</code>的交易，在终端中也会出现对应的信息</p><p>而如果调用的函数没有对链上数据进行修改，则不会出现<code>CONTRACT CALL</code>交易</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 调用合约的get方法</span><br><span class="hljs-keyword">let</span> flagLength = await <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MyContract</span>.</span></span>get<span class="hljs-constructor">Length()</span><br><span class="hljs-comment">// 查看数据</span><br>flagLength.<span class="hljs-keyword">to</span><span class="hljs-constructor">Number()</span><br></code></pre></td></tr></table></figure><p>而如果我们想要查看公开的状态变量，也可以通过实例进行访问，如果状态变量是个数组则需要输入一个 uint 作为参数</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 查看公开的状态变量<br>MyContract.flags(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure></li><li><p>使用网页 js</p></li></ul><h2 id="编写测试脚本"><a href="#编写测试脚本" class="headerlink" title="编写测试脚本"></a>编写测试脚本</h2><p>测试脚本可以部署并测试合约，也可以测试以部署的合约，测试使用<code>mocha</code>语法，支持一样的钩子函数<code>before()</code>、<code>after()</code>、<code>beforeEach()</code>和<code>afterEach()</code><br>测试脚本一般与对应的合约同名，并加上<code>.test.js</code>后缀<br>大体格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 导入合约</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Contract1</span> = artifacts.<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;Contract1&quot;</span>);<br><br><span class="hljs-comment">// 定义测试块，truffle使用了 contract 替换了 describe，函数参数为账户列表</span><br><span class="hljs-title function_">contract</span>(<span class="hljs-string">&quot;Contract1的测试&quot;</span>, <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">accounts</span>) =&gt; &#123;<br>  <br>  <span class="hljs-keyword">let</span> contract1;<br><br>  <span class="hljs-title function_">before</span>(<span class="hljs-keyword">async</span> ()=&gt;&#123;<br>    <span class="hljs-comment">// 所有测试用例之前执行</span><br>    <br>    <span class="hljs-comment">// 部署合约并获取合约实例</span><br>    <span class="hljs-comment">// 部署合约的三种方式</span><br>    <span class="hljs-comment">// 1. 使用nwe创建新的合约实例，构造参数可自己写</span><br>    contract1 = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Contract1</span>.<span class="hljs-title function_">new</span>(params,&#123;<span class="hljs-attr">value</span>: web3.<span class="hljs-property">utils</span>.<span class="hljs-title function_">toWei</span>(<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;Ether&quot;</span>), <span class="hljs-attr">gas</span>:..., <span class="hljs-attr">from</span>: accounts[<span class="hljs-number">1</span>]&#125;);<br>    <span class="hljs-comment">// 2. 使用deployed 通过迁移脚本创建合约实例，构造参数为迁移脚本中指定的参数</span><br>    contract1 = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Contract1</span>.<span class="hljs-title function_">deployed</span>();<br>    <span class="hljs-comment">// 3. 使用at连接到已部署的合约</span><br>    contract1 = awati <span class="hljs-title class_">Contrac1</span>.<span class="hljs-title function_">at</span>(address);<br>  &#125;)<br>  <span class="hljs-title function_">beforeEach</span>( <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 在本区块的每个测试用例之前执行</span><br>    <span class="hljs-comment">// 如果需要用例之间互相独立，则可以使用beforeEach进行初始化</span><br>  &#125;)<br>  <span class="hljs-comment">// 测试用例</span><br>  <span class="hljs-title function_">it</span>(<span class="hljs-string">&quot;测试内容：应该初始化合约&quot;</span>, <span class="hljs-keyword">async</span> ()=&gt;&#123;<br>    <span class="hljs-comment">// 执行的操作</span><br>    <span class="hljs-comment">// 获取合约的状态或调用方法等</span><br><br><br>    <span class="hljs-comment">// 断言</span><br>    <span class="hljs-comment">// 断言相等，不等则抛出错误，错误信息为message</span><br>    assert.<span class="hljs-title function_">equal</span>(actual, expected, message);<br>    <span class="hljs-comment">// 断言不等，相等抛出错误，错误信息为message</span><br>    assert.<span class="hljs-title function_">notEqual</span>(actual, expected, message);<br>    <span class="hljs-comment">// 断言为真，不为真则抛出错误，错误信息为message</span><br>    assert.<span class="hljs-title function_">isTrue</span>(value, message);<br>    <span class="hljs-comment">// 断言为假，不为假则抛出错误，错误信息为message</span><br>    assert.<span class="hljs-title function_">isFalse</span>(value, message)<br>  &#125;)<br>  <span class="hljs-comment">// 更多测试用例</span><br>  <span class="hljs-title function_">it</span>(<span class="hljs-params"></span>)&#123;&#125;<br>  <span class="hljs-title function_">afterEach</span>( <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">// 在本区块的每个测试用例之后执行</span><br>    <span class="hljs-comment">// 可以对所有用例进行统一断言或清理操作</span><br>  &#125;)<br>  <span class="hljs-title function_">after</span>( <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">// 在所有测试用例执行完后执行</span><br>    <span class="hljs-comment">// 可以进行清理操作，比如撤销合约或释放资源</span><br>  &#125;)<br><br>&#125;)<br><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 引用合约</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Greeter</span> = artifacts.<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;Greeter&quot;</span>);<br><br><span class="hljs-comment">//执行定义合约中的其他操作</span><br><span class="hljs-title function_">contract</span>(<span class="hljs-string">&quot;Greeter&quot;</span>, <span class="hljs-function">(<span class="hljs-params">accounts</span>) =&gt;</span> &#123;<br><br>  <span class="hljs-comment">// before 测试前的准备工作</span><br>  <span class="hljs-title function_">before</span>(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-comment">// 部署合约的两种方式</span><br>    <span class="hljs-comment">//01 通过迁移脚本部署，不能传递构造参数</span><br>    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Greeter</span>.<span class="hljs-title function_">deployed</span>();<br>    <span class="hljs-comment">//02 直接创建新的合约实例，可以传递构造参数</span><br>    <span class="hljs-comment">//let Contract_Ches  = await Ches.new(var_a);</span><br>    <span class="hljs-keyword">let</span> c = <span class="hljs-keyword">await</span> a.<span class="hljs-title function_">getGreeting</span>();<br>    <span class="hljs-keyword">let</span> d = <span class="hljs-keyword">await</span> a.<span class="hljs-title function_">setGreeting</span>(var_b);<br>    <span class="hljs-keyword">let</span> f = <span class="hljs-keyword">await</span> a.<span class="hljs-title function_">getGreeting</span>();<br><br>    <span class="hljs-comment">//在原有的合约上进行获取</span><br>    <span class="hljs-keyword">let</span> g = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Greeter</span>.<span class="hljs-title function_">at</span>(<span class="hljs-string">&quot;0x592C0067a4B3Fc66D7f26430b3EBeF9ac7796F85&quot;</span>);<br>    <span class="hljs-keyword">let</span> h = <span class="hljs-keyword">await</span> g.<span class="hljs-title function_">getGreeting</span>();<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-keyword">await</span> g.<span class="hljs-title function_">setGreeting</span>(<span class="hljs-string">&quot;您好，世界！&quot;</span>);<br>    <span class="hljs-keyword">let</span> k = <span class="hljs-keyword">await</span> g.<span class="hljs-title function_">getGreeting</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;合约地址:&quot;</span>, a.<span class="hljs-property">address</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;获取原数据:&quot;</span>, c);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;获取新数据:&quot;</span>, f);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;获取原来的合约地址:&quot;</span>, g.<span class="hljs-property">address</span>);<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;获取原来的合约值:&quot;</span>, h);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;更改原来合约的值，并且显示出来:&quot;</span>, k);<br>    <span class="hljs-comment">// console.log(&quot;02合约地址:&quot;,Contract_Ches.address);</span><br>  &#125;);<br><br>  <span class="hljs-comment">// it一个测试用例</span><br>  <span class="hljs-title function_">it</span>(<span class="hljs-string">&quot;实例描述，比如‘应该初始化合约状态’&quot;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;测试合约的操作:&quot;</span>);<br>  &#125;);<br>  <span class="hljs-comment">// 可以有多个测试用例</span><br>  <span class="hljs-title function_">it</span>(<span class="hljs-string">&quot;应该调用xx函数&quot;</span>， <span class="hljs-keyword">async</span> ()=&gt;&#123;<br>    <span class="hljs-comment">// 测试</span><br>    asset.<span class="hljs-title function_">equal</span>(i, <span class="hljs-string">&quot;你好世界&quot;</span>, <span class="hljs-string">&quot;i的值不是你好世界，执行结果不对&quot;</span>);<br>  &#125;)<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="常用-truffle-命令"><a href="#常用-truffle-命令" class="headerlink" title="常用 truffle 命令"></a>常用 truffle 命令</h1><h2 id="truffle-complie-合约编译"><a href="#truffle-complie-合约编译" class="headerlink" title="truffle complie - 合约编译"></a>truffle complie - 合约编译</h2><p>默认情况下，<code>truffle complie</code>只会编译更新的合约。可以用 <code>--all</code>强制编译所有合约，<code>--network</code>指定使用的网络</p><h2 id="truffle-development-开发网络"><a href="#truffle-development-开发网络" class="headerlink" title="truffle development - 开发网络"></a>truffle development - 开发网络</h2><p>会启动 truffle 内置的测试网络，在该网络中部署调用等操作不会影响真实网络</p><h2 id="truffle-console-控制台"><a href="#truffle-console-控制台" class="headerlink" title="truffle console - 控制台"></a>truffle console - 控制台</h2><p>可以使用<code>--network</code>指定要使用的网络</p><h2 id="truffle-migrate-部署合约"><a href="#truffle-migrate-部署合约" class="headerlink" title="truffle migrate - 部署合约"></a>truffle migrate - 部署合约</h2><p><code>truffle migrate</code>.命令将从最后完成的迁移脚本开始运行。<br><code>--reset</code>：从头运行所有迁移脚本</p><h2 id="truffle-networks-检查网络构件"><a href="#truffle-networks-检查网络构件" class="headerlink" title="truffle networks - 检查网络构件"></a>truffle networks - 检查网络构件</h2><p>显示每个网络上的部署合约的地址</p><h2 id="truffle-test-运行测试脚本"><a href="#truffle-test-运行测试脚本" class="headerlink" title="truffle test - 运行测试脚本"></a>truffle test - 运行测试脚本</h2><p>执行<code>test/</code>文件夹中的测试脚本，可以加上文件名运行特定测试。</p><h2 id="truffle-unbox-下载模板"><a href="#truffle-unbox-下载模板" class="headerlink" title="truffle unbox - 下载模板"></a>truffle unbox - 下载模板</h2><p>下载指定模板，后接模板名</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区块链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sh脚本学习</title>
    <link href="/2024/04/10/sh%E8%84%9A%E6%9C%AC%E4%B8%8E%E5%91%BD%E4%BB%A4/"/>
    <url>/2024/04/10/sh%E8%84%9A%E6%9C%AC%E4%B8%8E%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-sh-脚本"><a href="#什么是-sh-脚本" class="headerlink" title="什么是 sh 脚本"></a>什么是 sh 脚本</h1><p>sh 脚本就是 Shell，简单来说可以自动进行命令行的操作</p><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>只需要有文本编辑器和解释器就可以了，linux 常见的有<br>Bourne Shell（&#x2F;usr&#x2F;bin&#x2F;sh 或&#x2F;bin&#x2F;sh）<br>Bourne Again Shell（&#x2F;bin&#x2F;bash）<br>C Shell（&#x2F;usr&#x2F;bin&#x2F;csh）<br>K Shell（&#x2F;usr&#x2F;bin&#x2F;ksh）<br>Shell for Root（&#x2F;sbin&#x2F;sh<br>这里讲的是 Bash</p><h1 id="helloworld"><a href="#helloworld" class="headerlink" title="helloworld"></a>helloworld</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># 输出hello world</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello world&quot;</span><br></code></pre></td></tr></table></figure><p><code>#!</code>标记会告诉系统使用什么解释器来执行<br><code>#</code>表示注释，后面的内容都会被解释器忽略<br><code>echo &quot;hello world&quot;</code>表示输出文本</p><h1 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h1><p>首先需要让文件有被执行的权限，在命令行输入以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">chmodd +x ./hello.sh<br></code></pre></td></tr></table></figure><p>然后就可以执行脚本了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./hello.sh<br></code></pre></td></tr></table></figure><p>如果想指定解释器，还可以将脚本作为解释器参数</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/bin/</span>sh hello.sh<br><span class="hljs-regexp">/bin/</span>php hello.php<br></code></pre></td></tr></table></figure><p>这种写法会忽略第一行的解释器指定</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><p>shell 声明变量类似 python，直接变量名＋赋值就好了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">hello=<span class="hljs-string">&quot;world&quot;</span><br></code></pre></td></tr></table></figure><p><strong>注意，等号前后不能有空格</strong>，等号两侧出现空格可能会导致错误</p><h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><p>在使用变量时，只需在变量名前加<code>$</code>就可以了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">hello=<span class="hljs-string">&quot;world&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$hello</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;$hello&#125;</span><br></code></pre></td></tr></table></figure><p>如上，其中<code>&#123;&#125;</code>花括号用于帮助解释器识别变量的边界，比如下面这种写法</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">hello=<span class="hljs-string">&quot;world&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$hellohello</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;hello&#125;</span>hello&quot;</span><br></code></pre></td></tr></table></figure><p><code>$hellohello</code>会被认为是使用了一个名为<code>hellohello</code>的变量(其值为空)，<code>$&#123;hello&#125;hello</code>则会打印出“worldhello”</p><h2 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h2><p>可以使用<code>readonly</code>命令将变量定义为只读，其值不能被改变<br><strong>使用时慎重，这个操作不可逆</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 声明变量</span><br>myName=<span class="hljs-string">&quot;lihua&quot;</span><br><span class="hljs-comment"># 定义为只读变量</span><br><span class="hljs-built_in">readonly</span> myName<br><span class="hljs-comment"># 尝试修改只读变量的值发生报错</span><br>myName=:<span class="hljs-string">&quot;xiaoming&quot;</span><br></code></pre></td></tr></table></figure><p>也可以在声明的时候定义</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">readonly</span> myName=<span class="hljs-string">&quot;lihua&quot;</span><br>myName=<span class="hljs-string">&quot;xiaoming&quot;</span><br></code></pre></td></tr></table></figure><h2 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h2><p>使用<code>unset</code>命令可以删除变量，<strong>但不能删除只读变量</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">unset</span> myName<br></code></pre></td></tr></table></figure><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>和其他语言一样，shell 也有变量类型</p><ul><li>字符串类型<br>默认情况下，<strong>变量通常被视为字符串</strong>，比如</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br>a=1<br>b=<span class="hljs-variable">$a</span>+1<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$b</span><br></code></pre></td></tr></table></figure><p>上面的代码虽然看着是赋值了一个整形，但其实是会作为字符串解释的，所以 b 的值是“1+1”<br>也可以使用单引号或双引号定义字符串</p><ul><li>整数<br>可以使用<code>declare</code>或<code>typeset</code>（在 bash 中<code>typeset</code>是<code>declare</code>的别名，用法一致）命令来定义整数变量，但这是不一定的，有些 shell 并不是用这两个命令，所以开头指定解释器很重要</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">declare</span> -i num1=100<br><span class="hljs-built_in">typeset</span> -i num2=200<br></code></pre></td></tr></table></figure><ul><li>数组<br>数组可以分为<strong>索引数组</strong>和<strong>关联数组</strong>，其实两者的区别只是键值对的区别而已，<strong>索引数组使用下标作为键，关联数组使用字符串作为键</strong></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 定义索引数组</span><br>my_array=(1 2 3 4 5)<br><span class="hljs-comment"># 使用declare或typeset定义索引数组</span><br><span class="hljs-built_in">typeset</span> -a my_array2=(1 2 3 4 5)<br><span class="hljs-comment"># 使用declare或typeset定义关联数组</span><br><span class="hljs-built_in">typeset</span> -A my_array3=([key]=value)<br>my_array3[<span class="hljs-string">&quot;name&quot;</span>]=<span class="hljs-string">&quot;lihua&quot;</span><br>my_array3[<span class="hljs-string">&quot;age&quot;</span>]=20<br></code></pre></td></tr></table></figure><p>想要调用数组需要用<code>&#123;&#125;</code>将变量名+索引括起来</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;my_array[0]&#125;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;my_array3[&quot;name&quot;]&#125;</span><br></code></pre></td></tr></table></figure><p>还可以使用<code>!</code>和<code>*</code>，获取索引或所有值</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 使用*或@获取所有值</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;my_arrar3[*]&#125;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;my_arrar3[@]&#125;</span><br><span class="hljs-comment"># 获取索引</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;!my_arrar3[*]&#125;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;!my_arrar3[@]&#125;</span><br></code></pre></td></tr></table></figure><ul><li>环境变量<br>环境变量由用户或系统设置的特殊变量，比如<code>PATH</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><p>可以使用 export 查看环境变量，会有类似下面的返回值</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">declare</span> -<span class="hljs-keyword">x</span> USER<span class="hljs-operator">=</span><span class="hljs-string">&quot;ww&quot;</span><br><span class="hljs-keyword">declare</span> -<span class="hljs-keyword">x</span> PWD<span class="hljs-operator">=</span><span class="hljs-string">&quot;/home/ww&quot;</span><br></code></pre></td></tr></table></figure><p><code>-x</code>表示变量为环境变量</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$USER</span><br><span class="hljs-comment"># 返回&quot;ww&quot;</span><br></code></pre></td></tr></table></figure><ul><li>特殊变量<br>有一些特殊变量在 Shell 具有特殊含义，例如<code>$0</code>表示脚本的名称，<code>$1</code>, <code>$2</code>, 等表示脚本的参数。</li></ul><p><code>$#</code>表示传递给脚本的参数数量，<code>$?</code>表示上一个命令的退出状态等。</p><h2 id="Shell-字符串"><a href="#Shell-字符串" class="headerlink" title="Shell 字符串"></a>Shell 字符串</h2><h3 id="单双引号区别"><a href="#单双引号区别" class="headerlink" title="单双引号区别"></a>单双引号区别</h3><p>单引号和双引号都可以用来表示字符串（甚至可以不用引号），但两者还是有些区别</p><ul><li>单引号<ul><li>无视变量，所有内容都会原样输出</li><li>单引号字符串中不能出现单独一个单引号（用转义符也不行），但可以成对出现，作为</li></ul></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;$name\n&#x27;</span>123<span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-comment">#输出 $name123</span><br></code></pre></td></tr></table></figure><ul><li>双引号<ul><li>双引号内可以有变量</li><li>双引号内可以有转义字符</li></ul></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">name=<span class="hljs-string">&quot;lihua&quot;</span><br><span class="hljs-comment"># -e开启转义</span><br><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;my name is \n \&quot;<span class="hljs-variable">$&#123;name&#125;</span>\&quot;&quot;</span><br><span class="hljs-comment">#输出</span><br><span class="hljs-comment">#my name is</span><br><span class="hljs-comment"># &quot;lihua&quot;</span><br></code></pre></td></tr></table></figure><h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">str=<span class="hljs-string">&quot;abcd&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;#str&#125;</span><br><span class="hljs-comment"># 输出4</span><br></code></pre></td></tr></table></figure><p><code>#</code>用于获取元素的长度，可以指定索引。对于字符串而言<code>str</code>就是<code>str[0]</code>，可以&#96;$</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bash</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0x01和0x1有何不同</title>
    <link href="/2024/04/07/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0%E5%9C%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA/"/>
    <url>/2024/04/07/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0%E5%9C%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="有区别？"><a href="#有区别？" class="headerlink" title="有区别？"></a>有区别？</h1><p>还真有，今天在给bytes1类型变量赋值的时候<code>0x1</code>一直报错，但是我上面的<code>0x12</code>却没有报错，最后我把<code>0x1</code>换成<code>0x01</code>就好了。那么，这两者有什么不同呢？</p><h1 id="十六进制如何存储到二进制位上"><a href="#十六进制如何存储到二进制位上" class="headerlink" title="十六进制如何存储到二进制位上"></a>十六进制如何存储到二进制位上</h1><p>在十六进制中，一个位上能表示的最大值是F，也就是15，最小值则是0，而0-15则刚好可以用<strong>4个二进制位表示</strong></p><p>所以<strong>十六进制的每一个位都能用一个四位的二进制表示</strong>。</p><p>比如<code>0x1</code>就是二进制<code>0001</code>，<code>0x1F</code>就是二进制<code>0001 1111</code>，而<code>0x01</code>表示的自然就是<code>0000 0001</code>了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>那么回归问题，虽然<code>0x01</code>和<code>0x1</code>表示的值是相同的，但是他们在二进制位上并不相同，而我用的变量刚好是bytes1类型，长度是一个字节，也就是8个二进制位，当我赋值<code>0x1</code>的时候，长度对不上也就报错了，提示也是“类型不能进行隐式转换”</p>]]></content>
    
    
    
    <tags>
      
      <tag>小玩意</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端大师课</title>
    <link href="/2024/01/16/%E5%89%8D%E7%AB%AF%E5%A4%A7%E5%B8%88%E8%AF%BE/"/>
    <url>/2024/01/16/%E5%89%8D%E7%AB%AF%E5%A4%A7%E5%B8%88%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="事件（消息）循环"><a href="#事件（消息）循环" class="headerlink" title="事件（消息）循环"></a>事件（消息）循环</h1><h2 id="浏览器进程模型"><a href="#浏览器进程模型" class="headerlink" title="浏览器进程模型"></a>浏览器进程模型</h2><h3 id="何为进程"><a href="#何为进程" class="headerlink" title="何为进程"></a>何为进程</h3><p>程序运行需要自己的专属内存空间，可以把这块内存空间简单的理解为进程。每个应用至少有一个进程，<strong>进程之间相互独立</strong>，即使要通信，也需要双方同意。</p><h3 id="何为线程"><a href="#何为线程" class="headerlink" title="何为线程"></a>何为线程</h3><p>有了进程后，就可以运行程序的代码，运行代码的【人】成为【线程】，<strong>一个进程至少有一个线程，随进程开启自动创建，称为主线程</strong>，如果需要同时执行多块代码，<strong>主线程就会启动更多线程</strong>，所以一个进程可以有多个线程。</p><p>举个例子做饭，我去买菜，我妈去买肉，我爸去买调味品，就是同时进行的三个线程。</p><p>线程之间可以相互通信。</p><h3 id="浏览器有哪些进程的线程"><a href="#浏览器有哪些进程的线程" class="headerlink" title="浏览器有哪些进程的线程"></a>浏览器有哪些进程的线程</h3><p>主要进程有：</p><ol><li><p>浏览器进程：</p><p>主要负责界面显示（不是网页的展示，是标题栏、返回按钮、刷新按钮、导航栏等）、用户交互、子进程管理。浏览器内部会启动多个线程处理不同的任务。</p></li><li><p>网络进程：</p><p>网络通信，网络进程内部会启动多个线程处理不同的网络任务。</p></li><li><p>渲染进程：</p><p>负责执行HTML、CSS、JS代码，默认情况下，每开启一个标签页都会开启一个新的渲染进程，以保证网页互不影响。</p></li></ol><h2 id="渲染主线程是如何工作的？"><a href="#渲染主线程是如何工作的？" class="headerlink" title="渲染主线程是如何工作的？"></a>渲染主线程是如何工作的？</h2><ul><li>解析HTML</li><li>解析CSS</li><li>计算样式</li><li>布局</li><li>处理图层</li><li>每秒把页面画60次</li><li>执行全局JS代码</li><li>执行事件处理函数</li><li>执行计时器的回调函数</li><li>…</li></ul><blockquote><p>思考：主线程要处理这么多任务，要怎么调度任务？渲染进程为什么不适用多个线程来处理？</p></blockquote><p>比如：</p><ul><li>执行js函数的时候，用户点击了按钮，应该立即执行点击事件的处理函数吗？</li><li>执行js函数的时候，某个计时器到时间了，应该立即去执行它的回调吗？</li><li>用户按下按钮同时计时器也到达了时间，应该处理哪一个？</li></ul><p>主线程用<strong>排队</strong>解决这些问题。</p><p>将任务放在<strong>消息队列（message queue）</strong>中排队，一次只处理一个任务，而处理任务的过程中可能又会出现新的任务，新的任务依然放如消息队列中排队，且任务来源可以是其他线程。</p><p>具体工作步骤如下：</p><ol><li>在最开始的时渲染主进程进入无限循环</li><li>每一次循环检查消息队列中有无任务，有则取出第一个任务，执行玩后进入下一次循环；如果没有，则进入休眠状态</li><li>其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会添加到尾部，添加新任务时，如果主线程是休眠状态，则会将其唤醒以循环拿去任务</li></ol><p>整个过程就是事件（消息）循环</p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>在代码执行中，会遇到无法立即执行的任务，比如:</p><ul><li>记时完成后执行的任务：<code>setTimeout</code>、<code>setInterval</code></li><li>网络通信完成后执行的任务：<code>XHR</code>、<code>Fetch</code></li><li>用户操作后需要执行的任务：<code>addEventListener</code></li></ul><p>如果让渲染主线程等待，就会导致主线程长期处于<strong>阻塞</strong>状态，导致卡死。所以浏览器选择<strong>异步</strong>处理</p><p>当渲染主线程收到计时任务时，会发给<strong>操作线程</strong>进行计时，操作线程计时完成后回调到渲染主线程；如果计时这段时间渲染主线程跟着等待（阻塞），则称为<strong>同步</strong>；而<strong>异步</strong>则是不等待，在渲染主线程发送计时任务后，继续从<strong>消息队列</strong>获取新任务，而当操作线程计时结束后，操作线程也不会把回调放入渲染主线程中，而是放入消息队列中。</p><blockquote><p>如何理解js中的异步?</p><p>参考答案:<br>JS是一门<strong>单线程的语言</strong>，这是因为它运行在浏览器的渲染主线程中，而<strong>渲染主线程只有一个</strong>。而渲染主线程承担着诸多的工作，渲染页面、执行 JS 都在其中运行。如果使用同步的方式，就极有可能导致主线程产生<strong>阻塞</strong>，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。<br>所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程<strong>将任务交给其他线程去处理</strong>，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，<strong>将事先传递的回调函数包装成任务，加入到消息队列的未尾排队</strong>，等待主线程<strong>调度</strong>执行。在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。</p></blockquote><p>小例子:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Mr,Yuan is awesome !<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>change<span class="hljs-tag">&lt;/<span class="hljs-name">buttons</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> h1 = <span class="hljs-variable language_">document</span> .<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;h1&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>)</span><br><span class="language-javascript">    <span class="hljs-comment">// 死循环指定的时间</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">delay</span>(<span class="hljs-params">duration</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> start = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() ;</span><br><span class="language-javascript">        <span class="hljs-keyword">while</span> (<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - start &lt; duration)&#123;&#125; </span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        h1.<span class="hljs-property">textContent</span> = <span class="hljs-string">&quot;衰老师很帅!&quot;</span>;</span><br><span class="language-javascript">        <span class="hljs-title function_">delay</span>(<span class="hljs-number">3000</span>);    </span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>按照字面理解应该是点击按钮,h1文本立刻被替换,然后再执行3000ms的计时,但是在实际情况中点击按钮后，文本不会立即被改变，而是在等待3秒后，文本才改变。</p><p>实际呢？代码上也确实是先执行替换文本，然后再进入计时。替换文本后，为什么页面不会改变呢？这是因为页面还没有渲染。而渲染也是一个任务，所以在完成文本替换之后，会在消息队列里添加渲染任务。然后继续执行死循环计时任务。等到计时任务完成之后再去执行渲染任务。</p><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>任务有优先级吗？没有，但是队列有优先级，在以前，消息队列可分为<strong>宏队列</strong>和<strong>微队列</strong>，微队列的优先级更高。而在最新的W3C中，没有了宏队列，而是加入了更多的队列分类，常用的有：</p><ul><li>延时队列：用于存放计时器到达后的回调任务，优先级【中】</li><li>交互队列：用于存放用户操作后产生的事件处理任务，优先级【高】</li><li>微队列：用户存放需要最快执行的任务，优先级【最高】</li></ul><p><strong>同类型的任务必须放在同一个队列</strong></p><p>添加任务到微队列的方式主要是使用promise,MutationObserver。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//立即把一个函数添加到微队列</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(函数)<br></code></pre></td></tr></table></figure><p>例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//死循环指定时间</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">delay</span>(<span class="hljs-params">duration</span>) &#123;<br>  <span class="hljs-keyword">var</span> start = <span class="hljs-title class_">Data</span>.<span class="hljs-title function_">now</span>();<br>  <span class="hljs-keyword">while</span> (<span class="hljs-title class_">Data</span>.<span class="hljs-title function_">now</span>() - start &lt; duration) &#123;&#125;<br>&#125;<br><span class="hljs-comment">//设置0s的计时器</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>&#125;,<span class="hljs-number">0</span>)<br><br><span class="hljs-title function_">delay</span>(<span class="hljs-number">1000</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>执行结果是：一秒后输出2，1，渲染主线程会先执行全局的js，这个js的执行步骤如下：</p><ol><li>执行settimout，向<strong>操作线程</strong>发送一个计时任务，由于是0秒计时，所以操作线程立即返回任务到<strong>延时队列</strong>中</li><li>执行delay（1000），等待1s</li><li>执行console.log(2)，控制台输出2，到此，全局js执行完毕，进入事件循环</li><li>进入事件循环，先从<strong>微队列</strong>寻找任务，没有；再从<strong>交互队列</strong>寻找，没有；然后从<strong>延时队列</strong>寻找，找到了计时器回调函数任务，执行它，控制台输出1</li><li>结果： 等待1秒后，控制台输出2 1</li></ol><h1 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h1><h2 id="浏览器是如何渲染页面的？"><a href="#浏览器是如何渲染页面的？" class="headerlink" title="浏览器是如何渲染页面的？"></a>浏览器是如何渲染页面的？</h2><p>当浏览器的<strong>网络线程</strong>收到HTML文档后，会产生一个<strong>渲染任务</strong>，并传递给<strong>渲染主线程</strong>的<strong>消息队列</strong>，事件循环机制的作用下，渲染主线程取出队列中的渲染任务，开启渲染流程</p><p>整个渲染流程分为多个阶段：<strong>HTML解析、样式计算、布局、分层、绘制、分块、光栅化、画</strong></p><h3 id="解析HTML"><a href="#解析HTML" class="headerlink" title="解析HTML"></a>解析HTML</h3><p>将HTML字符串解析之后会得到两颗树：<strong>DOM树</strong>和<strong>CSSOM树</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>html</tag>
      
      <tag>js</tag>
      
      <tag>csss</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL数据库学习</title>
    <link href="/2024/01/15/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/01/15/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="基础应用"><a href="#基础应用" class="headerlink" title="基础应用"></a>基础应用</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="启动与停止MySQL服务"><a href="#启动与停止MySQL服务" class="headerlink" title="启动与停止MySQL服务"></a>启动与停止MySQL服务</h3><p>在安装MySQL后，可以通过命令行启动服务，只需输入以下命令</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">net</span> <span class="hljs-built_in">start</span> [服务名]<br></code></pre></td></tr></table></figure><p>我的服务名为<code>mysql57</code>，所以输入</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">net</span> <span class="hljs-built_in">start</span> mysql57<br></code></pre></td></tr></table></figure><p>不知道服务名的可以<code>win+R</code>输入<code>services.msc</code>，在弹出的【服务】管理器中可以找到名字带有<strong>MySQL</strong>的服务，比如<code>MySQL57</code>,当然，也可以在这里打开服务。</p><p><strong>如果启动服务时出现“拒绝访问”，可以用管理员模式打开终端</strong>,WIN+R，输出cmd，然后CTRL+SHIFT+ENTER即可。</p><p>如果想要停止服务，则输入</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">net</span> stop<span class="hljs-meta"> [服务名]</span><br></code></pre></td></tr></table></figure><p>比如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">net stop mysql57<br></code></pre></td></tr></table></figure><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>登录的指令需要在<strong>MySQL安装目录的bin文件下输入</strong>，默认的文件路径为<code>c:\Program Files\MySQL</code>，可以通过<code>cd</code>指令进入</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">cd c:<span class="hljs-string">\Program</span> Files<span class="hljs-string">\MySQL\MySQL</span> Server <span class="hljs-number">5.7</span><span class="hljs-string">\bin</span><br></code></pre></td></tr></table></figure><p>然后通过<code>mysql</code>指令登录</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mysql -h <span class="hljs-selector-attr">[主机名]</span> -u <span class="hljs-selector-attr">[用户名]</span> -<span class="hljs-selector-tag">p</span><br></code></pre></td></tr></table></figure><p>默认为</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mysql -h localhost -u root -<span class="hljs-selector-tag">p</span><br></code></pre></td></tr></table></figure><p>之后输入密码即可</p><h3 id="配置PATCH变量"><a href="#配置PATCH变量" class="headerlink" title="配置PATCH变量"></a>配置PATCH变量</h3><p>每次都要进入文件夹运行非常麻烦，不过只要设置了PATH就可以全局使用了。设置方法如下</p><ol><li>右键“我的电脑”-“属性”-“高级系统设置”-“环境变量”’</li><li>在系统变量中找到“patch”</li><li>添加bin文件的路径，比如”c:\Program Files\MySQL\MySQL Server 5.7\bin”</li></ol><p>现在就可以全局使用<code>mysql</code>了</p><h3 id="更改配置文件"><a href="#更改配置文件" class="headerlink" title="更改配置文件"></a>更改配置文件</h3><ol><li><p>使用配置向导修改配置</p><p>即<strong>mysqlinstaller</strong>，使用方法与安装MySQL时类似，软件路径为：<code>C:\Program Files\MySQL\MySQL Installer for Windows</code></p></li><li><p>手动修改配置</p><p>MySQL默认的安装路径是<code>C:\Program Files\MySQL\MySQL Server 5.7</code>,大多数版本包含以下文件夹</p><table><thead><tr><th>文件夹</th><th>内容</th></tr></thead><tbody><tr><td>bin</td><td>客户端程序和服务端程序</td></tr><tr><td>C:\Program Files (x86)\MySQL\MySQL Server 5.7\Data</td><td>数据库和日志文件</td></tr><tr><td>include</td><td>包含（头）文件</td></tr><tr><td>lib</td><td>库文件</td></tr><tr><td>share</td><td>字符集、语言等消息</td></tr><tr><td>examples</td><td>示例程序和脚本</td></tr></tbody></table><p>在安装目录下还包含<strong>ini</strong>类型的文件，如：</p><ul><li>my.ini：当前应用的配置文件</li><li>my_日期时间.ini：修改配置后自动生成的以日期时间命名的配置文件</li></ul><p>手工修改配置就是修改my.ini的内容。</p></li></ol><h2 id="创建与维护数据库"><a href="#创建与维护数据库" class="headerlink" title="创建与维护数据库"></a>创建与维护数据库</h2><h3 id="数据库特点"><a href="#数据库特点" class="headerlink" title="数据库特点"></a>数据库特点</h3><p>SQL有以下特点</p><ol><li>一体化： 集数据定义语言、数据操纵语言、数据控制语言元素为一体。</li><li>使用方式： 交互使用方式和嵌入高级语言中的使用方式</li><li>非过程化语言：只需要提出“干什么”，不需要指出“如何干”，语句的操作用系统自动完成</li><li>人性化：符合人们的思维方式、容易理解和掌握</li></ol><h3 id="SQL的分类"><a href="#SQL的分类" class="headerlink" title="SQL的分类"></a>SQL的分类</h3><p>在MySQL中，SQL可以分为3类：<strong>数据定义语言、数据操纵语言、数据控制语言</strong>：</p><ol><li><p>数据定义语言（Data Definition Language ,DDL）</p><p>DDL是最基础的SQL类型，<strong>用来创建数据库和创建、修改、删除数据库中的各种对象</strong>，为其他语言的操作提供对象。最常用的DDL语句是：<code>CREATE、DROP、ALTER</code></p></li><li><p>数据操纵语言（Data Manipulation Language ,DML)</p><p>DML用于<strong>完成数据查询和数据更新操作</strong>，其中数据更新是指<strong>对数据进行插入、删除和修改操作</strong>。最常用的DML语句是：<code>SELECT、INSERT、UPDATA、DELETE</code></p></li><li><p>数据控制语言（Data Control Language, DCL）</p><p>DCL是用来设置或更改数据库用户或角色权限的语句，主要包括<code>GRANT</code>语句和<code>REVOKE</code>语句。<code>GRANT</code>语句可以将指定的安全对象的权限授予相应的主体，<code>REVOKE</code>语句则删除授予的权限</p></li></ol><h3 id="数据库文件"><a href="#数据库文件" class="headerlink" title="数据库文件"></a>数据库文件</h3><p>在MySQL中，每个数据库都对应存放一个与数据库同名的文件夹中。 My circle数据库文件有.frM，.MYD和.NYI中的三种。其中.FRM是描述表结构的文件，.myd的是表的数据文件。.NYI是表数据文件中的索引文件。它们都存放在与数据库同名的文件夹中。</p><h3 id="自动创立的数据库"><a href="#自动创立的数据库" class="headerlink" title="自动创立的数据库"></a>自动创立的数据库</h3><p>MySQL安装完成之后，将会在data目录下自动创建四个数据库，在连接到数据库后，可以通过<code>SHOW DATABASES;</code>命令查看当前所有数据库</p><table><thead><tr><th>数据库</th><th>作用</th></tr></thead><tbody><tr><td>mysql</td><td>描述用户访问权限。</td></tr><tr><td>information_schema</td><td>保存关于MySQL服务器维护的所有其他数据库的信息，如数据库名、数据库表、表栏的数据类型与访问权限等。</td></tr><tr><td>performance_schema</td><td>主要用于收集数据库服务器性能参数。</td></tr><tr><td>sys</td><td>通过视图的形式把information_schema和performance_schema结合起来，查询出更加容易理解的数据存储过程，可以执行一些性能方面的配置，也可以得到一些性能诊断报告内容。</td></tr></tbody></table><p><strong>不要随意修改和删除系统自带的数据库</strong></p><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>使用<code>CREATE DATABASE</code>创建数据库，他的语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE database_name;<br></code></pre></td></tr></table></figure><p>注意不要忘记分号，database_name是要创建的数据库的名字</p><h3 id="打开数据库"><a href="#打开数据库" class="headerlink" title="打开数据库"></a>打开数据库</h3><p>使用<code>USE</code>打开数据库，他的语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE database_name;<br></code></pre></td></tr></table></figure><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><p>使用<code>DROP</code>删除数据库，他的语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> DATABASE database_name;<br></code></pre></td></tr></table></figure><p>删除时一定要注意，数据库中存储的所有内容会被一同删除，且<strong>无法恢复</strong></p><h2 id="数据库存储引擎"><a href="#数据库存储引擎" class="headerlink" title="数据库存储引擎"></a>数据库存储引擎</h2><p>存储引擎就是存储数据，为存储的数据建立索引和更新查询数据等技术的实现方法。因为在关系数据库中，数据是以表的形式存储的，所以存储引擎简而言之就是指表的类型。数据库的存储引擎决定了表在计算机中的存储方式。</p><p>查看数据库支持的存储引擎可以用<code>SHOW ENGINES</code>语句，将会返回一个表格，其中Support列表示能否使用，YES代表可以使用，NO不行，DEFAULT表示当前默认默认使用的存储引擎。以下是5.7的展示结果：</p><table><thead><tr><th>Engine</th><th>Support</th><th>Comment</th><th>Transactions</th><th>XA</th><th>Savepoints</th></tr></thead><tbody><tr><td>InnoDB</td><td>DEFAULT</td><td>支持事务、行级锁定和外键</td><td>是</td><td>是</td><td>是</td></tr><tr><td>MRG_MYISAM</td><td>是</td><td>一组相同的MyISAM表</td><td>否</td><td>否</td><td>否</td></tr><tr><td>MEMORY</td><td>是</td><td>基于哈希存储在内存中，适用于临时表</td><td>否</td><td>否</td><td>否</td></tr><tr><td>BLACKHOLE</td><td>是</td><td>&#x2F;dev&#x2F;null存储引擎（向其中写入的任何内容都会消失）</td><td>否</td><td>否</td><td>否</td></tr><tr><td>MyISAM</td><td>是</td><td>MyISAM存储引擎</td><td>否</td><td>否</td><td>否</td></tr><tr><td>CSV</td><td>是</td><td>CSV存储引擎</td><td>否</td><td>否</td><td>否</td></tr><tr><td>ARCHIVE</td><td>是</td><td>归档存储引擎</td><td>否</td><td>否</td><td>否</td></tr><tr><td>PERFORMANCE_SCHEMA</td><td>是</td><td>性能模式</td><td>否</td><td>否</td><td>否</td></tr><tr><td>FEDERATED</td><td>否</td><td>分布式MySQL存储引擎</td><td>NULL</td><td>NULL</td><td>NULL</td></tr></tbody></table><p>以下是部分引擎特点：</p><ul><li>InnoDB：支持事务、行级锁定和外键，适合于处理高并发和复杂事务的应用。</li><li>MyISAM：不支持事务和行级锁定，但具有高速读取和插入数据的特性，适合于读多写少的应用。</li><li>MEMORY：将数据存储在内存中，适用于临时表和需要高速读写的应用。</li><li>CSV：将数据以逗号分隔的形式存储在文本文件中，适用于处理简单的数据集。</li><li>ARCHIVE：用于归档和压缩数据，适合于大量历史数据的存储和查询。</li></ul><h2 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h2><h3 id="什么是表"><a href="#什么是表" class="headerlink" title="什么是表"></a>什么是表</h3><p>表是数据库中最重要、最基本的操作对象，是存储数据的基本单位，<strong>一个表就是一个关系，表实质上就是行列的集合，每一行代表一条记录，每一列代表记录的一个字段。</strong></p><h3 id="表的命名"><a href="#表的命名" class="headerlink" title="表的命名"></a>表的命名</h3><p>完整的数据表名称应该有<strong>数据库名和表名两部分组成</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">databse_name.table_name<br></code></pre></td></tr></table></figure><p>同时要遵守MySQL对数据库和表的命名原则：</p><ol><li>名称可以有当前<strong>字符集</strong>中的任何字母、数据、字符组成</li><li>最长64个字符，但同时也受限于所用操作系统限定的长度</li><li>如果要用引号，<strong>必须使用单引号</strong>，单双引号并不禁止变量解释</li><li>文件系统的大小写敏感性影响到如何命名和引用数据表。比如UNIX，名称my_tbl和MY_TBL是两个不同的表。从开发环境转移到新系统运行时一定要注意。</li></ol><h3 id="表的结构"><a href="#表的结构" class="headerlink" title="表的结构"></a>表的结构</h3><p>数据表像表格一样拥有<strong>列（Column）</strong>和<strong>行（Row）</strong>。用数据库的专业术语表示<strong>列既是字段（Field），每个字段分别存储不同性质的数据，每一行中各个字段的数据构成一条数据记录（Record）</strong>。</p><p>结构（Structure）和数据记录是表的两大组成部分，表在存储数据记录之前，需要先定义结构，需要定义拥有哪些字段和这些字段的特性（字段名称、数据类型、长度等）</p><p>查看表结构可以用<code>DESC</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DESC</span> table_name;<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+-------+</span>--------------<span class="hljs-code">+------+</span>-----<span class="hljs-code">+---------+</span>-------+<br><span class="hljs-section">| Field | Type         | Null | Key | Default | Extra |</span><br><span class="hljs-section">+-------+--------------+------+-----+---------+-------+</span><br><span class="hljs-section">| NAME  | varchar(255) | YES  |     | NULL    |       |</span><br><span class="hljs-section">+-------+--------------+------+-----+---------+-------+</span><br></code></pre></td></tr></table></figure><h3 id="字段名"><a href="#字段名" class="headerlink" title="字段名"></a>字段名</h3><p>字段名相当于表格首行的表头，各个字段分别用来存储不同性质的数据，字段名同样必须符合MySQL命名格式</p><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p>使用<code>CREATE</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [TEMPORARY] <span class="hljs-keyword">TABLE</span> [ IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>] [库名.]表名 ( <br>  表的结构定义 <br>)[ 表选项 ]<br></code></pre></td></tr></table></figure><p>如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> mytable (<br>    id <span class="hljs-type">int</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">55</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>    age <span class="hljs-type">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>) ENGINE<span class="hljs-operator">=</span>InnoDB CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span> utf8mb4_general_ci;<br></code></pre></td></tr></table></figure><ul><li>id列是一个<code>INT</code>整数类型，<code>PRIMARY KEY</code>设置id列作为主键，并且使用<code>AUTO_INCREMENT</code>属性使其自动递增。</li><li>name列是一个<code>VARCHAR</code>可变长度的字符串类型，最大长度为55个字符，并且设置了<code>DEFAULT NULL</code>属性，表示该列默认为空（可以为空）。</li><li>age列是一个<code>INT</code>整数类型，<code>NOT NULL</code>不允许为空。</li><li><code>ENGINE</code>设置存储引擎，<code>CHARSET</code>设置字符集，<code>COLLATE</code>设置排序方法</li></ul><p>如果库名带有小数点或者是数据库关键字，则需要将库名用”&#96;”括起来，注意这不是单引号是反引号，键盘左上角那玩意。比如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `sql.TEST`;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> sql.TEST;<br></code></pre></td></tr></table></figure><p>是两个不同的意思，第一个表示在当前使用的库下创建名为sql.test的表，第二个表示，在名为sql的数据库里面创建一个名为test的表，如果是关键字，不适用反引号则会报错。</p><h3 id="删除和清空表"><a href="#删除和清空表" class="headerlink" title="删除和清空表"></a>删除和清空表</h3><p>删除表用<code>DROP</code>,清空用的是<code>TRUNCATE</code>,只会清空表的数据，但是结构还在。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> [IF <span class="hljs-keyword">EXISTS</span>] table_name;<br><span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> table_name;<br></code></pre></td></tr></table></figure><p>使用<code>DELETE</code>也可以删除数据，可以清楚指定行，这三者的区别是：</p><ol><li><p>delete 和 truncate 仅仅删除表数据，drop 连表数据和表结构一起删除，打个比方，delete 是单杀，truncate 是团灭，drop 是把电脑摔了。</p></li><li><p>delete 是 DML 语句，操作完以后如果没有不想提交事务还可以回滚，truncate 和 drop 是 DDL 语句，操作完马上生效，不能回滚，打个比方，delete 是发微信说分手，后悔还可以撤回，truncate 和 drop 是直接扇耳光说滚，不能反悔。</p></li><li><p>执行的速度上，<strong>drop&gt;truncate&gt;delete</strong>，把库比作抽屉，drop是直接把抽屉丢了（1步），truncate是把里面的东西倒出来然后安回去（2步），delete是在抽屉里找到我要丢的，单独丢掉，然后把抽屉放回去（3步）。</p></li></ol><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>使用<code>INSERT INTO</code>语句来插入数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">INSERT INTO table_name (column1, column2, column3, ...)<br>VALUES (value1, value2, value3, ...);<br></code></pre></td></tr></table></figure><p>如果值是字符串类型，则需要用单引号或双引号括起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO mytable (id, name, age) VALUES (1, &#x27;xiaoming&#x27;, 20);<br></code></pre></td></tr></table></figure><p>插入新行</p><table><thead><tr><th>id</th><th>name</th><th>age</th></tr></thead><tbody><tr><td>1</td><td>xiaoming</td><td>20</td></tr></tbody></table><p>如果要插入多行，可以指定多组VALUES，用逗号分隔</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO mytable (id, name, age)<br>VALUES<br>(4, &#x27;xiaohong&#x27;, 21),<br>(5, &#x27;tom&#x27;, 20);<br></code></pre></td></tr></table></figure><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><p>查询数据用<code>SELECT</code>语句查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT column1, column2, colunm3 <br>FROM table_name<br>[WHERE condition]<br>[ORDER BY column_name [ASC | DESC]]<br>[LIMIT number];<br></code></pre></td></tr></table></figure><ul><li><code>WHERE condition</code> 是一个可选的子句，用于指定过滤条件，只返回符合条件的行。</li><li><code>ORDER BY column_name [ASC | DESC]</code> 是一个可选的子句，用于指定结果集的排序顺序，默认是升序（ASC）。</li><li><code>LIMIT number</code> 是一个可选的子句，用于限制返回的行数。</li></ul><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#返回所有数据<br>SELECT * FROM mytable;<br><br>#返回特定字段<br>SELECT id,name FROM mytable;<br><br>#WHERE语句，返回满足设定条件的行<br>#以下表示返回age字段等于20的行<br>SELECT * FROM mytable WHERE age = 20;<br><br>#ORDER BY 语句，默认表示按照某列的升序排序，ASC表示升序可以省略<br>SELECT * FROM mytable ORDER BY age;<br><br>#ORDER BY 语句设置DESC，表示按照某列的降序排序<br>SELECT * FROM mytable ORDER BY id DESC;<br><br>#LIMIT 语句，限制返回的行数<br>SELECT * FROM mytable LIMIT 2;<br></code></pre></td></tr></table></figure><p><code>WHERE</code>语句还支持各种运算符，比较运算符、逻辑运算符（NOT AND OR）、通配符等都能使用。</p><p>如果要使用通配符，需要用到<code>LIKE</code>，如果用了<code>LIKE</code>但没用通配符，那么他的效果和<code>=</code>是一样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">#通配符%，表示0个或多个字符，返回name字段带有xiao前缀的行<br>SELECT * FROM mytable WHERE  name LIKE &#x27;xiao%&#x27;;<br><br>#通配符_，表示一个字符，返回name字段第二个字母为x的行<br>SELECT * FROM mytable WHERE name LIKE &#x27;_x%&#x27;;<br><br>#不区分大小写匹配<br>SELECT * FROM mytable WHERE name LIKE &#x27;x%&#x27; COLLATE utf8mb4_general_ci;<br></code></pre></td></tr></table></figure><p><code>WHERE</code>还有个<code>IN</code>和<code>NOT IN</code>条件，可以筛选与指定数据相等的行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">#返回age字段是11或20的<br>SELECT * FROM mytable WHERE age IN (11, 20);<br><br>#取上面的补集<br>SELECT * FROM mytable WHERE age NOT IN (11, 20);<br></code></pre></td></tr></table></figure><p><code>WHERE</code>还有<code>BETWEEN、NOT BETWEEN、IS NULL 、IS NOT NULL</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#BETWEEN，筛选属于给定区间的数据，可以是时间、数字、文本<br>#两边都是闭区间，即包含两边<br>SELECT * FROM mytable WHERE id BETWEEN 1 AND 5;<br><br>#如果需要取补集可以用NOT BETWEEN<br></code></pre></td></tr></table></figure><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p><code>UPDATE</code>用来更新数据，语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE table_name<br>SET column1=value1,column1=value2...<br>WHERE condition;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 更新多个列<br>  UPDATE mytable<br>  SET age=20,name=&#x27;lihua&#x27;<br>  WHERE id=1;<br><br># 使用表达式更新<br>UPDATE mytable<br>SET age=age+1;<br><br># 使用子查询的值<br>UPDATE mytable<br>  SET name = (<br>  SELECT name FROM 座位表<br>  WHERE 座位表.id = mytable.id<br>  LIMIT 1<br>  );<br></code></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>删除数据用<code>DELETE</code>语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM table_name<br>WHERE condition;<br></code></pre></td></tr></table></figure><p>如果没有指定条件，则所有记录都会被删除。</p><h3 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h3><p>使用<code>ALTER</code>可以修改表的结构，重命名，添加删除字段等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE [表名] &#123;MODIFY | RENAME | ADD | DROP&#125;<br></code></pre></td></tr></table></figure><ul><li><p>修改字段类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE [表名] MODIFY COLUMN  [字段名] [新类型]<br></code></pre></td></tr></table></figure><p>比如修改name字段为varchar200类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE table_name MODIFY COLUMN name VARCHAR(200);<br></code></pre></td></tr></table></figure></li><li><p>重命名字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE [表名] RENAME COLUMN  [字段名] [新字段名];<br></code></pre></td></tr></table></figure></li></ul><h3 id="UNION操作符"><a href="#UNION操作符" class="headerlink" title="UNION操作符"></a>UNION操作符</h3><p>用于连接两个及以上的SELECT语句的结果组合到一个集合并去除重复。语法格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT column1, column2, ...<br>FROM table1<br>WHERE condition1<br>UNION<br>SELECT column1, column2, ...<br>FROM table2<br>WHERE condition2<br>[ORDER BY column1, column2...]<br></code></pre></td></tr></table></figure><p><code>ORDER BY</code> 子句是一个可选的子句，用于指定合并后的结果集的排序顺序。</p><p><strong>每个 SELECT 语句的列数和对应位置的数据类型必须相同,如果数量不等可以用NULL补位</strong></p><p>使用<code>UNION</code>的时候会自动去除重复行，如果不想去除，可以用<code>UNION ALL</code></p><h3 id="ORDER-BY排序"><a href="#ORDER-BY排序" class="headerlink" title="ORDER BY排序"></a>ORDER BY排序</h3><p>在使用<code>SELECT</code>时，可以对获取的数据进行排序，<code>ORDER BY</code>可以设定指定一个或多个字段以哪种方式进行排序，并支持<code>ASC</code>升序或<code>DESC</code>降序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT column1, column2...<br>FROM mytable<br>ORDER BY column1 [ASC|DESC],column2[ASC|DESC],...;<br></code></pre></td></tr></table></figure><p>当有指定了多个字段时，会按照书写顺序依次排序，比如上诉代码中，会先以column1为依据排序，如果有column1相同的行，则会继续以column2进行排序。</p><p>除了使用字段外，还可以用<strong>表达式进行排序</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT product_name, price * discount_rate AS discounted_price<br>FROM products<br>ORDER BY discounted_price DESC;<br></code></pre></td></tr></table></figure><p>以上 SQL 语句将选择产品表 products 中的产品名称和根据折扣率计算的折扣后价格，并按折扣后价格降序 DESC 排序</p><p>在SQL中，如果需要把指定的字段中出现了<strong>NULL值</strong>可以用<code>NULLS FIRST</code>或<code>NULLS LAST</code>设置NULL值的排序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> product_name, price<br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> price <span class="hljs-keyword">DESC</span> NULLS <span class="hljs-keyword">LAST</span>;<br></code></pre></td></tr></table></figure><p>而在mysql中，NULL值默认为最小，即升序最前，降序最后，如果想改变，由于MySQL并没有NULLS语法，所以需要使用<code>CASE</code>或<code>IS</code>实现相同的效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT name<br>FROM mytable<br>ORDER BY CASE WHEN name IS NULL THEN 1 ELSE 0 END, name DESC;<br></code></pre></td></tr></table></figure><p>上述代码表示如果name是NULL值则返回1，否则返回0，数据库会先根据这个返回值进行排序，而默认是升序排序，所以1也就是<code>name IS NULL</code>，会被置底，接着其他name则会按照<code>DESC</code>降序排序.如果想让NULL置顶，可以更改01的位置，或者在<code>END</code>后添加<code>DESC</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT name<br>FROM mytable<br>ORDER BY name IS NULL DESC, name DESC;<br></code></pre></td></tr></table></figure><p>上述代码表示，先根据（name IS NULL）的值（1&#x2F;0）进行排序，然后再根据name进行排序，上面的代码会将null值置顶，其余的name按照降序排序。和用case方法类似。不过这种方法在不同的数据库中得到了不同的效果，建议手动尝试下。</p><h3 id="GROUP-分组"><a href="#GROUP-分组" class="headerlink" title="GROUP 分组"></a>GROUP 分组</h3><p><code>GROUP BY</code>可以根据一个或多个字段进行分组，还可以使用<code>COUNT,SUM,AVG</code>等函数。语法格式:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, aggregate_function(column2)<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> column1;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 按名字分组，查看班里重名的人数<br>SELECT name ,COUNT(*) FROM 座位表 GROUP BY name;<br></code></pre></td></tr></table></figure><p>使用<code>WITH ROLLUP</code>可以在实现分组统计基础上再进行统计（<code>SUM, AVG, COUNT...</code>）</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序学习</title>
    <link href="/2024/01/10/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/01/10/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="基础配置与介绍"><a href="#基础配置与介绍" class="headerlink" title="基础配置与介绍"></a>基础配置与介绍</h1><h2 id="注册开发者账号"><a href="#注册开发者账号" class="headerlink" title="注册开发者账号"></a>注册开发者账号</h2><p>在<a href="mp.weixin.qq.com">微信公众平台</a>中，点击”立即注册“，账号类型选择”小程序“。完成后登录即可。</p><p>接着在”设置“-”开发设置“中查看AppID。每个小程序账号只有一个AppID，每个账号只能开发一个小程序，如果需要发布多个，则需要注册多个账号。</p><h2 id="安装微信开发者工具"><a href="#安装微信开发者工具" class="headerlink" title="安装微信开发者工具"></a>安装微信开发者工具</h2><p>在微信公众平台上可以找到下载地址，下载安装即可。</p><h2 id="开发者工具部分功能介绍"><a href="#开发者工具部分功能介绍" class="headerlink" title="开发者工具部分功能介绍"></a>开发者工具部分功能介绍</h2><h3 id="模拟器"><a href="#模拟器" class="headerlink" title="模拟器"></a>模拟器</h3><p>用于模拟手机环境，查看不同型号手机的运行效果。</p><h3 id="调试器"><a href="#调试器" class="headerlink" title="调试器"></a>调试器</h3><ul><li>console:控制台</li><li>sources: 源代码</li><li>newwork：网络，用于记录网络请求信息，根据它可进行网络性能优化</li><li>security：安全，用于调试页面的安全和认证等信息，如https</li><li>appdata：app数据，可以查看或编辑当前小程序运行时的数据</li><li>audites：审计，用于对小程序进行体验评分</li><li>sensor：传感器，用于模拟地理位置、重力感应</li><li>storage：存储，用于查看和管理本地数据缓存</li><li>trace：跟踪，用于真机调试时跟踪调试信息</li><li>wxml：用于查看和体哦啊是wxml和wxss</li></ul><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><table><thead><tr><th>路径</th><th>说明</th></tr></thead><tbody><tr><td>project.config.json</td><td>项目配置文件</td></tr><tr><td>app.js</td><td>应用程序的逻辑文件</td></tr><tr><td>app.json</td><td>应用程序的配置文件</td></tr><tr><td>app.wxss</td><td>应用程序的公共样式文件</td></tr><tr><td>pages&#x2F;</td><td>存放页面文件的目录</td></tr><tr><td>pages&#x2F;index&#x2F;</td><td>存放index页面的目录</td></tr><tr><td>pages&#x2F;index&#x2F;index.js</td><td>index页面的逻辑文件</td></tr><tr><td>pages&#x2F;index&#x2F;index.wxml</td><td>index页面的结构文件</td></tr><tr><td>pages&#x2F;index&#x2F;index.wxss</td><td>index页面的样式文件</td></tr><tr><td>pages&#x2F;logs&#x2F;</td><td>存放logs 页面的目录</td></tr><tr><td>pages&#x2F;logs&#x2F;logs.js</td><td>logs页面的逻辑文件</td></tr><tr><td>pages&#x2F;logs&#x2F;logs.json</td><td>logs页面的配置文件</td></tr><tr><td>pages&#x2F;logs&#x2F;logs.wxml</td><td>logs 页面的结构文件</td></tr><tr><td>pages&#x2F;logs&#x2F;logs.wxss</td><td>logs页面的样式文件</td></tr><tr><td>utils&#x2F;</td><td>存放公共脚本文件的目录</td></tr><tr><td>utils&#x2F;utils.js</td><td>公共脚本文件，保存一些工具代码</td></tr></tbody></table><h1 id="开发基础"><a href="#开发基础" class="headerlink" title="开发基础"></a>开发基础</h1><h2 id="新增页面"><a href="#新增页面" class="headerlink" title="新增页面"></a>新增页面</h2><p>新增页面需要创建<code>app.json</code>，并在该文件中编写</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;pages&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;pages/index/index&quot;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>保存之后，开发者工具就会<strong>自动生成index.js、index.json、index.wxml、index.wxss四个文件</strong></p><h2 id="页面组件"><a href="#页面组件" class="headerlink" title="页面组件"></a>页面组件</h2><p>小程序使用<strong>WXML（WeiXin Markup Language）</strong>来实现页面的结构（类似HTML），比如其中的<code>&lt;view&gt;</code>相当于HTML的<code>div</code>，常用的有</p><table><thead><tr><th>标签</th><th>功能</th></tr></thead><tbody><tr><td>view</td><td>视图容器</td></tr><tr><td>text</td><td>文本域</td></tr><tr><td>button</td><td>按钮</td></tr><tr><td>image</td><td>图片</td></tr><tr><td>form</td><td>表单</td></tr><tr><td>icon</td><td>图标文件</td></tr><tr><td>checkbox</td><td>复选框</td></tr><tr><td>radio</td><td>单选框</td></tr><tr><td>input</td><td>输入框</td></tr><tr><td>progress</td><td>进度条</td></tr></tbody></table><p>书写方式和HTML类似</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">text</span>&gt;</span>输入数字<span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>input</code>标签会根据<code>type</code>的不同而弹出不同的键盘，方便用户输入，它支持以下类型</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>text</td><td>文本输入键盘（默认）</td></tr><tr><td>number</td><td>数字输入键盘（不带小数点）</td></tr><tr><td>idcard</td><td>身份证输入键盘（0-9和X）</td></tr><tr><td>digit</td><td>带小数点的数字键盘</td></tr></tbody></table><p>之后点击编译，就可以看到运行状况了，而如果想要看见弹出的键盘，可以使用<strong>真机调试</strong>，用手机扫码之后就可以在手机山操作了，而且电脑同时还可以进行调试。</p><h2 id="页面样式"><a href="#页面样式" class="headerlink" title="页面样式"></a>页面样式</h2><p><strong>WXSS（WeiXin Style Sheets）</strong>用于描述WXML的组件样式，它具有CSS大部分特性，并做了一些扩展和修改。</p><ol><li><p><strong>选择器</strong></p><p>WXSS选择器和CSS用法基本相同</p></li><li><p><strong>尺寸单位</strong></p><p>在使用CSS做移动端网页开发的时候，为了适配不同屏幕需要对像素单位进行换算，而WXSS为了简化这一流程，加入了新得尺寸<strong>rpx</strong></p><p>rpx单位规定任何手机屏幕得宽度都为**750rpx(逻辑像素)**，所以设计图需要按照750px的宽度进行绘制，然后在小程序中使用rpx，不再需要担心宽度问题了。下表是rpx在不同设备中与px的换算关系</p><table><thead><tr><th>设备</th><th>屏幕宽度(px)</th><th>rpx换算px(屏幕宽度&#x2F;750)</th><th>px换算rpx（750&#x2F;屏幕宽度）</th></tr></thead><tbody><tr><td>iPhone 5</td><td>320</td><td>1rpx 约等于 0.42px</td><td>1px 约等于 2.34rpx</td></tr><tr><td>iPhone 6</td><td>375</td><td>1rpx &#x3D; 0.5px</td><td>1px &#x3D; 2rpx</td></tr><tr><td>iPhone 6 plus</td><td>414</td><td>1rpx &#x3D; 0.552rpx</td><td>1px 约等于 1.81rpx</td></tr></tbody></table></li><li><p><strong>样式导入</strong></p><p>在WXSS中可以使用<code>@import</code>导入外部样式表（和less有点像），语法如下</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;index.wxss&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>全局样式</strong></p><p>如果多个页面经常有通用的样式，可以在项目根目录下创建全局样式<strong>app.wxss</strong>，当页面样式和全局样式发生冲突时，页面样式的优先级更高</p></li></ol><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>每个页面均可以使用<strong>json文件</strong>对页面的效果进行配置，页面配置分为<strong>页面级</strong>和<strong>应用级</strong>，<strong>app.json</strong>是<strong>应用级配置文件</strong></p><ol><li><p><em>页面级配置文件</em></p><p>可以用来配置更改页面的导航样式，控制页面是否允许上下移动等，下面是常用的配置</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>navigationBarBackgroundColor</td><td>导航栏背景颜色，默认#000</td></tr><tr><td>navgationBarTextStyle</td><td>导航栏标题文字内容</td></tr><tr><td>navgationBarTitleStyle</td><td>导航栏标题颜色，仅支持block、white（默认）</td></tr><tr><td>backgroundColor</td><td>窗口的背景颜色，默认#fff</td></tr><tr><td>backgroundTextStyle</td><td>下拉loading的样式，仅支持dark（默认）、light</td></tr><tr><td>enablePullDownRefresh</td><td>是否开启全局下拉刷新，默认false</td></tr><tr><td>onReachBottomDisatance</td><td>页面上拉触底事件时距页面底部距离（单位px），默认50</td></tr><tr><td>disableScroll</td><td>默认false，设为true时，页面不能上下滚动</td></tr></tbody></table><p>当页面非常长时，为了加快加载速度，会先加载一部分，当用户快到底部时，立即加载后面的内容，而onReachBottomDistance值越大，加载的时机就越提前，当到达了给定的值，就会触发上拉触底事件，onReachBottom，在对应的js文件下，可以找到该事件的处理函数。</p></li><li><p><em>应用级配置文件</em></p><p>项目根目录下的<strong>app.json</strong>就是应用级配置文件，常用配置如下</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>pages</td><td>页面的路径</td></tr><tr><td>window</td><td>全局的默认窗口表现</td></tr><tr><td>tabBar</td><td>底部tab栏的表现</td></tr><tr><td>networkTimeout</td><td>网络超时时间</td></tr><tr><td>debug</td><td>是否开启调试模式，默认为false</td></tr><tr><td>requireBackgroundModes</td><td>需要在后台使用的能力，如音乐播放等</td></tr><tr><td>plugins</td><td>使用到的插件</td></tr></tbody></table><p>window的值是一个对象，可以将上面说过的页面级配置写在window中，作为应用级配置使用，从而设置多个页面。</p><p>newworkTimeout可以设置网络请求过程中的超时时间</p><table><thead><tr><th>属性</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>request</td><td>Number</td><td>wx.request()的超时时间(ms)，默认60000</td></tr><tr><td>connectSocket</td><td>Number</td><td>wx.connectSocket()的超时时间(ms)，默认60000</td></tr><tr><td>uploadFile</td><td>Number</td><td>wx.uoloadFile()的超时时间(ms)，默认60000</td></tr><tr><td>downloadFile</td><td>Number</td><td>wx.downloadFile()的超时时间(ms)，默认60000</td></tr></tbody></table></li></ol><h2 id="页面逻辑"><a href="#页面逻辑" class="headerlink" title="页面逻辑"></a>页面逻辑</h2><p>js文件用于编写页面逻辑，打开文件可以看到自带的一些代码，这些是开发者工具自动生成的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// pages/test/test.js</span><br><span class="hljs-title class_">Page</span>(&#123;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 页面的初始数据</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">data</span>: &#123;<br><br>  &#125;,<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 生命周期函数--监听页面加载</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">onLoad</span>(<span class="hljs-params">options</span>) &#123;<br><br>  &#125;,<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 生命周期函数--监听页面初次渲染完成</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">onReady</span>(<span class="hljs-params"></span>) &#123;<br><br>  &#125;,<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 生命周期函数--监听页面显示</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">onShow</span>(<span class="hljs-params"></span>) &#123;<br><br>  &#125;,<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 生命周期函数--监听页面隐藏</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">onHide</span>(<span class="hljs-params"></span>) &#123;<br><br>  &#125;,<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 生命周期函数--监听页面卸载</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">onUnload</span>(<span class="hljs-params"></span>) &#123;<br><br>  &#125;,<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 页面相关事件处理函数--监听用户下拉动作</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">onPullDownRefresh</span>(<span class="hljs-params"></span>) &#123;<br><br>  &#125;,<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 页面上拉触底事件的处理函数</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">onReachBottom</span>(<span class="hljs-params"></span>) &#123;<br><br>  &#125;,<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 用户点击右上角分享</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-title function_">onShareAppMessage</span>(<span class="hljs-params"></span>) &#123;<br><br>  &#125;<br><br><br>&#125;)<br></code></pre></td></tr></table></figure><p>在上述代码中，<code>Page()</code>函数用于注册一个页面，该函数的参数是一个对象，通过该对象可以指定页面的初始数据、生命周期函数、事件处理函数等（有点像vue）</p><table><thead><tr><th>属性</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>data</td><td>Object</td><td>页面的初始数据</td></tr><tr><td>onLoad</td><td>Function</td><td>生命周期回调函数，监听页面加载</td></tr><tr><td>onReady</td><td>Function</td><td>生命周期回调函数，监听页面初次渲染完成</td></tr><tr><td>onShow</td><td>Function</td><td>生命周期回调函数,监听页面显示</td></tr><tr><td>onHide</td><td>Function</td><td>生命周期回调函数，监听页面隐藏</td></tr><tr><td>onUnload</td><td>Function</td><td>生命周期回调函数，监听页面卸载</td></tr><tr><td>onPullDownRefresh</td><td>Function</td><td>页面事件处理函数，监听用户下拉动作</td></tr><tr><td>onReachBottom</td><td>Function</td><td>页面事件处理函数，页面上拉触底</td></tr><tr><td>onShareAppMessage</td><td>Function</td><td>页面事件处理函数，用户单机右上角分享按钮</td></tr><tr><td>onPageScroll</td><td>无法解析符号 ‘key’</td><td>页面事件处理函数，页面滚动会连续触发</td></tr><tr><td>其他</td><td>Any</td><td>开发者可以添加任意的函数或数据，在页面的函数中可以通过this.*来访问</td></tr></tbody></table><ol><li><p><strong>生命周期函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">onload</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">options</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;页面加载&#x27;</span>)<br>&#125;<br><span class="hljs-attr">onReady</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;页面初次渲染完成&#x27;</span>)<br>&#125;<br><span class="hljs-attr">onShow</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;页面显示&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>*onLoad:*页面加载时触发。一个页面只会调用一次，通过参数options，可以获取打开当前页面路径中的参数</li><li>*onReady:*页面初次渲染完成时调用。一个页面只会调用一次，代表页面已经准备妥当，此时可以与视图层进行交互</li><li>*onShow:*当页面显示时触发，如：从后台切入前台时触发</li><li>*onHide:*当页面隐藏时触发，如：从前台切入到后台时触发</li><li>*onUnload:*页面卸载时触发。例如使用路由API中的wx.redirectTo()或wx.navigateBack()跳转其他页面时。</li></ul></li><li><p><strong>页面事件处理函数</strong></p><p>以onPullDownRefresh、onReachBottom、onPageScroll为例演示。其中onPullDownRefresh需要在配置文件中将enablePullDownRefresh设为true才有效。而onPageScroll不会自动生成，需要自己写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">onPullDownRefresh</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;此时用户下拉触底&#x27;</span>)<br>&#125;,<br><span class="hljs-attr">onReachBottom</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;此时用户上拉触底&#x27;</span>)<br>&#125;,<br><span class="hljs-attr">onPageScroll</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">options</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;此时用户正在滚动页面&#x27;</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;滚动距离：&#x27;</span> + options.<span class="hljs-property">scrollTop</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>组件事件处理函数</strong></p><p><strong>组件事件处理函数用于为组件绑定事件</strong>，如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">bindtap</span>=<span class="hljs-string">&quot;compare&quot;</span>&gt;</span>比较<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>bindtap</code>表示绑定tap点击事件，事件处理函数为<code>compare</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">compare</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;比较按钮被点击了&#x27;</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e)<br>&#125;<br></code></pre></td></tr></table></figure><p>其中参数表示<strong>事件对象</strong>，输出结果为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;type: <span class="hljs-string">&quot;tap&quot;</span>, timeStamp: <span class="hljs-number">320371</span>, target: &#123;…&#125;, currentTarget: &#123;…&#125;, <span class="hljs-selector-tag">mark</span>: &#123;…&#125;, …&#125;<br></code></pre></td></tr></table></figure><p>通过事件对象可以获取<strong>type（事件类型）、timestamp（事件生成时的时间戳）、target（触发事件的组件中一些属性集合）、currenTarget（当前组件的一些属性值集合）、detail（额外的信息）等信息</strong></p><p>下面是一些细节</p><ol><li><p><em><code>e.target</code>和<code>e.currentTarget</code>的区别</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;outer&quot;</span> <span class="hljs-attr">bind:tap</span>=<span class="hljs-string">&quot;viewTap&quot;</span>&gt;</span><br>  outer<br>  <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;inner&quot;</span>&gt;</span><br>    inner<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">viewTap</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">id</span> + <span class="hljs-string">&#x27;-&#x27;</span> + e.<span class="hljs-property">currentTarget</span>.<span class="hljs-property">id</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>由于inner在outer中，所以我们点击outer或inner都能触发viewTap事件，当我们点击outer会出现”outer-outer“，点击inner会出现”inner-outer”，由此可见，<strong>target获取到的是子元素的属性值集合（当前元素？），currentTarget是父元素的属性值集合</strong></p></li><li><p><em>常用冒泡事件</em></p><table><thead><tr><th>事件类型</th><th>触发条件</th></tr></thead><tbody><tr><td>touchstart</td><td>手指触摸动作开始</td></tr><tr><td>touchmove</td><td>手指触摸后移动</td></tr><tr><td>touchcancel</td><td>手指触摸动作被打断，如来电提醒、弹窗</td></tr><tr><td>touchend</td><td>手指触摸动作结束</td></tr><tr><td>tap</td><td>手指触摸后马上离开</td></tr><tr><td>longpress</td><td>手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发这个事件，tap事件将不被触发</td></tr></tbody></table><p>上述都属于冒泡事件，<strong>冒泡事件是指当一个组件上的事件被触发后，事件会向父节点传递，而非冒泡事件则不会向父节点传递。</strong>另外，一些组件还拥有一些专门的事件，如：form的submit事件。</p></li><li><p><em>事件绑定和冒泡</em></p><p>组件绑定事件有<strong>bind事件类型</strong>和<strong>catch事件类型</strong>，<strong>bind不会阻止冒泡事件向上冒泡，而catch可以阻止事件向上冒泡</strong></p></li></ol></li></ol><h2 id="注册程序"><a href="#注册程序" class="headerlink" title="注册程序"></a>注册程序</h2><p>若要在小程序<strong>启动、显示、隐藏时执行某些操作</strong>，可以通过App（）函数来实现。它用于注册小程序，接收一个对象参数，通过参数指定小程序的生命周期回调等。<strong>App（）函数必须在app.js中调用，且只能调用一次</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">App</span>( &#123;<br>    <span class="hljs-comment">//生命周期回调——监听小程序初始化</span><br>    <span class="hljs-comment">//小程序初始化完成时触发（全局只触发一次）</span><br>    <span class="hljs-attr">onLauch</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;onLauch执行&#x27;</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(options)<br>    &#125;,<br>    <span class="hljs-comment">//生命周期回调——监听小程序显示</span><br>    <span class="hljs-comment">//小程序启动，或从后台进入前台时显示</span><br>    <span class="hljs-attr">onShow</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;onShow执行&#x27;</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;options&#x27;</span>)<br>    &#125;,<br>    <span class="hljs-comment">//生命周期回调——监听小程序隐藏</span><br>    <span class="hljs-comment">//从前台进入后台时触发</span><br>    <span class="hljs-attr">onHide</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;onHide执行&#x27;</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(options)<br>    &#125;,<br>    <span class="hljs-comment">//错误监听函数</span><br>    <span class="hljs-comment">//小程序发生脚本错误，或API调用失败时触发</span><br>    <span class="hljs-attr">onError</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<br>        consle.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;onError执行&#x27;</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error)<br>    &#125;,<br>    <span class="hljs-comment">//页面不存在 监听函数</span><br>    <span class="hljs-comment">//小程序要打开的页面不存在时触发</span><br>    <span class="hljs-attr">onPageNotFound</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;onPageNotFound&#x27;</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(options)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>其中options会输出类似以下内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml">&#123;<span class="hljs-attr">path:</span> <span class="hljs-string">&quot;pages/index/index&quot;</span>, <span class="hljs-attr">query:</span> &#123;<span class="hljs-string">…</span>&#125;, <span class="hljs-attr">scene:</span> <span class="hljs-number">1001</span>, <span class="hljs-attr">shareTicket:</span> <span class="hljs-string">undefined</span>, <span class="hljs-attr">referrerInfo:</span> &#123;<span class="hljs-string">…</span>&#125;, <span class="hljs-string">…</span>&#125;<br></code></pre></td></tr></table></figure><ul><li>path:打开小程序的路径，一般时app.json中设置的第一个页面，也可以通过自定义编译条件指定启动页面</li><li>query：打开小程序的query，一般是空对象，也可以通过自定义编译条件指定启动参数</li><li>scene：打开小程序的场景值，一般时1001，也可以通过自定义编译条件指定进入场景</li><li>shaareTicket：当小程序被转发出去时，如果此转发卡片被其他用户打开，可以获取到shareTicket（如群的标识）。通常搭配wx.showShareMenu()使用，并且需要在该方法的参数对象中设置withShareTicket为true</li><li>referrerInfo：当场景从另一个小程序、公众号或APP打开时，可以通过它获取来源于小程序、公众号的AppId等，scene为1037时支持传递附加数据</li></ul><p>同时，App（）函数还可以保存一些在所有页面共享的数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">App</span>(&#123;<br>    <span class="hljs-attr">num</span>: <span class="hljs-number">123</span>,<br>    <span class="hljs-attr">test</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;test&#x27;</span>)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>然后在页面的js文件（比如index.js）的onReady中编写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">onReady</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> app = <span class="hljs-title function_">getApp</span>()<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(app.<span class="hljs-property">num</span>)<br>    app.<span class="hljs-title function_">test</span>()<br>&#125;,<br></code></pre></td></tr></table></figure><h2 id="绑定变量"><a href="#绑定变量" class="headerlink" title="绑定变量"></a>绑定变量</h2><p>可以通过<code>&#123;&#123;&#125;&#125;</code>在对应位置绑定一个变量或表达式，比如<code>&#123;&#123;msg&#125;&#125;</code>绑定了msg，会将js文件中<code>data:&#123;&#125;</code>中定义的msg显示出来。</p><p>修改msg的值有两种方式，通过<code>this.data.msg = </code>重新赋值或<code>this.data.setData()</code>。两者的区别是，<strong>赋值不会刷新页面</strong>，msg修改之后页面依然显示原来的值，而通过<code>setData()</code>则可以。</p><p>setData（）的参数是一个对象，输入<code>this.data.setData(&#123; msg: 1 &#125;)</code>，表示将msg的值修改为1。</p><h2 id="表单数据绑定"><a href="#表单数据绑定" class="headerlink" title="表单数据绑定"></a>表单数据绑定</h2><p>下面是一个表单绑定的例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">bindsubmit</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">text</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&#123;&#123;name&#125;&#125;&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">text</span>&gt;</span>性别<span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">radio-group</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;&#123;&#123;gender&#125;&#125;&quot;</span> <span class="hljs-attr">wx:key</span>=<span class="hljs-string">&quot;value&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">radio</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&#123;&#123;item.value&#125;&#125;&quot;</span> <span class="hljs-attr">checked</span>=<span class="hljs-string">&quot;&#123;&#123;item.checked&#125;&#125;&quot;</span> /&gt;</span><br>        &#123;&#123;item.name&#125;&#125;<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">radio-group</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">checkbox-group</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;skills&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">text</span>&gt;</span>技能：<span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;&#123;&#123;skills&#125;&#125;&quot;</span> <span class="hljs-attr">wx:key</span>=<span class="hljs-string">&quot;value&quot;</span> &gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">checkbox</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&#123;&#123;item.value&#125;&#125;&quot;</span> <span class="hljs-attr">checked</span>=<span class="hljs-string">&quot;&#123;&#123;item.checked&#125;&#125;&quot;</span>/&gt;</span><br>        &#123;&#123;item.name&#125;&#125;<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">checkbox-group</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">form-type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">num1</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">num2</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">msg</span>: <span class="hljs-number">12</span> ,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>    <span class="hljs-attr">gender</span>: [<br>        &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-attr">checked</span>: <span class="hljs-literal">true</span>&#125;,<br>        &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-attr">checked</span>: <span class="hljs-literal">false</span>&#125;<br>    ],<br>    <span class="hljs-attr">skills</span>: [<br>      &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;CSS&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;CSS&#x27;</span>, <span class="hljs-attr">checked</span>: <span class="hljs-literal">true</span>&#125;,<br>      &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;HTML&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;HTML&#x27;</span>, <span class="hljs-attr">checked</span>: <span class="hljs-literal">true</span>&#125;,<br>      &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;VUE&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;VUE&#x27;</span>, <span class="hljs-attr">checked</span>: <span class="hljs-literal">false</span>&#125;,<br>      &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;JS&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;JS&#x27;</span>, <span class="hljs-attr">checked</span>: <span class="hljs-literal">false</span>&#125;,<br>    ]<br>  &#125;,<br><span class="hljs-attr">submit</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">detail</span>.<span class="hljs-property">value</span>)<br>    wx.<span class="hljs-title function_">request</span>(&#123;<br>      <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br>      <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://127.0.0.1:3000/&#x27;</span>,<br>      <span class="hljs-attr">data</span>: e.<span class="hljs-property">detail</span>.<span class="hljs-property">value</span>,<br>      <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">data</span>)<br>      &#125;,<br>      <span class="hljs-attr">fail</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>      &#125;<br>    &#125;)<br>&#125;      <br><br></code></pre></td></tr></table></figure><h2 id="nodejs搭建本地服务器与发送请求"><a href="#nodejs搭建本地服务器与发送请求" class="headerlink" title="nodejs搭建本地服务器与发送请求"></a>nodejs搭建本地服务器与发送请求</h2><ol><li><p>初始化项目，并自动创建package.json配置文件</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> init -y<br></code></pre></td></tr></table></figure></li><li><p>安装Express框架，用于快速搭建HTTP服务器</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">npm install <span class="hljs-built_in">express</span> --<span class="hljs-built_in">save</span><br></code></pre></td></tr></table></figure></li><li><p>安装nodemon监控文件修改</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> nodemon -g<br></code></pre></td></tr></table></figure><p>之后，在目录下创建index.js，代码编写如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> bodyParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;body-parser&#x27;</span>)<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br>app.<span class="hljs-title function_">use</span>(bodyParser.<span class="hljs-title function_">json</span>())<br><span class="hljs-comment">//处理POST请求</span><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req,res</span>) =&gt;</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">body</span>)<br>res.<span class="hljs-title function_">json</span>(req.<span class="hljs-property">body</span>)<br>&#125;)<br><span class="hljs-comment">//监听端口</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;sercer running at http://127.0.0.1:3000&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>启动服务器</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">nodemon <span class="hljs-keyword">index</span>.js<br></code></pre></td></tr></table></figure></li><li><p>小程序发送请求</p><p>发送请求使用<code>wx.request()</code>函数，参数是一个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">submit</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>    wx.<span class="hljs-property">request</span> (&#123;<br>        <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<span class="hljs-comment">//请求类型</span><br>        <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://127.0.0.1:3000/&#x27;</span>,<span class="hljs-comment">//接口地址</span><br>        <span class="hljs-attr">data</span>: e.<span class="hljs-property">detail</span>.<span class="hljs-property">value</span>,<span class="hljs-comment">//请求内容</span><br>        <span class="hljs-attr">header</span>:&#123;<span class="hljs-comment">//请求头</span><br>            <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span><br>        &#125;,<br>        <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) &#123;<span class="hljs-comment">//请求成功后执行的函数</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>        &#125;,<br>        <span class="hljs-attr">fail</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<span class="hljs-comment">//请求失败后执行的函数</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error)<br>        &#125;<br>    &#125;)&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在发送请求时候可能会出现错误：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">request:fail url not in <span class="hljs-built_in">domain</span> list<br></code></pre></td></tr></table></figure><p>这时需要到<em>设置-项目设置-本地设置</em>，将*不检验合法域名…*选中，就可以了。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ensp常用基础指令</title>
    <link href="/2023/11/24/ensp/"/>
    <url>/2023/11/24/ensp/</url>
    
    <content type="html"><![CDATA[<h1 id="描述vlan"><a href="#描述vlan" class="headerlink" title="描述vlan"></a>描述vlan</h1><p>description用来给vlan加定义信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ensp">description Technical//技术部vlan<br></code></pre></td></tr></table></figure><h1 id="ip绑定mac"><a href="#ip绑定mac" class="headerlink" title="ip绑定mac"></a>ip绑定mac</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ensp">int e0/0/3<br>port-sercurity enable<br>port-sercur mac-address strick<br>port-sercur mac-address strick 1234-4567-ABCD vlan 10 //在valn10上启用<br></code></pre></td></tr></table></figure><h1 id="STP"><a href="#STP" class="headerlink" title="STP"></a>STP</h1><p>①使冗余端口置于“阻塞状态”<br>②网络中的计算机在通信时，只有一条链路生效<br>③当这个链路出现故障时，将处于“阻塞状态”的端口重新打开，从而确保网络连接稳定可靠<br><strong>STP</strong>的优先级越小，优先级越高，最小0，最大4096</p><h2 id="开启STP"><a href="#开启STP" class="headerlink" title="开启STP"></a>开启STP</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">stp <span class="hljs-built_in">enable</span><br>stp mode stp<br></code></pre></td></tr></table></figure><h2 id="配置STP优先级"><a href="#配置STP优先级" class="headerlink" title="配置STP优先级"></a>配置STP优先级</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">stp priority <span class="hljs-number">0</span>  <span class="hljs-regexp">//</span>配置成为主根交换机<br>stp priority <span class="hljs-number">4096</span>  <span class="hljs-regexp">//</span>配置成为备份根交换机<br></code></pre></td></tr></table></figure><p>还有另一种方法</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">stp root primary    <span class="hljs-regexp">//</span>主根交换机<br>stp root secondary  <span class="hljs-regexp">//</span>备份根交换机<br></code></pre></td></tr></table></figure><h2 id="配置边缘端口"><a href="#配置边缘端口" class="headerlink" title="配置边缘端口"></a>配置边缘端口</h2><p>配置为边缘端口，以加速网络的收敛,缩短收敛的时间，减少了对网络通信的影响</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">int</span> e0<span class="hljs-regexp">/0/</span><span class="hljs-number">10</span><br>stp edged-port enable<br></code></pre></td></tr></table></figure><h1 id="RSTP"><a href="#RSTP" class="headerlink" title="RSTP"></a>RSTP</h1><h2 id="开启rstp"><a href="#开启rstp" class="headerlink" title="开启rstp"></a>开启rstp</h2><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">stp <span class="hljs-built_in">mode</span> rstp <br></code></pre></td></tr></table></figure><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">stp priority <span class="hljs-number">0</span>  <span class="hljs-regexp">//</span>配置成为主根交换机<br>stp priority <span class="hljs-number">4096</span>  <span class="hljs-regexp">//</span>配置成为备份根交换机<br></code></pre></td></tr></table></figure><p>还有另一种方法</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">stp root primary    <span class="hljs-regexp">//</span>主根交换机<br>stp root secondary  <span class="hljs-regexp">//</span>备份根交换机<br></code></pre></td></tr></table></figure><h2 id="配置边缘端口-1"><a href="#配置边缘端口-1" class="headerlink" title="配置边缘端口"></a>配置边缘端口</h2><p>配置为边缘端口，以加速网络的收敛,缩短收敛的时间，减少了对网络通信的影响</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">int</span> e0<span class="hljs-regexp">/0/</span><span class="hljs-number">10</span><br>stp edged-port enable<br></code></pre></td></tr></table></figure><h1 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h1><h2 id="配置静态路由"><a href="#配置静态路由" class="headerlink" title="配置静态路由"></a>配置静态路由</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ip</span> route-static 目标网段 子网掩码 下一跳地址<br><span class="hljs-attribute">ip</span> route-static <span class="hljs-number">172.16.1.0</span> <span class="hljs-number">24</span> <span class="hljs-number">20.20.20.10</span><br></code></pre></td></tr></table></figure><p>在 R1 上配置目的网段为主机 PC2 所在网段的静态路由，即目的 IP 地址为 172.16.1.0，<br>掩码 255.255.255.0 即 24 位。对于 R1 而言，要发送数据到主机 PC2，则必须先发送给 R2，<br>所以 R2 即为 R1 的下一跳路由，R2 与 R1 所在的直连链路上的物理接口的 IP 地址即为下一<br>跳 IP 地址，即 20.20.20.10。<br><img src="/image.png" alt="route-static"></p><h2 id="查看路由表"><a href="#查看路由表" class="headerlink" title="查看路由表"></a>查看路由表</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">display</span> ip routing-<span class="hljs-selector-tag">table</span><br></code></pre></td></tr></table></figure><h1 id="浮动路由"><a href="#浮动路由" class="headerlink" title="浮动路由"></a>浮动路由</h1><p>定义：指<strong>配置两条静态路由</strong>，默认选取链路质量优（<strong>带宽大的）作为主路径</strong>，当主路径出现故障时，由带宽较小的备份路径顶替主路经，浮动路由站在同一时刻，数据<strong>只会由一条链路代为转发。</strong>。 <strong>优先级越小越优先</strong><br><strong>静态路由的默认优先级是60</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">[R1]ip route-static <span class="hljs-number">0.0.0.0</span> <span class="hljs-number">0.0.0.0</span> <span class="hljs-number">10.10.10.10</span><br>[R2]ip route-static <span class="hljs-number">0.0.0.0</span> <span class="hljs-number">0.0.0.0</span> <span class="hljs-number">10.10.10.1</span><br></code></pre></td></tr></table></figure><p>浮动路由，优先级设为100，做备用。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">[R1]ip route-static <span class="hljs-number">0.0.0.0</span> <span class="hljs-number">0.0.0.0</span> <span class="hljs-number">20.20.20.10</span> preference <span class="hljs-number">100</span><br>[R2]ip route-static <span class="hljs-number">0.0.0.0</span> <span class="hljs-number">0.0.0.0</span> <span class="hljs-number">20.20.20.1</span> preference <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p><img src="/image-1.png" alt="Alt text"></p><h1 id="OSPF动态路由协议"><a href="#OSPF动态路由协议" class="headerlink" title="OSPF动态路由协议"></a>OSPF动态路由协议</h1><p>Area 0 是骨干区域、核心区域，Area 1、2 等是常规区域，其他常规区域都必须与此相连。</p><h2 id="创建并运行"><a href="#创建并运行" class="headerlink" title="创建并运行"></a>创建并运行</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm">配置<br>[<span class="hljs-built_in">R1</span>]ospf <span class="hljs-number">1</span><br>[<span class="hljs-built_in">R1</span>-ospf-<span class="hljs-number">1</span>]<span class="hljs-meta">area</span> <span class="hljs-number">0</span><br>[<span class="hljs-built_in">R1</span>-ospf-<span class="hljs-number">1</span>-<span class="hljs-meta">area</span>-<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>]network <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span> <span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">255</span><br></code></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">network</span> 直连网段 反掩码<br></code></pre></td></tr></table></figure><h1 id="单臂路由"><a href="#单臂路由" class="headerlink" title="单臂路由"></a>单臂路由</h1><p>单臂路由（router-on-a-stick）是指在路由器的一个接口上通过配置子接口（或“逻辑接口”，并不存在真正物理接口）的方式，实现原来相互隔离的不同VLAN（虚拟局域网）之间的互联互通。<br><a href="https://blog.csdn.net/weixin_45551608/article/details/114764211">单臂详解</a></p><blockquote><p>易错点<br>1 交换机和路由器相连的端口属性要设置为Trunk且运行所有vlan通过；<br>2 和路由器直接相连的接口（不是子接口）不能设置IP；<br>3 路由器的子接口要记得开启arp广播请求；<br>4 主机ip和子接口ip地址（所对应的网关地址）不能重复。</p></blockquote><p><img src="/image-2.png" alt="Alt text"></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[Huawei]system-view<br>[Huawei]sysname SW1<br>[SW1]vlan batch <span class="hljs-number">10</span> <span class="hljs-number">20</span><br>[SW1] port-<span class="hljs-keyword">group</span> <span class="hljs-keyword">group</span>-member Ethernet <span class="hljs-number">0</span><span class="hljs-regexp">/0/</span><span class="hljs-number">2</span> to Ethernet <span class="hljs-number">0</span><span class="hljs-regexp">/0/</span><span class="hljs-number">10</span><br>[SW1-port-<span class="hljs-keyword">group</span>]port link-type access<br>[SW1-port-<span class="hljs-keyword">group</span>]port <span class="hljs-keyword">default</span> vlan <span class="hljs-number">10</span><br>[SW1-port-<span class="hljs-keyword">group</span>]quit<br>[SW1] port-<span class="hljs-keyword">group</span> <span class="hljs-keyword">group</span>-member Ethernet <span class="hljs-number">0</span><span class="hljs-regexp">/0/</span><span class="hljs-number">11</span> to Ethernet <span class="hljs-number">0</span><span class="hljs-regexp">/0/</span><span class="hljs-number">20</span> <br>[SW1-port-<span class="hljs-keyword">group</span>]port link-type access<br>[SW1-port-<span class="hljs-keyword">group</span>]port <span class="hljs-keyword">default</span> vlan <span class="hljs-number">20</span><br>[SW1-port-<span class="hljs-keyword">group</span>]quit<br>[SW1]<span class="hljs-keyword">interface</span> Ethernet0<span class="hljs-regexp">/0/</span><span class="hljs-number">1</span><br>[SW1-Ethernet0<span class="hljs-regexp">/0/</span><span class="hljs-number">1</span>]port link-type trunk<br>[SW1]<span class="hljs-keyword">interface</span> Ethernet0<span class="hljs-regexp">/0/</span><span class="hljs-number">1</span><br>[SW1-Ethernet0<span class="hljs-regexp">/0/</span><span class="hljs-number">1</span>]port trunk allow-pass vlan <span class="hljs-number">10</span> <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gradle">&lt;Huawei&gt;system-view<br>[Huawei]sysname R1<br>[R1]<span class="hljs-keyword">interface</span> GigabitEthernet <span class="hljs-number">0</span><span class="hljs-regexp">/0/</span><span class="hljs-number">0.1</span><br>[R1-GigabitEthernet0<span class="hljs-regexp">/0/</span><span class="hljs-number">0.1</span>]dot1q termination vid <span class="hljs-number">10</span><br>[R1-GigabitEthernet0<span class="hljs-regexp">/0/</span><span class="hljs-number">0.1</span>]ip address <span class="hljs-number">192.168</span>.<span class="hljs-number">1.254</span> <span class="hljs-number">24</span><br>[R1-GigabitEthernet0<span class="hljs-regexp">/0/</span><span class="hljs-number">0.1</span>]arp broadcast enable<br>[R1-GigabitEthernet0<span class="hljs-regexp">/0/</span><span class="hljs-number">0.1</span>]quit<br>[R1]<span class="hljs-keyword">interface</span> GigabitEthernet <span class="hljs-number">0</span><span class="hljs-regexp">/0/</span><span class="hljs-number">0.2</span><br>[R1-GigabitEthernet0<span class="hljs-regexp">/0/</span><span class="hljs-number">0.2</span>]dot1q termination vid <span class="hljs-number">20</span><br>[R1-GigabitEthernet0<span class="hljs-regexp">/0/</span><span class="hljs-number">0.2</span>]ip address <span class="hljs-number">192.168</span>.<span class="hljs-number">2.254</span> <span class="hljs-number">24</span><br>[R1-GigabitEthernet0<span class="hljs-regexp">/0/</span><span class="hljs-number">0.2</span>]arp broadcast enable<br></code></pre></td></tr></table></figure><p>dot1q终结模式是指在网络设备（如交换机、路由器）上配置一个接口，用于接收和处理使用IEEE 802.1Q协议进行标记的VLAN数据帧。</p><p>IEEE 802.1Q是一种VLAN标记协议，通过在以太网帧的头部添加额外的标记字段来标识不同的VLAN。当网络中的数据帧经过支持802.1Q的交换机时，交换机会根据帧头部的标记字段将数据帧发送到相应的VLAN。</p><p>而dot1q终结模式则是在网络设备上配置特定的接口，使其能够接收并解析带有VLAN标记的数据帧，并按照相应的VLAN进行处理。这样，设备就能够将不同VLAN之间的数据进行隔离和转发。</p><p>通过配置dot1q终结模式，网络设备可以实现多个虚拟局域网（VLAN）之间的隔离和通信，提供更灵活和可靠的网络架构。</p><p>ARP（Address Resolution Protocol）是一种用于将IP地址解析为MAC地址的协议。当主机需要与目标主机通信时，首先需要知道目标主机的MAC地址。主机会通过发送ARP请求广播来获取目标主机的MAC地址，然后将该MAC地址添加到自己的ARP缓存中，以便后续通信。</p><p>在命令中，<code>[R1-GigabitEthernet0/0/0.10]</code> 表示进入到接口 GigabitEthernet0&#x2F;0&#x2F;0 的子接口 VLAN 10 的配置模式。”arp broadcast enable” 则是启用该接口上的 ARP 广播功能，允许该接口发送 ARP 请求广播。</p><h1 id="vlanif"><a href="#vlanif" class="headerlink" title="vlanif"></a>vlanif</h1><p>分VLAN后，同一VLAN内的用户可以互相通信，但是属于不同VLAN的用户不能直接通信。为了实现VLAN间通信，可通过配置逻辑的三层接口（VLANIF接口）来实现。当交换机需要与网络层的设备通信时，可以在交换机上创建基于VLAN的逻辑接口，即VLANIF接口。VLANIF接口属于逻辑接口，逻辑接口是指物理上不存在且需要通过配置建立的接口。<br>VLANIF接口是网络层接口，创建VLANIF接口前要先创建了对应的VLAN，才可以配置IP地址。借助VLANIF接口，交换机就能与其它网络层的设备互相通信。</p><h1 id="vrrp"><a href="#vrrp" class="headerlink" title="vrrp"></a>vrrp</h1><p>虚拟路由冗余协议VRRP（Virtual Router Redundancy Protocol）通过把几台路由设备联合组成一台虚拟的路由设备，将虚拟路由设备的IP地址作为用户的默认网关实现与外部网络通信。当网关设备发生故障时，VRRP机制能够选举新的网关设备承担数据流量，从而保障网络的可靠通信。</p><h2 id="配置VRRP协议"><a href="#配置VRRP协议" class="headerlink" title="配置VRRP协议"></a>配置VRRP协议</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">vrrp</span> vrid 备份组号 virtual-<span class="hljs-built_in">ip</span> 虚拟<span class="hljs-built_in">ip</span><br></code></pre></td></tr></table></figure><p><img src="/image-3.png" alt="Alt text"></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[R1]<span class="hljs-keyword">interface</span> G0<span class="hljs-regexp">/0/</span><span class="hljs-number">0</span><br>[R1-GigabitEthernet0<span class="hljs-regexp">/0/</span><span class="hljs-number">0</span>]vrrp vrid <span class="hljs-number">1</span> virtual-ip <span class="hljs-number">192.168</span>.<span class="hljs-number">1.254</span><br><br>[R2]<span class="hljs-keyword">interface</span> GigabitEthernet <span class="hljs-number">0</span><span class="hljs-regexp">/0/</span><span class="hljs-number">0</span><br>[R2-GigabitEthernet0<span class="hljs-regexp">/0/</span><span class="hljs-number">0</span>]vrrp vrid <span class="hljs-number">1</span> virtual-ip <span class="hljs-number">192.168</span>.<span class="hljs-number">1.254</span><br></code></pre></td></tr></table></figure><p><strong>设置优先级</strong><br>vrrp的优先级越大越优先，默认是100。使R1 成为 Master， R2 为 Backup</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">[R1-GigabitEthernet0<span class="hljs-regexp">/0/</span><span class="hljs-number">0</span>]vrrp vrid <span class="hljs-number">1</span> priority <span class="hljs-number">110</span><br></code></pre></td></tr></table></figure><h2 id="配置上行接口监视"><a href="#配置上行接口监视" class="headerlink" title="配置上行接口监视"></a>配置上行接口监视</h2><p>在 R1 上配置上行接口监视，监视上行接口 G0&#x2F;0&#x2F;1，当此接口断掉时，裁剪优先级 60，<br>使优先级变为 50，小于 R2 的优先级 100。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[R1-GigabitEthernet0/0/0]</span>vrrp vrid <span class="hljs-number">1</span> track <span class="hljs-keyword">interface</span> <span class="hljs-symbol">GigabitEthernet</span> <span class="hljs-symbol">0</span>/<span class="hljs-symbol">0</span>/<span class="hljs-symbol">1</span> <span class="hljs-symbol">reduced</span> <span class="hljs-symbol">60</span><br></code></pre></td></tr></table></figure><h1 id="基于VRRP的双出口负载均衡"><a href="#基于VRRP的双出口负载均衡" class="headerlink" title="基于VRRP的双出口负载均衡"></a>基于VRRP的双出口负载均衡</h1><p>为内部计算机指定两个网关，使内部流量通过不同的路由器转发。网关可以使用<strong>多个VRRP组来实现</strong></p><h2 id="配置VRRP路由协议"><a href="#配置VRRP路由协议" class="headerlink" title="配置VRRP路由协议"></a>配置VRRP路由协议</h2><p><img src="/image-4.png" alt="Alt text"></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">//R1配置</span><br>[R1]<span class="hljs-keyword">interface</span> G0<span class="hljs-regexp">/0/</span><span class="hljs-number">0</span><br>[R1-GigabitEthernet0<span class="hljs-regexp">/0/</span><span class="hljs-number">0</span>]vrrp vrid <span class="hljs-number">1</span> virtual-ip <span class="hljs-number">192.168</span>.<span class="hljs-number">1.253</span><br>[R1-GigabitEthernet0<span class="hljs-regexp">/0/</span><span class="hljs-number">0</span>] vrrp vrid <span class="hljs-number">2</span> virtual-ip <span class="hljs-number">192.168</span>.<span class="hljs-number">1.254</span><br><br>R2配置<br>[R2]<span class="hljs-keyword">interface</span> GigabitEthernet <span class="hljs-number">0</span><span class="hljs-regexp">/0/</span><span class="hljs-number">0</span><br>[R2-GigabitEthernet0<span class="hljs-regexp">/0/</span><span class="hljs-number">0</span>]vrrp vrid <span class="hljs-number">1</span> virtual-ip <span class="hljs-number">192.168</span>.<span class="hljs-number">1.253</span><br>[R2-GigabitEthernet0<span class="hljs-regexp">/0/</span><span class="hljs-number">0</span>]vrrp vrid <span class="hljs-number">2</span> virtual-ip <span class="hljs-number">192.168</span>.<span class="hljs-number">1.254</span><br></code></pre></td></tr></table></figure><p><strong>设置优先级</strong><br>优先级默认100，配置优先级使R1成为组1的master路由，R2成为组2的master路由</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">[R1-GigabitEthernet0<span class="hljs-regexp">/0/</span><span class="hljs-number">0</span>]vrrp vrid <span class="hljs-number">1</span> priority <span class="hljs-number">110</span><br>[R2-GigabitEthernet0<span class="hljs-regexp">/0/</span><span class="hljs-number">0</span>] vrrp vrid <span class="hljs-number">2</span> priority <span class="hljs-number">110</span><br></code></pre></td></tr></table></figure><h2 id="监视上行端口"><a href="#监视上行端口" class="headerlink" title="监视上行端口"></a>监视上行端口</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[R1-GigabitEthernet0<span class="hljs-regexp">/0/</span><span class="hljs-number">0</span>]vrrp vrid <span class="hljs-number">1</span> track <span class="hljs-keyword">interface</span> GigabitEthernet <span class="hljs-number">0</span><span class="hljs-regexp">/0/</span><span class="hljs-number">1</span> reduced <span class="hljs-number">60</span><br><br>[R2-GigabitEthernet0<span class="hljs-regexp">/0/</span><span class="hljs-number">0</span>]vrrp vrid <span class="hljs-number">1</span> track <span class="hljs-keyword">interface</span> GigabitEthernet <span class="hljs-number">0</span><span class="hljs-regexp">/0/</span><span class="hljs-number">2</span> reduced <span class="hljs-number">60</span><br></code></pre></td></tr></table></figure><h1 id="链路聚合"><a href="#链路聚合" class="headerlink" title="链路聚合"></a>链路聚合</h1><p><strong>两台交换机间的链路进行汇聚，提高网络传输质量</strong></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>创建Eth-Trunk 1 接口，指定为手工负载分担模式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[SW1]</span>interface Eth-Trunk <span class="hljs-number">1</span><br><span class="hljs-selector-attr">[SW1-Eth-Trunk1]</span>mode manual load-balance<br><span class="hljs-selector-attr">[SW1]</span>quit<br></code></pre></td></tr></table></figure><p><strong>将端口加入接口</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[SW1]<span class="hljs-keyword">interface</span> GigabitEthernet <span class="hljs-number">0</span><span class="hljs-regexp">/0/</span><span class="hljs-number">1</span><br>[SW1-GigabitEthernet0<span class="hljs-regexp">/0/</span><span class="hljs-number">1</span>] eth-trunk <span class="hljs-number">1</span><br>[SW1]<span class="hljs-keyword">interface</span> GigabitEthernet <span class="hljs-number">0</span><span class="hljs-regexp">/0/</span><span class="hljs-number">2</span><br>[SW1-GigabitEthernet0<span class="hljs-regexp">/0/</span><span class="hljs-number">2</span>] eth-trunk <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>批量加入</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[SW1]<span class="hljs-keyword">interface</span> Eth-Trunk <span class="hljs-number">1</span><br>[SW1]trunkport g0<span class="hljs-regexp">/0/</span><span class="hljs-number">1</span> g0<span class="hljs-regexp">/0/</span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h1 id="PAP认证"><a href="#PAP认证" class="headerlink" title="PAP认证"></a>PAP认证</h1><h2 id="配置ppp的pap认证"><a href="#配置ppp的pap认证" class="headerlink" title="配置ppp的pap认证"></a>配置ppp的pap认证</h2><p><strong>认证端配置</strong><br>R1 路由器作为认证端，需要配置本端 PPP 协议的认证方式为 PAP。执行 aaa 命令，进入<br>AAA 视图，配置 PAP 认证所使用的用户名密码。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">[<span class="hljs-built_in">R1</span>]<span class="hljs-keyword">aaa</span><br>[<span class="hljs-built_in">R1</span>-<span class="hljs-keyword">aaa</span>]local-user jan16 password cipher <span class="hljs-number">123456</span><br>[<span class="hljs-built_in">R1</span>-<span class="hljs-keyword">aaa</span>]local-user jan16 service-type ppp<br>[<span class="hljs-built_in">R1</span>-<span class="hljs-keyword">aaa</span>]<span class="hljs-keyword">int</span> s4/<span class="hljs-number">0</span>/<span class="hljs-number">0</span><br>[<span class="hljs-built_in">R1</span>-Serial4/<span class="hljs-number">0</span>/<span class="hljs-number">0</span>]link-protocol ppp<br>[<span class="hljs-built_in">R1</span>-Serial4/<span class="hljs-number">0</span>/<span class="hljs-number">0</span>]ppp authentication-mode pap<br></code></pre></td></tr></table></figure><p><strong>对端配置pap认证</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[R2]<span class="hljs-keyword">int</span> s4<span class="hljs-regexp">/0/</span><span class="hljs-number">0</span><br>[R2-Serial4<span class="hljs-regexp">/0/</span><span class="hljs-number">0</span>]link-protocol ppp<br>[R2-Serial4<span class="hljs-regexp">/0/</span><span class="hljs-number">0</span>]ppp pap local-user Jan16 password cipher <span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure><h1 id="CHAP认证"><a href="#CHAP认证" class="headerlink" title="CHAP认证"></a>CHAP认证</h1><h2 id="配置ppp的CHAP认证"><a href="#配置ppp的CHAP认证" class="headerlink" title="配置ppp的CHAP认证"></a>配置ppp的CHAP认证</h2><p><strong>认证方</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[R1]aaa<br>[R1-aaa]<span class="hljs-keyword">local</span>-<span class="hljs-keyword">user</span> Jan16 <span class="hljs-keyword">password</span> cipher <span class="hljs-number">123456</span><br>[R1-aaa]<span class="hljs-keyword">local</span>-<span class="hljs-keyword">user</span> Jan16 service-<span class="hljs-keyword">type</span> ppp<br>[R1]interface <span class="hljs-type">Serial</span> <span class="hljs-number">4</span>/<span class="hljs-number">0</span>/<span class="hljs-number">0</span><br>[R1-<span class="hljs-type">Serial4</span>/<span class="hljs-number">0</span>/<span class="hljs-number">0</span>]link-protocol ppp<br>[R1-<span class="hljs-type">Serial4</span>/<span class="hljs-number">0</span>/<span class="hljs-number">0</span>]ppp authentication-mode chap<br></code></pre></td></tr></table></figure><p><strong>被认证方</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[R2]<span class="hljs-keyword">int</span> s4<span class="hljs-regexp">/0/</span><span class="hljs-number">0</span><br>[R2-Serial4<span class="hljs-regexp">/0/</span><span class="hljs-number">0</span>]link-protocol ppp<br>[R2-Serial4<span class="hljs-regexp">/0/</span><span class="hljs-number">0</span>]ppp chap user Jan16<br>[R2-Serial4<span class="hljs-regexp">/0/</span><span class="hljs-number">0</span>]ppp chap password <span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure><h1 id="PPPoE认证"><a href="#PPPoE认证" class="headerlink" title="PPPoE认证"></a>PPPoE认证</h1><p>拨号上网</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs css">①修改 ISP 路由器的设备名，并配置 Loopback1 接口的 IP；<br><span class="hljs-selector-attr">[Huawei]</span>system-view<br><span class="hljs-selector-attr">[Huawei]</span>sysname ISP<br><span class="hljs-selector-attr">[ISP]</span> interface LoopBack1<br><span class="hljs-selector-attr">[ISP-LoopBack1]</span> ip <span class="hljs-selector-tag">address</span> <span class="hljs-number">10.10</span>.<span class="hljs-number">10.1</span> <span class="hljs-number">255.255</span>.<span class="hljs-number">255.0</span><br>②配置 PPPoE 地址池，通过使用全局地址池给对端分配地址，实现 PPPoE Server 为<br>PPPoE Client 动态分配 IP 地址。<br><span class="hljs-selector-attr">[ISP]</span>ip pool pppoe<br><span class="hljs-selector-attr">[ISP-ip-pool-pppoe]</span>gateway-list <span class="hljs-number">20.20</span>.<span class="hljs-number">20.1</span><br><span class="hljs-selector-attr">[ISP-ip-pool-pppoe]</span>network <span class="hljs-number">20.20</span>.<span class="hljs-number">20.0</span> <span class="hljs-attribute">mask</span> <span class="hljs-number">255.255</span>.<span class="hljs-number">255.0</span><br>③配置 PPPoE 认证用户，实现 PPPoE Server 对用户主机的认证。<br><span class="hljs-selector-attr">[ISP]</span>aaa<br><span class="hljs-selector-attr">[ISP-aaa]</span>local-user r1 password cipher <span class="hljs-number">123456</span><br><span class="hljs-selector-attr">[ISP-aaa]</span>local-user r1 privilege level <span class="hljs-number">0</span><br><span class="hljs-selector-attr">[ISP-aaa]</span>local-user r1 service-type ppp<br>④配置虚拟接口模板 VT，本端 PPPoE 协议对对端设备的认证方式为 CHAP。<br><span class="hljs-selector-attr">[ISP]</span>interface Virtual-Template <span class="hljs-number">1</span><br><span class="hljs-selector-attr">[ISP-Virtual-Template1]</span>ppp authentication-mode chap<br><span class="hljs-selector-attr">[ISP-Virtual-Template1]</span>remote <span class="hljs-selector-tag">address</span> pool pppoe<br><span class="hljs-selector-attr">[ISP-Virtual-Template1]</span>ip <span class="hljs-selector-tag">address</span> <span class="hljs-number">20.20</span>.<span class="hljs-number">20.1</span> <span class="hljs-number">255.255</span>.<span class="hljs-number">255.0</span><br>⑤启用 PPPoE Server 功能，在以太网接口 G0/<span class="hljs-number">0</span>/<span class="hljs-number">0</span> 上启用 PPPoE Server 功能。<br><span class="hljs-selector-attr">[ISP]</span>interface GigabitEthernet <span class="hljs-number">0</span>/<span class="hljs-number">0</span>/<span class="hljs-number">0</span><br><span class="hljs-selector-attr">[ISP-GigabitEthernet0/0/0]</span>pppoe-server bind Virtual-Template <span class="hljs-number">1</span><br>（<span class="hljs-number">2</span>）配置 PPPoE 客户端<br>①修改 R1 路由器的设备名，并配置 G0/<span class="hljs-number">0</span>/<span class="hljs-number">1</span> 接口的 IP 作为内网用户的网关；<br><span class="hljs-selector-attr">[Huawei]</span>system-view<br><span class="hljs-selector-attr">[Huawei]</span>sysname R1<br><span class="hljs-selector-attr">[R1]</span>int G0/<span class="hljs-number">0</span>/<span class="hljs-number">1</span><br><span class="hljs-selector-attr">[R1-GigabitEthernet0/0/1]</span> ip <span class="hljs-selector-tag">address</span> <span class="hljs-number">192.168</span>.<span class="hljs-number">10.254</span> <span class="hljs-number">255.255</span>.<span class="hljs-number">255.0</span><br>②配置 Dialer 接口。<br><span class="hljs-selector-attr">[R1]</span>interface Dialer0<br><span class="hljs-selector-attr">[R1-Dialer0]</span>ppp chap user r1<br><span class="hljs-selector-attr">[R1-Dialer0]</span>ppp chap password cipher <span class="hljs-number">123456</span><br><span class="hljs-selector-attr">[R1-Dialer0]</span>tcp adjust-mss <span class="hljs-number">1200</span><br><span class="hljs-selector-attr">[R1-Dialer0]</span>ip <span class="hljs-selector-tag">address</span> ppp-negotiate<br><span class="hljs-selector-attr">[R1-Dialer0]</span>dialer user isp<br><span class="hljs-selector-attr">[R1-Dialer0]</span>dialer bundle <span class="hljs-number">1</span><br><span class="hljs-selector-attr">[R1-Dialer0]</span>dialer-group <span class="hljs-number">1</span><br>③建立 PPPoE 会话<br><span class="hljs-selector-attr">[R1]</span>interface GigabitEthernet0/<span class="hljs-number">0</span>/<span class="hljs-number">0</span><br><span class="hljs-selector-attr">[R1-GigabitEthernet0/0/0]</span> pppoe-client dial-bundle-number <span class="hljs-number">1</span><br>④配置 NAT 转换，配置局域网用户通过 NAT 转换将私网地址转换为公网地址，进行拨<br>号上网。<br><span class="hljs-selector-attr">[R1]</span>acl number <span class="hljs-number">3000</span><br><span class="hljs-selector-attr">[R1-acl-adv-3000]</span> rule <span class="hljs-number">5</span> permit ip source <span class="hljs-number">192.168</span>.<span class="hljs-number">10.0</span> <span class="hljs-number">0.0</span>.<span class="hljs-number">0.255</span><br><span class="hljs-selector-attr">[R1-acl-adv-3000]</span>quit<br><span class="hljs-selector-attr">[R1]</span>interface Dialer0<br><span class="hljs-selector-attr">[R1-Dialer0]</span>nat outbound <span class="hljs-number">3000</span><br>⑤配置到 PPPoE Server 的静态路由<br><span class="hljs-selector-attr">[R1]</span> ip route-static <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span> <span class="hljs-number">0</span> dialer <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h1 id="ACL访问控制列表"><a href="#ACL访问控制列表" class="headerlink" title="ACL访问控制列表"></a>ACL访问控制列表</h1><p>ACL用来过滤数据包</p><h2 id="配置ACL"><a href="#配置ACL" class="headerlink" title="配置ACL"></a>配置ACL</h2><p>创建ACL允许，源为192.168.30.0的报文通过，应用到G0&#x2F;0&#x2F;2上。<br>华为默认全部允许</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[SW1]</span>acl 2000<br><span class="hljs-comment">[SW1-acl-basic-2000]</span><span class="hljs-keyword">rule</span> permit source 192.168.30.0 0.0.0.255<br><span class="hljs-comment">[SW1-acl-basic-2000]</span><span class="hljs-keyword">rule</span> deny <br><span class="hljs-comment">[SW1]</span>int G0/0/2<br><span class="hljs-comment">[SW1-GigabitEthernet0/0/2]</span>traffic-filter outbound acl 2000<br></code></pre></td></tr></table></figure><p>拒绝包源网段为192.168.40.0的报文通过，规则应用到g0&#x2F;0&#x2F;1上</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[SW1]acl <span class="hljs-number">2001</span><br>[SW1-acl-basic-<span class="hljs-number">2001</span>]rule deny <span class="hljs-keyword">source</span> <span class="hljs-number">192.168</span>.<span class="hljs-number">40.0</span> <span class="hljs-number">0.0</span>.<span class="hljs-number">0.255</span><br>[SW1]<span class="hljs-keyword">int</span> G0<span class="hljs-regexp">/0/</span><span class="hljs-number">1</span><br>[SW1-GigabitEthernet0<span class="hljs-regexp">/0/</span><span class="hljs-number">1</span>]traffic-filter outbound acl <span class="hljs-number">2001</span><br></code></pre></td></tr></table></figure><h1 id="扩展ACL"><a href="#扩展ACL" class="headerlink" title="扩展ACL"></a>扩展ACL</h1><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">[<span class="hljs-built_in">R1</span>]acl <span class="hljs-number">3000</span><br><br>//配置了ACL的第<span class="hljs-number">5</span>条规则，允许源<span class="hljs-built_in">IP</span>地址为<span class="hljs-number">192.168</span><span class="hljs-number">.10</span><span class="hljs-number">.1</span>的TCP流量通过，目的端口为<span class="hljs-number">80</span>（HTTP）。<br>[<span class="hljs-built_in">R1</span>-acl-adv-<span class="hljs-number">3000</span>]rule <span class="hljs-number">5</span> permit tcp source <span class="hljs-number">192.168</span><span class="hljs-number">.10</span><span class="hljs-number">.1</span> <span class="hljs-number">0</span> destination-port eq www<br><br>[<span class="hljs-built_in">R1</span>-acl-adv-<span class="hljs-number">3000</span>]rule <span class="hljs-number">10</span> deny <span class="hljs-built_in">ip</span><br>[<span class="hljs-built_in">R1</span>]<span class="hljs-keyword">int</span> G0/<span class="hljs-number">0</span>/<span class="hljs-number">1</span><br>[<span class="hljs-built_in">R1</span>-GigabitEthernet0/<span class="hljs-number">0</span>/<span class="hljs-number">1</span>]traffic-filter outbound acl <span class="hljs-number">3000</span><br></code></pre></td></tr></table></figure><p>这组命令的作用是配置了一个ACL，允许源IP地址为192.168.10.1的HTTP流量通过，而拒绝其他所有IP流量通过。然后，将该ACL应用到了GigabitEthernet0&#x2F;0&#x2F;1接口的出流量中。这样，从该接口发送出去的数据包都会被ACL过滤，只有符合规则的HTTP流量才能通过。<br>在这个语句中，</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">rule</span>表示ACL规则的关键字，<span class="hljs-number">5</span>表示规则的编号。permit表示该规则允许匹配的流量通过，tcp表示该规则适用于TCP协议。source <span class="hljs-number">192.168.10.1</span> <span class="hljs-number">0</span>表示源IP地址为<span class="hljs-number">192.168.10.1</span>，destination-port eq www表示目的端口为<span class="hljs-number">80</span>（HTTP）。<br></code></pre></td></tr></table></figure><h1 id="静态nat发布官网"><a href="#静态nat发布官网" class="headerlink" title="静态nat发布官网"></a>静态nat发布官网</h1><p>网络地址转换，主要将私有地址转换成公网地址。形成映射关系</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[R1]<span class="hljs-keyword">interface</span> GigabitEthernet <span class="hljs-number">0</span><span class="hljs-regexp">/0/</span><span class="hljs-number">1</span><br>[R1-GigabitEthernet0<span class="hljs-regexp">/0/</span><span class="hljs-number">1</span>]nat <span class="hljs-keyword">static</span> global <span class="hljs-number">16.16</span>.<span class="hljs-number">16.1</span> inside <span class="hljs-number">192.168</span>.<span class="hljs-number">1.1</span><br></code></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">nat</span> static <span class="hljs-meta">global</span> 公网<span class="hljs-built_in">ip</span> inside 内部<span class="hljs-built_in">ip</span><br></code></pre></td></tr></table></figure><p><img src="/image-5.png" alt="NAT-static"></p><h1 id="动态nat访问互联网"><a href="#动态nat访问互联网" class="headerlink" title="动态nat访问互联网"></a>动态nat访问互联网</h1><p>动态 NAT 转换需要有多个公网 IP 地址，在路由器中将公网 IP 地址配置为 NAT 地址池，并建立 ACL 列表匹配内部地址。在出口<br>路由器的 G0&#x2F;0&#x2F;1 上应用 NAT 转换即可。<br>动态NAT基于地址池来实现私有地址和公有地址的转换，转换是随机的<br><strong>配置地址池</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">[R1]nat address-<span class="hljs-keyword">group</span> <span class="hljs-title">1</span> <span class="hljs-number">16.16</span>.<span class="hljs-number">16.1</span> <span class="hljs-number">16.16</span>.<span class="hljs-number">16.5</span><br></code></pre></td></tr></table></figure><p><strong>创建ACL</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[R1]</span>acl 2000<br><span class="hljs-comment">[R1-acl-basic-2000]</span><span class="hljs-keyword">rule</span> permit source 192.168.10.0 0.0.0.255<br></code></pre></td></tr></table></figure><p><strong>nat绑定acl</strong><br>在 G0&#x2F;0&#x2F;1 接口下使用 nat outbound 命令将 ACL2000 与地址池相关联，使得 ACL 中规<br>定的地址可以使用地址池进行地址转换。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[R1-acl-basic-<span class="hljs-number">2000</span>]<span class="hljs-keyword">int</span> G0<span class="hljs-regexp">/0/</span><span class="hljs-number">1</span><br>[R1-GigabitEthernet0<span class="hljs-regexp">/0/</span><span class="hljs-number">1</span>]nat outbound <span class="hljs-number">2000</span> address-<span class="hljs-keyword">group</span> <span class="hljs-number">1</span> no-pat   <span class="hljs-comment">//不使用pat模式</span><br></code></pre></td></tr></table></figure><p>端口多路复用（Port address Translation,PAT）是指改变外出数据包的源端口并进行端口转换，即端口地址转换（PAT，Port Address Translation）.采用端口多路复用方式。内部网络的所有主机均可共享一个合法外部IP地址实现对Internet的访问，从而可以最大限度地节约IP地址资源。同时，又可隐藏网络内部的所有主机，有效避免来自internet的攻击。因此，目前网络中应用最多的就是端口多路复用方式。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>向外网发送包后，使用<code>disaplay nat session all</code>查看</p><h1 id="使用静态NAPT发布官网"><a href="#使用静态NAPT发布官网" class="headerlink" title="使用静态NAPT发布官网"></a>使用静态NAPT发布官网</h1><p>（通俗的讲）它们都是地址转换，NAPT与NAT的区别在于 NAT是一对一转换，NAPT是多对一转换。通俗来说NAT是一个内部地址转换成一个外部地址进行通信的，而NAPT是多个内部地址使用同一地址不同端口转换成外部地址进行通信的。<br>NAPT允许多个私网地址转换到同一个公有地址的不同端口，私网利用端口号来区分。<br>简单来说：NAPT发送数据的时候会在源地址和目标地址上加上端口号（比如源地址：192.168.1.2:1010，目标地址：200.1.1.2:1020），回来的数据也是一样。<br><img src="/image-6.png" alt="Alt text"></p><h2 id="配置静态NAPT"><a href="#配置静态NAPT" class="headerlink" title="配置静态NAPT"></a>配置静态NAPT</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[R1]<span class="hljs-keyword">interface</span> GigabitEthernet <span class="hljs-number">0</span><span class="hljs-regexp">/0/</span><span class="hljs-number">1</span><br>[R1-GigabitEthernet0<span class="hljs-regexp">/0/</span><span class="hljs-number">1</span>]nat server protocol tcp global <span class="hljs-number">16.16</span>.<span class="hljs-number">16.1</span> <span class="hljs-number">80</span> inside <span class="hljs-number">192.168</span>.<span class="hljs-number">1.1</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><h1 id="easyIP"><a href="#easyIP" class="headerlink" title="easyIP"></a>easyIP</h1><p>利用端口号来识别不用的私网地址，NAPT的特例。直接将内网私有地址转换为出接口的公网IP地址。<br>Easy IP 是 NAT 的其中一种方式，主要用于内部计算机共享公网 IP 地址访问互联网。<br><img src="/image-7.png" alt="Alt text"></p><h2 id="配置动态NAT"><a href="#配置动态NAT" class="headerlink" title="配置动态NAT"></a>配置动态NAT</h2><p><strong>创建ACL</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[R1]</span>acl 2000<br><span class="hljs-comment">[R1-acl-basic-2000]</span><span class="hljs-keyword">rule</span> permit source 192.168.10.0 0.0.0.255<br></code></pre></td></tr></table></figure><p><strong>在 G0&#x2F;0&#x2F;1 接口下使用 nat outbound 命令配置 Easy-IP 特性，直接使用接口 IP 地址作为 NAT 转换后的地址</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[R1-acl-basic-<span class="hljs-number">2000</span>]<span class="hljs-keyword">int</span> G0<span class="hljs-regexp">/0/</span><span class="hljs-number">1</span><br>[R1-GigabitEthernet0<span class="hljs-regexp">/0/</span><span class="hljs-number">1</span>]nat outbound <span class="hljs-number">2000</span><br></code></pre></td></tr></table></figure><h1 id="ipv6"><a href="#ipv6" class="headerlink" title="ipv6"></a>ipv6</h1><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>IPv6地址总长度为128比特，分为8组，每组为4个十六进制数的形式，每组十六进制数间用冒号分隔。<br>例如：FC00:0000:130F:0000:0000:09C0:876A:130B</p><h2 id="掩码"><a href="#掩码" class="headerlink" title="掩码"></a>掩码</h2><p>IPv6的掩码使用“前缀长度”来表示，如：<br>FC00:0:130F::9C0:876A:130B&#x2F;64<br>代表这个地址的前缀长度是64，也就是掩码长度为64位</p><h2 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h2><p>每组中的前导“0”都可以省略，上述地址可以写为：FC00:0:130F:0:0:9C0:876A:130B。<br>地址中包含的连续两个或多个均为0的组，可以用双冒号“::”来代替：FC00:0:130F::9C0:876A:130B<br>需要注意的是，在一个IPv6地址中只能使用一次双冒号“::”</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><strong>全球单播地址</strong><br>全球唯一的单播地址，类似于IPv4的公网IP<br>地址范围是2000::&#x2F;3<br><strong>唯一本地地址</strong><br>相当于IPv4的私网ip，在Internet不可路由。<br>IPv4的私网ip是为了节省地址，而IPv6主要为了安全（和Internet隔离），或者暂时没申请到地址临时使用。<br>地址范围是FC00::&#x2F;7<br><strong>链路本地地址</strong><br>当一个节点启动IPv6协议栈时，启动时节点的每个接口会自动配置一个链路本地地址。<br>这种机制使得两个连接到同一链路的IPv6节点不需要做任何配置就可以通信。<br>地址范围是FE80::&#x2F;10<br>链路本地地址可以使用EUI64自动生成<br><strong>特殊地址</strong><br>0:0:0:0:0:0:0:1&#x2F;128 或者::1&#x2F;128。<br>与IPv4中的127.0.0.1作用相同，用于本地回环，发往::&#x2F;1的数据包实际上就是发给本地，可用于本地协议栈回环测试。<br>0:0:0:0:0:0:0:0&#x2F;128 或者::&#x2F;128。<br>该地址作为某些报文的源地址，比如作为重复地址检测时发送的邻居请求报文（NS）的源地址，或者DHCPv6初始化过程中客户端所发送的请求报文的源地址。</p><h1 id="ipv6配置静态路由"><a href="#ipv6配置静态路由" class="headerlink" title="ipv6配置静态路由"></a>ipv6配置静态路由</h1><p><strong>启用ipv6</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[R2]<span class="hljs-keyword">interface</span> GigabitEthernet <span class="hljs-number">0</span><span class="hljs-regexp">/0/</span><span class="hljs-number">0</span><br>[R2-GigabitEthernet0<span class="hljs-regexp">/0/</span><span class="hljs-number">0</span>]ipv6 enable<br></code></pre></td></tr></table></figure><p><strong>添加ip地址</strong><br>地址2020:0:0:0:0:0:1，缩写为2020::1，掩码长度64位，4*16&#x3D;64，所以掩码是2020</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">[R2-GigabitEthernet0<span class="hljs-regexp">/0/</span><span class="hljs-number">0</span>]ipv6 address <span class="hljs-number">2020</span>::<span class="hljs-number">1</span>/<span class="hljs-number">64</span><br></code></pre></td></tr></table></figure><p><strong>配置静态路由</strong><br><img src="/image-8.png" alt="Alt text"><br>在R1上配置静态路由到PC2所在网段，目标网段为<code>2020::0</code>，掩码为<code>64</code>，下一跳地址为<code>2001::2</code></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">[<span class="hljs-title class_">R1</span>]ipv6 route-static <span class="hljs-number">2020</span>:: <span class="hljs-number">64</span> <span class="hljs-number">2001</span>::<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h1 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h1>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js笔记</title>
    <link href="/2023/11/01/js%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/11/01/js%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javaScript">&lt;head&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;hello world&quot;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/head&gt;<br></code></pre></td></tr></table></figure><p><a href="code/HelloWorld.html">代码运行</a></p><h2 id="JavaScript书写位置"><a href="#JavaScript书写位置" class="headerlink" title="JavaScript书写位置"></a>JavaScript书写位置</h2><p>共有三种写法<br><strong>行内</strong>、<strong>script</strong>、<strong>外部js文件中</strong></p><h3 id="行内"><a href="#行内" class="headerlink" title="行内"></a>行内</h3><p>新建一个 haicoder.html 文件，并输入以下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&lt;input type=<span class="hljs-string">&quot;button&quot;</span> value=<span class="hljs-string">&quot;haicoder&quot;</span> onclick=<span class="hljs-string">&quot;alert(&#x27;Hello HaiCoder&#x27;)&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p><a href="code/haicoder.html">代码运行</a><br>当我们点击按钮时，运行<strong>onclick</strong>中的代码</p><h3 id="script标签"><a href="#script标签" class="headerlink" title="script标签"></a>script标签</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&lt;head&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;HelloWorld&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/head&gt;<br></code></pre></td></tr></table></figure><p><a href="code/HelloWorld.html">代码运行</a></p><h3 id="使用外部js文件"><a href="#使用外部js文件" class="headerlink" title="使用外部js文件"></a>使用外部js文件</h3><p>新建一个main.js文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Hello</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;HelloWorld js&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后再新建一个main.html文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br>  Hello()<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><p><a href="code/main.html">代码运行</a></p><h2 id="JavaScript是弱类型语言"><a href="#JavaScript是弱类型语言" class="headerlink" title="JavaScript是弱类型语言"></a>JavaScript是弱类型语言</h2><p>JavaScript 是弱类型语言，因此 JavaScript 变量 无须声明可以直接赋值。<br>并且 JavaScript 变量的 数据类型 可以动态改变，即同一个变量可以一会儿被赋值为 整数值，一会儿也可以被赋值为字符串。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>JavaScript 是弱类型语言，因此 JavaScript 变量无须声明可以直接赋值。</p><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>在 JavaScript 中 ，声明变量使用 var 关键字，var 关键字后面直接加变量名即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> name;<br></code></pre></td></tr></table></figure><h3 id="声明并复制"><a href="#声明并复制" class="headerlink" title="声明并复制"></a>声明并复制</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;lihua&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="多个声明变量并赋值"><a href="#多个声明变量并赋值" class="headerlink" title="多个声明变量并赋值"></a>多个声明变量并赋值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;lihua&quot;</span>, age = <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><h3 id="改变类型"><a href="#改变类型" class="headerlink" title="改变类型"></a>改变类型</h3><p>JavaScript是弱类型语言，变量的数据类型可以改变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&lt;script&gt;<br>    <span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num)<br>    num = <span class="hljs-string">&quot;hi&quot;</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><a href="code/type.html">代码运行</a><br>按下f12打开浏览器控制台，查看结果</p><h2 id="变量命名规则和规范"><a href="#变量命名规则和规范" class="headerlink" title="变量命名规则和规范"></a>变量命名规则和规范</h2><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ol><li>JavaScript 变量只能由字母、数字、下划线、$ 符号组成，不能以数字开头。</li><li>JavaScript 变量命名时不能使用 关键字 和保留字，例如：for、while。</li><li>JavaScript 变量命名是区分大小写的，即变量 a 与变量 A 是两个不同的变量。</li></ol><h3 id="规范和建议"><a href="#规范和建议" class="headerlink" title="规范和建议"></a>规范和建议</h3><p>遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。例如：userName、userPassword 等。<br><strong>建议</strong>:<br>在给变量命名时，我们要做到见名知意，同时，我们最好也能做到见到变量名，能知道变量的 数据类型 ，因此，在定义变量时也有一套类似的常识标准，即，我们使用不同的变量前缀，代表变量的不同数据类型，如下：</p><table><thead><tr><th>类型</th><th>前缀</th><th>类型</th><th>实例</th></tr></thead><tbody><tr><td>数组</td><td>a</td><td><strong>Array</strong></td><td>aItems</td></tr><tr><td>布尔</td><td>b</td><td><strong>Boolean</strong></td><td>bIsPass</td></tr><tr><td>浮点数</td><td>f</td><td><strong>Float</strong></td><td>fPrice</td></tr><tr><td>函数</td><td>fn</td><td><strong>Function</strong></td><td>fnHandler</td></tr><tr><td>整数</td><td>i</td><td><strong>Integer</strong></td><td>iCount</td></tr><tr><td>对象</td><td>o</td><td><strong>Object</strong></td><td>oPerson</td></tr><tr><td>正则表达式</td><td>re</td><td>RegExp</td><td>reEmailCheck</td></tr><tr><td>字符串</td><td>s</td><td><strong>String</strong></td><td>sUserName</td></tr></tbody></table><p><a href="code/JavaScript%20%E5%85%B3%E9%94%AE%E5%AD%97-JavaScript%20%E4%BF%9D%E7%95%99%E5%AD%97%E6%9C%89%E5%93%AA%E4%BA%9B-%E5%97%A8%E5%AE%A2%E7%BD%91.html">js关键字</a></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>JavaScript 的基本数据类型有六种，即：<strong>字符串（String）</strong>、<strong>数字（Number）</strong>、<strong>布尔（Boolean）</strong>、<strong>空（Null）</strong>、<strong>未定义（Undefined）</strong>、<strong>代表（Symbol）</strong>。<br>其中代表是在 ECMAScript 6 中新添加的类型。一种实例是唯一且不可改变的数据类型。<br>字符串不能改变<br>其中数值、字符串、布尔称为原始类型，是最基本的数据类型，不能再细分。<br>同时，这些类型又有<strong>值类型</strong>和<strong>引用类型</strong>。</p><ul><li>值类型：Number、String、Boolean、null、undefinded</li><li>引用类型：函数、对象、数组等<br>值类型传递的是值，比如将变量a赋值给变量b，只传递值的话，两者只是单纯的值相等，没有其他关联，改变其中一个对另一个没有影响。如：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">100</span>;<span class="hljs-comment">//Number类型，值传递</span><br><span class="hljs-keyword">var</span> b = a;<span class="hljs-comment">//赋值</span><br>b = <span class="hljs-number">10</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<span class="hljs-comment">//将a输出到浏览器控制台,100</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b);<span class="hljs-comment">//将b输出到浏览器控制台,10</span><br></code></pre></td></tr></table></figure>而如果是引用类型，比如数组，则对另一个的修改会影响另一个<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<span class="hljs-comment">//声明数组[1,2,3]</span><br><span class="hljs-keyword">var</span> d = c;<br>d[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;[将d数组的<span class="hljs-number">1</span>改为<span class="hljs-number">0</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c);<span class="hljs-comment">//输出[023]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(d);<span class="hljs-comment">//输出[023]</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="JavaScript复杂数据类型"><a href="#JavaScript复杂数据类型" class="headerlink" title="JavaScript复杂数据类型"></a>JavaScript复杂数据类型</h3><p>JavaScript 的复杂数据类型只有一种，即 <strong>Object</strong>。对象则称为<strong>合成类型</strong>（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>JavaScript 中的字符串是一串表示文本值的<strong>不可变</strong>的字符序列，JavaScript 的字符串使用** String 对象**来表示。声明 JavaScript 字符串语法：</p><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>JavaScript 中的数字可以分为整数和 浮点数 类型，JavaScript 的数字使用 <strong>Number 对象</strong>来表示。JavaScript 的整数还可以分为二进制、八进制、十进制和十六进制形式。<br>进制声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> num1 = <span class="hljs-number">16</span>;<span class="hljs-comment">//10进制</span><br><span class="hljs-keyword">var</span> num2 = <span class="hljs-number">0b1000</span>;<span class="hljs-comment">//2进制</span><br><span class="hljs-keyword">var</span> num3 = <span class="hljs-number">0100</span>;<span class="hljs-comment">//8进制，严格模式下不允许使用</span><br><span class="hljs-keyword">var</span> num4 = <span class="hljs-number">0x1</span>;<span class="hljs-comment">//16进制</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num2)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num3)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num4)<br></code></pre></td></tr></table></figure><p><a href="code/type_num.html">代码运行</a></p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>JavaScript 的浮点数使用 <strong>Number 对象</strong>来表示。JavaScript 的浮点数有两种表现形式，第一种就是用普通的<strong>小数表示法</strong>、第二种就是使用<strong>科学计数法</strong>。</p><h3 id="数字范围"><a href="#数字范围" class="headerlink" title="数字范围"></a>数字范围</h3><p>JavaScript 数字的最大值和最小值都可以使用 Number 里面的常量值来获取。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">//最大值</span><br><span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_VALUE</span><br><span class="hljs-comment">//最小值</span><br><span class="hljs-title class_">Number</span>.<span class="hljs-property">MIN_VALUE</span><br><span class="hljs-comment">//无穷大</span><br><span class="hljs-title class_">Infinity</span><br><span class="hljs-comment">//无穷小</span><br>-<span class="hljs-title class_">Infinity</span><br></code></pre></td></tr></table></figure><p><a href="code/type_num2.html">代码运行</a></p><h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><p>JavaScript 中 NaN 属性是代表非数字值的特殊值，该属性用于指示某个值不是 数字。可以把 Number 对象设置为该值，来指示其不是数字值。<br>NaN 与任何值都不相等，包括其本身。也就是说<strong>NaN&#x3D;&#x3D;NaN是false</strong><br>同时将一个<strong>非数字</strong>的变量转为<strong>数字</strong>，会返回NaN<br><strong>isNaN函数</strong>：用于判断传入的 变量 是否不是一个 数字，如果是一个数字，则返回 false，否则，返回 true。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> num = <span class="hljs-string">&quot;string&quot;</span>;<br><span class="hljs-keyword">var</span> numStr = <span class="hljs-string">&quot;123&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>(num));<span class="hljs-comment">//num无法转换为数字，返回NaN</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span>==<span class="hljs-title class_">NaN</span>);<span class="hljs-comment">//NaN不等于任何，包括自身，返回false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(numStr));<span class="hljs-comment">//numStr可以转换成数字，返回false</span><br></code></pre></td></tr></table></figure><p><a href="code/type_NaN.html">代码运行</a></p><h3 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h3><p>JavaScript 中的 true 在内部存储的值是 1，JavaScript 中的 false 在内部存储的值是 0。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">true</span> == <span class="hljs-number">1</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">false</span> == <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p><a href="code/type_bool.html">代码运行</a></p><h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3><p>JavaScript 中的 Undefined 表示 变量 <strong>未定义时</strong>的属性，当<strong>读取不存在</strong>的 对象 属性时会返回 undefined。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> t1 = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">//声明变量并赋值</span><br><span class="hljs-keyword">var</span> t2;<span class="hljs-comment">//之声明未赋值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(t1 == underfined);<span class="hljs-comment">//false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(t2 == underfined);<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p><a href="code/type_undefined.html">代码运行</a></p><h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><p>JavaScript 中的 null 是一个表明 null 值的特殊 关键字。 JavaScript 是大小写敏感的，因此 null 与 Null、NULL 或变体完全不同。<br>JavaScript 中的 null 是可以进行比较的，即 null 等于 null。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> t1 = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">//赋值空字符串</span><br><span class="hljs-keyword">var</span> t2 ;<span class="hljs-comment">//不赋值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(t1 == <span class="hljs-literal">null</span>)<span class="hljs-comment">//false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(t2 == <span class="hljs-literal">null</span>)<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p><a href="code/type_null.html">代码运行</a></p><h3 id="null与undefined"><a href="#null与undefined" class="headerlink" title="null与undefined"></a>null与undefined</h3><p>JavaScript 中的 null 是 js 中的 关键字，表示<strong>空值</strong>，null 可以看作是 <strong>was object</strong> 的一个特殊的值，如果一个 object 值为空，表示这个对象不是有效 对象。<br>undefined 不是 js 中的关键字，其是一个 <strong>全局变量</strong>，是 <strong>Global</strong> 的一个属性。<br><strong>相同点</strong>：都是原始类型的值，保存在栈中变量本地。<br><strong>不同</strong>：</p><ol><li>JavaScript null 与 undefined 类型 不一样。</li><li>转化为值时不一样，undefined 为 NaN ,null 为 0。<br><strong>返回underfined的情况</strong>：</li><li>使用了一个未定义的变量。</li><li>使用了已定义但未声明的变量。</li><li>使用了一个对象属性，但该属性不存在或者未赋值。</li><li>调用 函数 时，该提供的参数没有提供。</li><li>函数没有返回值时，默认返回 undefined。</li></ol><h3 id="Symbol类型"><a href="#Symbol类型" class="headerlink" title="Symbol类型"></a>Symbol类型</h3><p>JavaScript 中的 Symbol 是 ECMAScript 6 中新添加的 类型，是一种实例是唯一且不可改变的数据类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> v1 = <span class="hljs-title class_">Symbol</span>();<span class="hljs-comment">//声明Symbol变量</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;v1 = &quot;</span>,v1);<span class="hljs-comment">//返回Symbol()</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;typeof(v1) = &quot;</span>,<span class="hljs-title function_">typeof</span>(v1));<span class="hljs-comment">//v1的类型为symbol</span><br></code></pre></td></tr></table></figure><p><strong>而且每个Symbol()变量都是唯一的</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> v2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">var</span> v3 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;v1==v2:&quot;</span>v1 ==v2);<span class="hljs-comment">//false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;v2==v3:&quot;</span>,v2 == v3);<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p>同时也正因为这个性质，可以用作对象属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROP_NAME</span> = <span class="hljs-title class_">Symbol</span>();         <span class="hljs-comment">//声明常量，下同</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROP_AGE</span>  = <span class="hljs-title class_">Symbol</span>();<br><span class="hljs-keyword">var</span> obj = &#123;                         <span class="hljs-comment">//声明名为obj的对象</span><br>    [<span class="hljs-variable constant_">PROP_NAME</span>]:<span class="hljs-string">&quot;HaiCoder&quot;</span> ,        <span class="hljs-comment">//使用PROP_NAME的值作为属性名，下同</span><br>    [<span class="hljs-variable constant_">PROP_AGE</span>] : <span class="hljs-number">109</span><br>&#125;;<br>arr = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(obj);<span class="hljs-comment">//获取obj中symbol类型的属性，放入数组</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;arr = &quot;</span>,arr);<span class="hljs-comment">//&#123;Symbol(),Symbol()&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;arr[0] = &quot;</span>,arr[<span class="hljs-number">0</span>]);<span class="hljs-comment">//Symbol()</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;arr[1] = &quot;</span>,arr[<span class="hljs-number">0</span>]);<span class="hljs-comment">//Symbol()</span><br></code></pre></td></tr></table></figure><p><a href="code/type_symbol.html">代码运行</a></p><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><table><tr><td><strong>toString</strong></td><td>转换成字符串类型</td><td>x.ToString()</td></tr><tr><td>String</td><td>转换成字符串类型</td><td>String(x)</td></tr><tr><td><strong>Number</strong></td><td>转换成数字类型</td><td>Number(x)</td></tr><tr><td><strong>parseInt</strong></td><td>转换成整数类型</td><td>x.parseInt()</td></tr><tr><td><strong>parseFloat</strong></td><td>转换成浮点数类型</td><td>x.parseFloat()</td></tr><tr><td><strong>Boolean</strong></td><td>转换成布尔类型</td><td>Boolean(x)</td></tr></table>#### 转字符串<p>将特定的<strong>数据类型</strong>的<strong>变量</strong>转成<strong>字符串类型</strong>可以使用toString（）和String方法。有些数据类型没有toString（）方法，比如undefined和null，这时候需要用string方法</p><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">x.<span class="hljs-title function_">toString</span>();<span class="hljs-comment">//将变量x转换成字符串类型。返回转换成功后的字符串</span><br><span class="hljs-title function_">string</span>(x);<span class="hljs-comment">//将变量x转换成字符串类型。</span><br></code></pre></td></tr></table></figure><h4 id="转数字"><a href="#转数字" class="headerlink" title="转数字"></a>转数字</h4><p>将特定的<strong>数据类型</strong>的<strong>变量</strong>转成<strong>数字类型</strong>可以使用Number（）和parseInt（）方法</p><p>基本语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(x，radix);<span class="hljs-comment">//将变量 x 转换成数字类型。返回转换成功后的指定进制数字，进制范围【2，36】</span><br><span class="hljs-title class_">Number</span>(x);<span class="hljs-comment">//将变量 x 转换成数字类型。</span><br></code></pre></td></tr></table></figure><p>同时转换规则两者也有一定的差别：</p><p>当Number遇到无法转换成的字符串比如“123b“会返回NaN,而parseInt则会转换到无法转换为止，即返回123，当radix参数超过范围时，返回NaN</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;123b&quot;</span>;<br><span class="hljs-keyword">var</span> strToNum1 = <span class="hljs-built_in">parseInt</span>(str,<span class="hljs-number">10</span>);<br><span class="hljs-keyword">var</span> strToNum2 = <span class="hljs-built_in">parseInt</span>(str,<span class="hljs-number">37</span>);<br><span class="hljs-keyword">var</span> strToNum3 = <span class="hljs-title class_">Number</span>(str);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;parseInt(str,10) = &quot;</span>,strToNum1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;parseInt(str,37) = &quot;</span>,strToNum2);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Number(str) = &quot;</span>,strToNum3);<br></code></pre></td></tr></table></figure><p><a href="code/transfer_toNumber.html">代码运行</a><br>与parseInt类似的还有parseFloat()</p><h4 id="转布尔"><a href="#转布尔" class="headerlink" title="转布尔"></a>转布尔</h4><p> 将<strong>其他类型</strong>转<strong>布尔</strong>使用<strong>Boolean函数</strong>。规则如下：</p><table><thead><tr><th>类型</th><th>规则</th></tr></thead><tbody><tr><td>Number</td><td>0为false，非0true</td></tr><tr><td>string</td><td>空为false，其他true</td></tr><tr><td>null</td><td>false</td></tr><tr><td>underfined</td><td>false</td></tr></tbody></table><h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><ol><li>当以函数的形式调用时， this是window。</li><li>当以方法的形式调用时， 谁调用方法this就是谁。</li><li>当以构造函数的形势调用时， this就是新创建的对象。</li></ol><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><h3 id="三种方式"><a href="#三种方式" class="headerlink" title="三种方式"></a>三种方式</h3><p>通常可以有三种显示方法，即：以对话框的形式弹出信息、输出文本到浏览器显示和输出文本到浏览器的控制台。<br>以对话框的形式弹出信息我们使用 <strong>window.alert()</strong> 方法，输出文本到浏览器显示我们可以使用<strong>document.write()</strong> 和 <strong>innerHTML</strong> 方法，输出文本到浏览器的控制台我们使用 <strong>console.log()</strong> 方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;html&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">//alert() 方法用于显示带有一条指定消息和一个确认按钮的警告框。</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;警告消息&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">//document.write() 方法可向文档写入 HTML 表达式或 JavaScript 代码。同时，一次可列出多个 参数(exp1,exp2,exp3,…) ，并将按顺序被追加到文档中。</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;文本1&quot;</span>,<span class="hljs-string">&quot;文本2&quot;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">//console.log() 方法用于向控制台输出一条消息。支持 C 语言 printf 式的格式化输出。当然，也可以不使用格式化输出来达到同样的目的。</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;console&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">setInnerHTML</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-comment">//innerHTML 属性设置或返回表格行的开始和结束标签之间的 HTML,tablerowObject.innerHTML=文本;</span></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;test&quot;</span>).<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;&lt;strong&gt;设置标签的html内容&quot;</span>;<span class="hljs-comment">//将id为test的标签内容替换为指定内容</span></span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span>原始内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>.</span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;setInnerHTML()&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;点击&quot;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><a href="code/output.html">代码运行</a></p><h3 id="alert"><a href="#alert" class="headerlink" title="alert"></a>alert</h3><p>显示带有一条指定消息和一个确认按钮的警告框。对话框是一个模态窗口，它能<strong>阻止用户对浏览器窗口界面的其他部位进行操作</strong>。参数是要显示在对话框中的文本字符串，如果传入其他类型的值，会<strong>转换成字符串</strong>。</p><h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><p>在 JavaScript 中 document.write() 方法可向文档写入 HTML 表达式或 JavaScript 代码。同时，一次可列出多个参数(exp1,exp2,exp3,…) ，并将按顺序被追加到文档中。<br>虽然根据 DOM 标准，该方法只接受单个 字符串 作为 参数。不过根据经验，write() 可接受任何多个参数。<br>我们通常按照两种的方式使用 write() 方法：一是在使用该方法<strong>在文档中输出 HTML</strong>，另一种是在调用该方法的的<strong>窗口之外的窗口、框架中产生新文档</strong>。在第二种情况中，请<strong>务必使用 close() 方法</strong>来关闭文档。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>使用 JavaScript 的 document.write输出文本<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;嗨客网(www.haicoder.net)&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">111</span>,<span class="hljs-string">&quot;&lt;br&gt;&quot;</span>,<span class="hljs-number">222</span>);</span></span><br><span class="language-javascript"><span class="language-xml">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h3><p>用于设置或返回表格行的开始和结束标签之间的 HTML。</p><h3 id="console方法"><a href="#console方法" class="headerlink" title="console方法"></a>console方法</h3><p> 方法用于向控制台输出一条消息。同时支持 C 语言 printf 式的格式化输出。当然，也可以不使用格式化输出来达到同样的目的。<br><strong>console.log()系列方法</strong></p><table><tr><td>console.log</td><td>向控制台输出一条消息。</td></tr><tr><td>console.debug</td><td>向控制台输出一条信息，它包括一个指向该行代码位置的超链接。</td></tr><tr><td>console.info</td><td>向控制台输出一条信息，该信息包含一个表示“信息”的图标，和指向该行代码位置的超链接。</td></tr><tr><td>console.warn</td><td>同 info。区别是图标与样式不同。</td></tr><tr><td>console.error</td><td>同 info。区别是图标与样式不同。error 实际上和 throw new Error() 产生的效果相同，使用该语句时会向浏览器抛出一个 js 异常。</td></tr><tr><td>console.assert</td><td>断言，测试一条表达式是否为真，不为真时将抛出异常（断言失败）。</td></tr></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;log消息&quot;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">debug</span>(<span class="hljs-string">&quot;debug消息&quot;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&quot;info消息&quot;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&quot;warm消息&quot;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">assert</span>()<span class="hljs-comment">//为空，返回failed</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;assert断言false,返回failed&quot;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">assert</span>(<span class="hljs-string">&quot;不为空&quot;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;assert断言true则不作显示&quot;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;error消息&quot;</span>)<br></code></pre></td></tr></table></figure><p><a href="code/output_console.html">代码运行</a></p><h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>在 JavaScript 中函数及变量的声明都将被提升到函数的最顶部。因此，在 JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。</p><p>变量提升的本质其实是由于 js 引擎在编译的时候，就将所有的变量声明了，因此在执行的时候，所有的变量都已经完成声明。</p><p>当有多个同名变量声明的时候，函数声明会覆盖其他的声明。如果有多个函数声明，则是由最后的一个函数声明覆盖之前所有的声明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//先使用后声明</span><br>a = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">var</span> a;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br></code></pre></td></tr></table></figure><p><a href="code/Hoisting.html">代码运行</a><br>JavaScript 会将当前作用域的所有变量的声明提升到程序的顶部。如果修改如下，则会报错underfined,因为只有声明会被提升，赋值则不会。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br><span class="hljs-keyword">var</span> a;<br>a = <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><p><a href="code/Hoisting2.html">代码运行</a><br>当函数与变量同名时，函数的优先级更高</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">fun</span>();<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;fun函数被执行&quot;</span>)<br>&#125;<br><span class="hljs-keyword">var</span> fun;<br></code></pre></td></tr></table></figure><p><a href="code/Hoisting3.html">代码运行</a><br>可以看见函数被正常调用。如果是多个同名函数，则取后面的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;fun1&quot;</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;fun2&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="code/Hoisting4.html">代码运行</a><br>现在将代码修改如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">fun;<br><span class="hljs-keyword">var</span> fun = <span class="hljs-title function_">funtion</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;函数被调用&quot;</span>);<br>&#125;<br><span class="hljs-keyword">var</span> fun;<br></code></pre></td></tr></table></figure><p><a href="code/Hoisting5.html">代码运行</a><br>结果是“fun not a function”,这是因为”var fun &#x3D; function(){}”是一个变量声明赋值语句，var fun也是，两个同名变量取后者，因此fun是undefined</p><h2 id="var-let和const"><a href="#var-let和const" class="headerlink" title="var,let和const"></a>var,let和const</h2><p>var和let都是用于声明变量的关键字，但存在一定差异：<br>var 定义变量，没有块的概念，可以<strong>跨块访问</strong>，不能跨<strong>函数</strong>访问，不初始化出现<strong>undefined</strong>，不会报错。<br>let 定义变量，只能在<strong>块作用域里</strong>访问，也<strong>不能</strong>跨函数访问，对函数外部无影响。<br>const 定义常量，只能在<strong>块作用域里</strong>访问，也<strong>不能</strong>跨函数访问，使用时<strong>必须初始化</strong>(即必须赋值)，而且<strong>不能修改</strong>。(这点有点特殊，后面讲)</p><p>var声明的变量作用域在整个函数范围内，或者全局：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;  <span class="hljs-comment">//在if中声明变量</span><br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)  <span class="hljs-comment">//if外访问变量，但仍在函数中</span><br>&#125;<br></code></pre></td></tr></table></figure><p><a href="code/var.html">运行代码</a><br>结果是函数可以正常运行打印出a，说明var声明变量作用域是整个函数<br>如果换成let:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-string">&quot;out&quot;</span>;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-string">&quot;in&quot;</span>;  <span class="hljs-comment">//在if中声明变量</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;if-a:&quot;</span>,a);<span class="hljs-comment">//访问if中的变量</span><br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;fun-a:&quot;</span>,a);  <span class="hljs-comment">//访问if外的变量</span><br>&#125;<br><span class="hljs-title function_">fun</span>();<br></code></pre></td></tr></table></figure><p><a href="code/let.html">代码运行</a><br>const与let类似。<br>以及var可以声明相同变量，而let只能声明一次<br>最后关于const不能修改这点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">10</span>;<br>a = <span class="hljs-number">100</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br></code></pre></td></tr></table></figure><p>当const声明的是一个简单类型时，是不能修改的，会报错。<br>但如果声明的是一个复杂类型（一般是对象和数组），则会出现不同的地方。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>a[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br></code></pre></td></tr></table></figure><p>没报错，数组被修改。这是为什么呢？<br>这是因为，const保证的其实是a指向的内存地址不改变，而不是该内存地址的内容不改变。简单类型其实就是常量，无法修改，想改变a的值只能重新指向新地址，但对于数组，他的值改变了，但地址并不会改变，也就不会引起a指向的改变。</p><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>ECMAScript 5 的严格模式是采用具有限制性 JavaScript 变体的一种方式，从而使代码显示地脱离 “马虎模式&#x2F;稀松模式&#x2F;懒散模式“（sloppy）模式。</p><p>在 JavaScript 中，我们要开启严格模式，只需要使用 use strict 指令即可。<br>语法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">use strict;<br></code></pre></td></tr></table></figure><p>放在代码顶部，也可放在函数前，只对函数生效，但一般是全局形式。它不是一条语句，是一个字面量表达式，在 JavaScript 旧版本中会被忽略。<br><strong>为什么使用严格模式</strong></p><ul><li>消除 JavaScript 语法的一些不合理、不严谨之处，减少一些怪异行为。</li><li>消除代码运行的一些不安全之处，保证代码运行的安全。</li><li>提高编译器效率，增加运行速度。</li><li>为未来新版本的 JavaScript 做好铺垫。</li><li>“严格模式” 体现了 JavaScript 更合理、更安全、更严谨的发展方向，包括 IE 10 在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。</li><li>另一方面，同样的代码，在 “严格模式” 中，可能会有不一样的运行结果；一些在 “正常模式” 下可以运行的语句，在 “严格模式” 下将不能运行。掌握这些内容，有助于更细致深入地理解 JavaScript，让你变成一个更好的程序员。</li><li>严格模式通过抛出错误来消除了一些原有静默错误。</li><li>严格模式修复了一些导致 JavaScript 引擎难以执行优化的缺陷：有时候，相同的代码，严格模式可以比非严格模式下运行得更快。</li><li>严格模式禁用了在 ECMAScript 的未来版本中可能会定义的一些语法。<br><strong>严格模式的限制</strong></li><li>不允许使用未声明的 变量。</li><li>不允许删除变量或 对象。</li><li>不允许删除 函数。</li><li>不允许变量重名。</li><li>不允许使用八进制。</li><li>不允许使用 转义字符。</li><li>不允许对只读属性赋值。</li><li>不允许对一个使用 getter 方法读取的属性进行赋值。</li><li>不允许删除一个不允许删除的属性。</li><li>变量名不能使用 “eval” 字符串。</li><li>变量名不能使用 “arguments” 字符串。</li><li>由于一些安全原因，在作用域 eval() 创建的变量不能被调用。</li><li>禁止 this 关键字指向全局对象。</li></ul><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>其他懒得写，写不同的地方就好</p><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p>不同点就是”&#x3D;&#x3D;&#x3D;“和”！&#x3D;&#x3D;“两个运算符，三等号表示等值等型，！&#x3D;&#x3D;表示不等值或不等型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> num = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;1&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;num === str :&quot;</span>,num === str );<span class="hljs-comment">//false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;num !== str :&quot;</span>,num !== str);<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p><a href="code/===.html">代码运行</a></p><h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><p>js支持三目运算符，和三目嵌套</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> retValue = a &gt; b ? (a &gt; c ? a : c)  : (b &gt; c ? b : c);<br><span class="hljs-comment">//比较三数最大值</span><br></code></pre></td></tr></table></figure><h2 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h2><p>在 JavaScript 中，获取用户输入的数据使用 <strong>prompt</strong> 方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title function_">prompt</span>(text, defaultText)<br><span class="hljs-comment">//text可选。提示信息，不是HTML格式。</span><br><span class="hljs-comment">//default可选。默认的输入文本。(一开始自动填入)</span><br></code></pre></td></tr></table></figure><p>返回值：如果用户单击提示框的取消按钮，则返回 null。如果用户单击确认按钮，则返回输入字段当前显示的文本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> a = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;输入名字:&quot;</span>,<span class="hljs-string">&quot;张三&quot;</span>);<br><span class="hljs-title function_">alert</span>(a);<br></code></pre></td></tr></table></figure><p><a href="code/prompt.html">代码运行</a><br>再用户输入时，会暂停对js代码的进行。</p><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><p>if、elseif、while、for、switch等都与C语言一样，但js的for可以用for in语句，可以用于遍历 <strong>数组</strong> 的每一个<strong>元素</strong>或者用于遍历获取 <strong>对象</strong> 的每一个<strong>属性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> boj)&#123;<br>  code...<br>&#125;<br></code></pre></td></tr></table></figure><p>当使用 for in 循环遍历数组时，那么参数 i 是<strong>数组</strong>的<strong>索引</strong>，而不是数组的元素。当使用 for in 循环遍历<strong>对象</strong>时，那么参数 variable 是对象的<strong>属性</strong>。<br><strong>break</strong>语句：js的break与C类似，但js可以指定中断的循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-attr">loop</span>:<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = startIndex; i &lt; endIndex; i++)&#123;<br>    <span class="hljs-comment">//do something</span><br>    <span class="hljs-keyword">if</span> (condition) &#123;<br>        <span class="hljs-keyword">break</span> loop<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里loop是标签，后接“：”<br><strong>continue</strong>也有一样的用法</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h2><p>JavaScript 的函数可以分为：自定义函数和系统函数。<br>JavaScript 的函数也支持普通函数、<strong>匿名函数</strong> 和 <strong>闭包</strong> 三种形式。<br>js的函数声明不需要写返回值类型，定义参数也不需要声明类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">a</span>) &#123;<br>  <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数参数默认值"><a href="#函数参数默认值" class="headerlink" title="函数参数默认值"></a>函数参数默认值</h2><p>如果我们在调用函数时没有输入参数，则使用我们定义的默认参数的值。函数的默认参数必须放在函数参数列表的<strong>最后</strong>，且默认参数可以是任意多个。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun1</span>(<span class="hljs-params">name, year=<span class="hljs-number">20</span></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(year);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun2</span>(<span class="hljs-params">name=<span class="hljs-string">&quot;张三&quot;</span>, year=<span class="hljs-number">20</span></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(year);<br>&#125;<br><span class="hljs-title function_">fun1</span>(<span class="hljs-string">&quot;lihua&quot;</span>);<br><span class="hljs-title function_">fun2</span>();<br></code></pre></td></tr></table></figure><p><a href="code/funtion.html">代码运行</a></p><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><p>在 JavaScript 中，<strong>arguments</strong> 对象是比较特别的一个 <strong>对象</strong>，实际上是<strong>当前 函数</strong> 的一个<strong>内置属性</strong>。也就是说<strong>所有</strong>函数都内置了一个 arguments 对象。<br>arguments 对象中<strong>存储了传递的所有的 实参</strong>，arguments 是一个 <strong>伪数组</strong>（本质还是对象），因此可以进行遍历。<br>argument常用方法</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>arguments.callee</td><td>arguments 所在的函数，指向当前执行的函数</td></tr><tr><td>arguments.caller</td><td>指向调用当前函数的函数</td></tr><tr><td>arguments.length</td><td>获得长度，实参的个数</td></tr><tr><td>arguments[i]</td><td>通过遍历索引，获得每个实参</td></tr></tbody></table><h2 id="函数变量"><a href="#函数变量" class="headerlink" title="函数变量"></a>函数变量</h2><p>在js中<strong>函数</strong>也是一种<strong>数据类型</strong>，可以和其他类型一样，<strong>保存在变量中</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">123</span>);<br>&#125;<br><span class="hljs-keyword">var</span> f = <span class="hljs-title function_">fun</span>();<br><span class="hljs-title function_">f</span>();<br></code></pre></td></tr></table></figure><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>匿名函数就是不写函数名的函数，往往赋值给变量。匿名函数的调用方法有四种</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">//赋值后调用</span><br><span class="hljs-keyword">var</span> f = <span class="hljs-title function_">funtion</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-comment">//赋值给变量</span><br>  ...<br>&#125;<br><span class="hljs-title function_">f</span>();<span class="hljs-comment">//调用函数</span><br><br><span class="hljs-comment">//小括号直接调用</span><br><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  ...<br>&#125;(实参列表);<br><br><span class="hljs-comment">//在事件中调用</span><br><span class="hljs-keyword">let</span>  btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;btn&quot;</span>);  <span class="hljs-comment">// 找到页面某个标签</span><br>btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;   <span class="hljs-comment">// 添加事件</span><br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&quot;你点了我！&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//通过对象调用</span><br><span class="hljs-keyword">let</span> myObj = &#123;   <span class="hljs-comment">//声明对象</span><br>     name : <span class="hljs-string">&quot;HaiCoder&quot;</span>,<br>     <span class="hljs-attr">sayHai</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&quot;Hello,&quot;</span>+ <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> );<br>     &#125;<br>&#125;;<br>myObj.<span class="hljs-title function_">sayHai</span>();<br></code></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包就是一个 函数 和与其相关的引用环境组合的一个整体。<br>在 JavaScript 中闭包是引用了 <strong>自由变量</strong> 的函数，被引用的自由变量和函数一同存在，即使已经离开了自由变量的环境也不会被释放或者删除，在闭包中可以继续使用这个自由变量。<br>闭包（Closure）在某些编程语言中也被称为 Lambda 表达式<br>在 JavaScript 中，被捕获到闭包中的变量让闭包本身拥有了记忆效应，闭包中的逻辑可以修改闭包捕获的变量，变量会跟随闭包生命期一直存在，闭包本身就如同变量一样拥有了记忆功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>)&#123;<br>  a = <span class="hljs-number">20</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) &#123;<br>    a+=x;<br>    <span class="hljs-keyword">return</span> a;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> f = <span class="hljs-title function_">add</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">f</span>(<span class="hljs-number">1</span>));<span class="hljs-comment">//21</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">f</span>(<span class="hljs-number">2</span>));<span class="hljs-comment">//23</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">f</span>(<span class="hljs-number">3</span>));<span class="hljs-comment">//26</span><br></code></pre></td></tr></table></figure><p><a href="code/closure.html">代码运行</a></p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域有全局、局部、和块级。任意一对花括号中的语句都属于一个块。</p><h3 id="js词法规则"><a href="#js词法规则" class="headerlink" title="js词法规则"></a>js词法规则</h3><ul><li>函数允许访问函数外的数据</li><li>整个代码结构中只有函数可以限定作用域</li><li>作用域规则首先使用提升规则分析</li><li>如果当前作用规则中有名字了, 就不考虑外面的名字</li></ul><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>只有函数可以制造作用域结构， 那么只要是代码，就至少有一个作用域，即全局作用域。凡是代码中有函数，那么这个函数就构成另一个作用域。如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域。</p><p>将这样的所有的作用域列出来，可以有一个结构: 函数内指向函数外的链式结构。就称作作用域链。</p><h1 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h1><h2 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h2><p>在 JavaScript 中要想获取字符串长度只需要使用字符串的 <strong>length 属性</strong>即可。JavaScript 获取字符串长度语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">str.<span class="hljs-property">length</span>;<br></code></pre></td></tr></table></figure><h2 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h2><p>在 JavaScript 中，截取字符串有三种方法，分别为：使用 <strong>substring 函数</strong>、<strong>使用 substr 函数</strong>和<strong>使用 slice 函数。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;helloworld&quot;</span>;<br><span class="hljs-keyword">var</span> str0_5 = str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>,<span class="hljs-number">6</span>);<span class="hljs-comment">//提取两个0到5的字符，省略结尾则截取到结束</span><br><span class="hljs-keyword">var</span> str1_6 = str.<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>);<span class="hljs-comment">//从1位置开始，取长度为6的字符串。如果起始下标是负数则从尾部开始，长度省略则到结束</span><br><span class="hljs-keyword">var</span> str2_5 = str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>,<span class="hljs-number">6</span>);<span class="hljs-comment">//提取2到6的字符，可以为负数，省略结尾则截取到结束</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;substring&quot;</span>,str0_5);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;substr&quot;</span>,str1_6);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;slice&quot;</span>,str2_5);<br></code></pre></td></tr></table></figure><p><a href="code/string.html">代码运行</a><br>substring和slice的区别：</p><ol><li>slice接受负数，表示从结尾算起</li><li>substring如果结束位置在起始位置之前，会自动调整，而参数小于0时按0处理</li></ol><h2 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h2><p>JavaScript 拼接 字符串 有两种方法，分别是：使用 + 号拼接和使用 **join **函数 拼接。<br>加号直接加就好，join语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> arr  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>();<span class="hljs-comment">//声明数组</span><br><span class="hljs-keyword">var</span> str1 = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-keyword">var</span> str2 = <span class="hljs-string">&quot;World&quot;</span>;<br>arr.<span class="hljs-title function_">push</span>(str1);<span class="hljs-comment">//push方法将字符串存储数组中</span><br>arr.<span class="hljs-title function_">push</span>(str2);<br><span class="hljs-keyword">var</span> str = arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//调用数组的join方法拼接，参数为分隔字符</span><br></code></pre></td></tr></table></figure><p><a href="code/string2.html">代码运行</a></p><h2 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h2><p>注意分隔和截取的区别<br>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">stringObject.<span class="hljs-title function_">split</span>(separator,howmany);<br></code></pre></td></tr></table></figure><p>separator为必填，表示从该参数指定的地方开始分隔，可以<strong>填字符串或正则表达</strong>式。<br>howmany表示<strong>返回数组</strong>的<strong>最大长度</strong>，如果不填则整个字符串都会被分隔<br>返回值：一个<strong>字符串数组</strong>，返回的数组中的字串不包括 separator 自身。<br>但是，如果 separator 是包含子表达式的 正则表达式，那么 返回 的数组中包括与这些子表达式匹配的字串（但不包括与整个正则表达式匹配的文本）。</p><p><strong>说明：如果把“”空字符串做spearator做参数，则每个字符都被分隔</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;www.baidu.com&quot;</span>;<br><span class="hljs-keyword">var</span> strs = str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(strs);<br></code></pre></td></tr></table></figure><p><a href="code/string3.html">代码运行</a></p><h2 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h2><p>在一个字符串中查找另一个字符串有四种方法，分别为：使用 <strong>indexOf</strong> 函数、使用 <strong>lastIndexOf</strong> 函数、使用 <strong>match</strong> 函数和使用 <strong>search</strong> 函数。</p><h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h3><p>indexOf() 方法可 返回 某个指定的字符串在源字符串<strong>中首次出现</strong>的位置。如果没有则返回<strong>-1</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">stringObject.<span class="hljs-title function_">indexOf</span>(searchvalue,fromindex)<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>searchvalue</td><td>必需。规定需检索的字符串值。</td></tr><tr><td>fromindex</td><td>可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。如省略该参数，则将从字符串的首字符开始检索。</td></tr></tbody></table><h3 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h3><p>lastIndexOf() 方法可返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。如果找到一个 searchvalue，则返回 <strong>searchvalue 的第一个字符在 stringObject 中的位置。</strong><br>用法同上</p><h2 id="正则表达式匹配字符"><a href="#正则表达式匹配字符" class="headerlink" title="正则表达式匹配字符"></a>正则表达式匹配字符</h2><p>在一个 字符串 中使用正则表达式去匹配查找另一个字符串有两种方法，分别为：使用 match 函数和使用 search 函数。</p><h3 id="match（）"><a href="#match（）" class="headerlink" title="match（）"></a>match（）</h3><p>match() 方法可在字符串内检索指定的值，或找到<strong>一个或多个</strong>正则表达式的匹配。该方法类似 indexOf() 和 lastIndexOf()，但是它 <strong>返回 指定的值</strong>，而<strong>不是</strong>字符串的<strong>位置</strong>。返回个数取决于是否启用<strong>全局检索</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;hheelloohehehe&quot;</span>;<br><br><span class="hljs-comment">//查找字符串</span><br><span class="hljs-keyword">var</span> str1 = str.<span class="hljs-title function_">match</span>(<span class="hljs-string">&quot;he&quot;</span>);<br><br><span class="hljs-comment">//使用正则表达式</span><br><span class="hljs-keyword">var</span> str2 = str.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/he/</span>);<br><br><span class="hljs-comment">//g全局模式</span><br><span class="hljs-keyword">var</span> str3 = str.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/he/g</span>);<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str1);<br> <span class="hljs-comment">//[ &#x27;he&#x27;, index: 1, input: &#x27;hheelloohehehe&#x27;, groups: undefined ]</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str2);<br> <span class="hljs-comment">//[ &#x27;he&#x27;, index: 1, input: &#x27;hheelloohehehe&#x27;, groups: undefined ]</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str3);<br> <span class="hljs-comment">//[ &#x27;he&#x27;, &#x27;he&#x27;, &#x27;he&#x27;, &#x27;he&#x27; ]</span><br></code></pre></td></tr></table></figure><p><a href="code/string4.html">代码运行</a></p><h3 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h3><p>search()于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。返回匹配子串的起始位置，没有则-1.<br>search不支持全局模式，但有忽略大小写模式‘i’</p><h2 id="访问字符串字符"><a href="#访问字符串字符" class="headerlink" title="访问字符串字符"></a>访问字符串字符</h2><p>在 JavaScript 中要想获取 字符串 中某个下标的字符，有三种方法，分别为：使用 [] 加上下标访问、使用<strong>charAt</strong>函数 访问和使用 <strong>charCodeAt</strong> 函数访问。<br><strong>charAt</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">str.<span class="hljs-title function_">charAt</span>(index);<br></code></pre></td></tr></table></figure><p>返回该索引处的字符，如果越界则返回<strong>undefined</strong></p><p><strong>charCodeAt</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">str.<span class="hljs-title function_">charCodeAt</span>(index);<br></code></pre></td></tr></table></figure><p>如果访问的索引在字符串中，则返回该索引处的字符的<strong>ACSII码</strong>，否则，返回<strong>NaN</strong>。</p><h2 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h2><p>在JavaScript中，在一个 字符串 中将特定的字符串替换为指定的字符串，可以使用 <strong>replace 函数。</strong><br>replace() 函数用来查找匹配一个 正则表达式 的字符串，然后使用新字符串代替匹配的字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">stringObject.<span class="hljs-title function_">replace</span>(regexp/substr,replacement)<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>regexp&#x2F;substr</td><td>必需。规定子字符串或要替换的模式的 RegExp 对象。请注意，如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。</td></tr><tr><td>replacement</td><td>必需。一个字符串值。规定了替换文本或生成替换文本的函数。</td></tr></tbody></table><h2 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h2><p>toLowerCase() 和 toUpperCase。</p><h2 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h2><p>concat() 方法用于连接两个或多个数组或者字符串。该方法<strong>不会改变</strong>现有的数组，而仅仅会 返回 被<strong>连接数组的一个副本。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">arrayObject.<span class="hljs-title function_">concat</span>(arrayX,arrayX,......,arrayX)<br></code></pre></td></tr></table></figure><p><strong>返回值</strong><br>返回一个新的数组。该数组是通过把所有 arrayX 参数添加到 arrayObject 中生成的。如果要进行 concat() 操作的参数是数组，那么添加的是数组中的元素，而不是数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> str1 = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-keyword">var</span> str2 = <span class="hljs-string">&quot;world&quot;</span>;<br><span class="hljs-keyword">var</span> str = str2.<span class="hljs-title function_">concat</span>(str2);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;str1 = &quot;</span>,str1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;str2 = &quot;</span>,str2);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;str = &quot;</span>,str);<br><br><span class="hljs-keyword">var</span> arr1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">3</span>);<br>arr1[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>arr1[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>arr1[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">var</span> arr2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Aray</span>(<span class="hljs-number">3</span>);<br>arr2[<span class="hljs-number">0</span>] = <span class="hljs-number">456</span>;<br>arr2[<span class="hljs-number">1</span>] = <span class="hljs-number">789</span>;<br>arr2[<span class="hljs-number">2</span>] = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">var</span> arr = arr1.<span class="hljs-title function_">concat</span>(arr2);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;arr1:&quot;</span>,arr1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;arr2:&quot;</span>,arr1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;arr:&quot;</span>,arr);<br></code></pre></td></tr></table></figure><p><a href="code/string5.html">代码运行</a></p><h2 id="去除首尾空格"><a href="#去除首尾空格" class="headerlink" title="去除首尾空格"></a>去除首尾空格</h2><p>在 JavaScript 中去除 字符串 的首尾空格，使用** trim 函数<strong>。有些浏览器</strong>不支持** trim 函数，那么我们可以自己通过<strong>replace函数</strong>实现 trim 函数。有的浏览器不支持trim函数，我们可以用repalce函数实现相同的效果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myTrim</span>(<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-keyword">return</span> x.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\s+|\s+$/gm</span>,<span class="hljs-string">&#x27;&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="子串是否存在"><a href="#子串是否存在" class="headerlink" title="子串是否存在"></a>子串是否存在</h2><p>可以使用字符串查找的方法，也可以使用<strong>includes方法</strong>，如果有则返回true，否则返回false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">str.<span class="hljs-title function_">includes</span>(searchvalue, start);<br></code></pre></td></tr></table></figure><p>参数为查找的子串和起始位置，位置可不写。</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="JavaScript创建数组"><a href="#JavaScript创建数组" class="headerlink" title="JavaScript创建数组"></a>JavaScript创建数组</h2><p>JavaScript 的数组的创建有三种方法，即，使用 new 创建、使用 new 直接创建并实例化和隐式创建。<br><strong>new</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>();<br></code></pre></td></tr></table></figure><p><strong>new创建并实例化</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>隐式创建</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> arr = [];<br></code></pre></td></tr></table></figure><p><strong>隐式创建并初始化</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><h2 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h2><p>除了上部分的创建并初始化，还有几种初始化方式<strong>fill初始化</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(count).<span class="hljs-title function_">fill</span>(item);<br></code></pre></td></tr></table></figure><p>可以将item元素填充满数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">1</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<br></code></pre></td></tr></table></figure><p><a href="code/array.html">代码运行</a></p><h2 id="数组添加元素"><a href="#数组添加元素" class="headerlink" title="数组添加元素"></a>数组添加元素</h2><p>向 JavaScript 的 数组 中添加元素有四种方法，即：直接使用 [] 添加元素、使用 push 添加元素、使用 unshift 添加元素和使用 splice 添加元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">//直接使用下标添加，添加元素可以不紧跟末尾元素</span><br><span class="hljs-keyword">var</span> arr = <span class="hljs-title class_">Array</span>(<span class="hljs-number">10</span>);<br>arr[<span class="hljs-number">12</span>] = <span class="hljs-number">12</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;arr1:&quot;</span>,arr);<br><br><span class="hljs-comment">//向末尾添加一个或多个元素，并返回新长度</span><br><span class="hljs-keyword">var</span> len = arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;arr2:&quot;</span>,arr);<br><br><span class="hljs-comment">//向头部添加一个或多个元素，并返回新长度</span><br><span class="hljs-keyword">var</span> len2 = arr.<span class="hljs-title function_">unshift</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;arr3:&quot;</span>,arr);<br></code></pre></td></tr></table></figure><p><a href="code/array2.html">代码运行</a></p><p><strong>splic详解</strong><br>JavaScript 的 splice() 方法向&#x2F;从数组中添加&#x2F;删除项目，然后<strong>返回被删除的项目</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Arrau</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)<br><span class="hljs-comment">//从下标0开始删除3个元素，并向数组被删除的位置添加新元素9，10</span><br><span class="hljs-comment">//个数写0表示不删除</span><br><span class="hljs-keyword">var</span> del = arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;del:&quot;</span>,del)<span class="hljs-comment">//1 2 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;arr:&quot;</span>,arr)<span class="hljs-comment">//9 10 4 5 </span><br></code></pre></td></tr></table></figure><h2 id="数组删除元素"><a href="#数组删除元素" class="headerlink" title="数组删除元素"></a>数组删除元素</h2><p>从 JavaScript 的 数组 中删除元素有七种方法，即：使用 <strong>length 属性删除</strong>、使用<strong>delete 删除</strong>、使用 <strong>pop 删除</strong>、使用 <strong>shift 删除</strong>、使用 <strong>splice 删除</strong>、使用<strong>迭代方式</strong>删除和使用 <strong>prototype 原型方法删除</strong>。</p><h3 id="length删除"><a href="#length删除" class="headerlink" title="length删除"></a>length删除</h3><p>js的长度是可以修改的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">arr.<span class="hljs-property">length</span> = arr.<span class="hljs-property">length</span> - count;<br></code></pre></td></tr></table></figure><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">delete</span> arr[index];<br></code></pre></td></tr></table></figure><p>删除后<strong>长度不变</strong>，只是被赋值为<strong>undefined</strong></p><h3 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h3><p>JavaScript 中的 Array 对象提供了一个 pop() 栈方法用于弹出并返回数组中的最后一项，某种程度上可以当做删除用。<br>栈数据结构的访问规则是 FILO（First In Last Out，先进后出），栈操作在栈顶添加项，从栈顶移除项，使用pop() 方法，它能移除数组中的<strong>最后一项并返回该项</strong>，并且数组的<strong>长度减 1</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">del = arr.<span class="hljs-title function_">pop</span>();<br></code></pre></td></tr></table></figure><h3 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h3><p>JavaScript 中的 Array 对象提供了一个 shift() 队列方法用于弹出并返回数组中的第一项，某种程度上也可以当做删除用。</p><p>队列数据结构的访问规则是 FIFO（First In First Out，先进先出），队列在列表的末端添加项，从列表的前端移除项，使用 shift() 方法，它能够移除数组中的<strong>第一个项并返回该项</strong>，并且数组的<strong>长度减 1。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">del = arr.<span class="hljs-title function_">shift</span>();<br></code></pre></td></tr></table></figure><h3 id="splic"><a href="#splic" class="headerlink" title="splic"></a>splic</h3><p>在 JavaScript 的 Array 对象中提供了一个 splice() 方法用于对数组进行特定的操作。splice() 恐怕要算最强大的数组方法了，他的用法有很多种，在此只介绍删除数组元素的方法。</p><p>在删除数组元素的时候，它可以删除任意数量的项，只需要指定 2 个参数：要删除的第一项的位置和要删除的项数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">arrayObject.<span class="hljs-title function_">splice</span>(index,howmany,item1,.....,itemX);<br></code></pre></td></tr></table></figure><h2 id="数组查找元素"><a href="#数组查找元素" class="headerlink" title="数组查找元素"></a>数组查找元素</h2><p>使用 indexOf 方法、使用 lastIndexOf 方法、使用 findIndex 方法和使用 find 方法。前2者与string类似</p><h3 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex"></a>findIndex</h3><p>findIndex() 方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置。<br>方法为元素调用函数（回调函数）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">array.<span class="hljs-title function_">findIndex</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">currentValue, index, arr</span>), thisValue);<br></code></pre></td></tr></table></figure><p>作为参数的函数至少要有一个形参：数组元素，另外两个可选参数为下标和数组本身，当函数返回true时，findIndex返回下标，并结束。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">a为元素</span><br><span class="hljs-comment">b为下标</span><br><span class="hljs-comment">c为数组本身</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">a,b,c</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;a = &quot;</span>,a);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;b = &quot;</span>,b);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;c[b] = &quot;</span>,c[b]);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//一直false，便利整个数组</span><br>&#125;<br><span class="hljs-keyword">var</span> arr1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br><span class="hljs-keyword">var</span> index = arr1.<span class="hljs-title function_">findIndex</span>(f)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params">a</span>)&#123;<span class="hljs-comment">//查找等于1的元素的下标</span><br>  <span class="hljs-keyword">return</span> a == <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">var</span> arr2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">var</span> index2 = arr2.<span class="hljs-title function_">findIndex</span>(f2);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index2);<br></code></pre></td></tr></table></figure><p><a href="code/array3.html">代码运行</a></p><p>在findIndex中还有一个可选参数，<strong>“thisValue”</strong>，传递给回调函数的值一般用 “this” 值。如果这个参数为空， “undefined” 会传递给 “this” 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">a</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br>&#125;<br><span class="hljs-keyword">var</span> me = &#123;<span class="hljs-comment">//创建me对象</span><br>  age : <span class="hljs-string">&quot;lh&quot;</span><br>&#125;<br><span class="hljs-keyword">var</span> arr = <span class="hljs-title class_">Array</span>(<span class="hljs-number">3</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">var</span> index = arr.<span class="hljs-title function_">findIndex</span>(f,me);<span class="hljs-comment">//将me对象传递给f函数中的this</span><br></code></pre></td></tr></table></figure><p><a href="code/array4.html">代码运行</a></p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>find和findIndex类似，但返回符合条件的第一个<strong>元素值</strong>，如果没有则返回<strong>undefined</strong>。</p><h2 id="数组元素是否存在"><a href="#数组元素是否存在" class="headerlink" title="数组元素是否存在"></a>数组元素是否存在</h2><p>和string类似，使用includes方法</p><h2 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a>数组长度</h2><p>使用length属性</p><h2 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h2><p>JavaScript 的 数组 的遍历方法有七种，即：使用 <strong>for循环</strong> 遍历、使用 <strong>foreach</strong> 遍历、使用 <strong>for in</strong> 遍历、使用 <strong>for of</strong> 遍历、使用 <strong>keys</strong>方法遍历、使用 <strong>values</strong> 方法遍历和使用 <strong>entries</strong> 方法遍历。</p><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>forEach方法会每个元素调用一次函数（回调函数），使用方法与find类似,也有thisValue参数可选，返回索引</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">array.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">currentValue, index, arr</span>), thisValue);<br></code></pre></td></tr></table></figure><h3 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h3><p>用法类似for in，但for in返回的是下标，for of返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> value <span class="hljs-keyword">of</span> arr)&#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>JavaScript 的 数组 对象内置了 map 方法，可以用来遍历数组.用法类似forEach。为数组的每一个元素调用一个<strong>回调函数</strong>进行处理，处理完成后，将<strong>回调函数的返回值</strong>组成一个<strong>新的数组</strong>,若没有返回值则产生和原数组等长元素为undefined的数组 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">a</span>) &#123;   <span class="hljs-comment">//回调函数</span><br>  <span class="hljs-keyword">return</span> a*<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);<br><span class="hljs-keyword">var</span> newArr = arr.<span class="hljs-title function_">map</span>(f,<span class="hljs-literal">undefined</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr);<br></code></pre></td></tr></table></figure><p><a href="code/array5.html">代码运行</a></p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>JavaScript 的 数组 对象内置了 filter 方法，可以用来遍历数组，为数组的每一个元素调用一个回调函数进行处理，如果数组的元素符合回调函数的要求，那么会将该元素添加到新数组中。用法同上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">a</span>) &#123;   <span class="hljs-comment">//回调函数</span><br>  <span class="hljs-keyword">if</span> (a % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);<br><span class="hljs-keyword">var</span> newArr = arr.<span class="hljs-title function_">map</span>(f,<span class="hljs-literal">undefined</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr);<br></code></pre></td></tr></table></figure><p><a href="code/array6.html">代码运行</a></p><h3 id="every"><a href="#every" class="headerlink" title="every"></a>every</h3><p>用于检测数组中元素是否<strong>都符合条件</strong>，如果有一个不符合则返回false</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">a</span>) &#123;   <span class="hljs-comment">//回调函数</span><br>  <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);<br><span class="hljs-keyword">var</span> isPass = arr.<span class="hljs-title function_">every</span>(f,<span class="hljs-literal">undefined</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(isPass);<br></code></pre></td></tr></table></figure><p><a href="code/array7.html">代码运行</a></p><h3 id="some"><a href="#some" class="headerlink" title="some"></a>some</h3><p>JavaScript 的 数组 对象内置了 some 方法用于检测数组中的元素是否都符合指定条件，如果<strong>只要一个元素</strong>符合指定条件，则返回 true，<strong>所有元素都不符合要求</strong>，则返回 false。<br>同上</p><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>JavaScript 的 数组 对象内置了 reduce 方法用于接收一个 函数 作为累加器，将数组中的每个值（从左到右）开始缩减，最终计算为一个值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">array.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">total, currentValue, currentIndex, arr</span>), initialValue);<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>function(total,currentValue, index,arr)</td><td>必须。数组每个元素需要执行的函数。</td></tr><tr><td>initialValue</td><td>可选。传递给函数的初始值</td></tr></tbody></table><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>total</td><td>必需。初始值, 或者计算结束后的返回值。</td></tr><tr><td>currentValue</td><td>必需。当前元素</td></tr><tr><td>index</td><td>可选。当前元素的索引</td></tr><tr><td>arr</td><td>可选。当前元素所属的数组对象</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">allAdd</span>(<span class="hljs-params">a,b,index</span>)&#123;  <span class="hljs-comment">//将所有值相加</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;index = &quot;</span>,index);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;a = &quot;</span>,a);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;b = &quot;</span>,b);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;a+b = &quot;</span>,a+b);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;------&quot;</span>);<br>  <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);<br><span class="hljs-keyword">var</span> result = arr.<span class="hljs-title function_">reduce</span>(allAdd);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br></code></pre></td></tr></table></figure><p>这样就是将整个数组相加，1+2+3+4+5。而initiaValue可以设置初始值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">.<br>.<br>.<br>...arr.<span class="hljs-title function_">reduce</span>(allAdd,<span class="hljs-number">100</span>);<span class="hljs-comment">//初始值为100</span><br>...<br></code></pre></td></tr></table></figure><p><a href="code/array8.html">代码运行</a><br>这样就是100+(1+2+3+4+5)<br>如果回调函数没有返回值，则每次调用都会将NaN返回</p><h3 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight"></a>reduceRight</h3><p>和reduce用法一样，不过reduceRight是从尾部开始</p><h3 id="keys和values"><a href="#keys和values" class="headerlink" title="keys和values"></a>keys和values</h3><p>JavaScript 的 数组 的 keys() 方法用于从数组<strong>创建一个包含数组键的可迭代对象</strong>，其中 keys 返回 的<strong>迭代器</strong>是<strong>数组的所有的索引</strong>，而不是数组的值。<strong>每个迭代器只能使用一次</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-string">&quot;q&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>);<br><span class="hljs-keyword">var</span> keys = arr.<span class="hljs-title function_">keys</span>();<span class="hljs-comment">//获取keys迭代器</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">of</span> keys) &#123;<span class="hljs-comment">//遍历迭代器，注意for in无法对迭代器使用</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key);<br>&#125;<br></code></pre></td></tr></table></figure><p>JavaScript 的 数组 的 values() 方法用于从数组创建一个包含数组值的可迭代对象，其中 values 返回 的迭代器是<strong>数组的所有的值</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> values = arr.<span class="hljs-title function_">values</span>();<span class="hljs-comment">//获取value迭代器</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> value <span class="hljs-keyword">of</span> keys) &#123;<span class="hljs-comment">//遍历迭代器</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="code/array9.html">代码运行</a></p><h3 id="entire"><a href="#entire" class="headerlink" title="entire"></a>entire</h3><p>JavaScript 的 数组 的 entries() 方法用于从数组创建一个包含数组键和值的可迭代对象，其中 entries 返回 的迭代器包含了数组的所有的键和值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-string">&quot;qe&quot;</span>, <span class="hljs-string">&quot;er&quot;</span>, <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Arr =&quot;</span>, arr);<br><span class="hljs-keyword">var</span> entries = arr.<span class="hljs-title function_">entries</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;entries =&quot;</span>, entries);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> [key, value] <span class="hljs-keyword">of</span> entries)&#123; <span class="hljs-comment">//接受键值对</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Key =&quot;</span>, key, <span class="hljs-string">&quot;Value =&quot;</span>, value);<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="code/array10.html">代码运行</a></p><h2 id="判断是否是数组"><a href="#判断是否是数组" class="headerlink" title="判断是否是数组"></a>判断是否是数组</h2><p>在 JavaScript 中，判断一个 变量 是否是 数组 使用 isArray 方法，如果是数组，则 isArray 返回 true，如果不是数组，则 返回 false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(obj);<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> a = [];<br><span class="hljs-keyword">var</span> b = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> aIsArr = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(a);<br><span class="hljs-keyword">var</span> bIsArr = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(b);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(aIsArr);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bIsArr);<br></code></pre></td></tr></table></figure><h2 id="数组合并"><a href="#数组合并" class="headerlink" title="数组合并"></a>数组合并</h2><p>JavaScript 的 数组 的 concat() 方法用于将多个数组合并成一个数组，并 返回 合并后的数组。此方法并不会改变原来的数组，而仅仅是返回被连接的数组的一个副本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">array1.<span class="hljs-title function_">concat</span>(arr2,arr3...);<br></code></pre></td></tr></table></figure><h2 id="数组转字符串"><a href="#数组转字符串" class="headerlink" title="数组转字符串"></a>数组转字符串</h2><p>JavaScript 的 数组 的 toString() 方法 用于将数组转换为 字符串，同时，使用 toString() 方法将数组转成字符串时，数组的每个元素之间<strong>使用 “,” 分隔。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">array.<span class="hljs-title function_">toString</span>();<br></code></pre></td></tr></table></figure><h2 id="数组连接"><a href="#数组连接" class="headerlink" title="数组连接"></a>数组连接</h2><p>JavaScript 的 数组 的 join() 方法用于将数组的所有元素连接成一个 字符串，同时，使用 join() 方法将数组连接成字符串时，还可以<strong>指定每个元素之间的分隔符。</strong></p><h2 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h2><p>复制数组的一部分数据覆盖到数组的另一个位置。并返回数组，<strong>但是不会改变原数组的长度,会改变顺序</strong>。<strong>返回拷贝过后的数组</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">array.<span class="hljs-title function_">copyWithin</span>(target, start, end);<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>target</td><td>必需。复制到指定目标索引位置。</td></tr><tr><td>start</td><td>可选。元素复制的起始位置。</td></tr><tr><td>end</td><td>可选。停止复制的索引位置 (默认为 array.length)。如果为负值，表示倒数。</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;Golang&quot;</span>, <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;JavaScript&quot;</span>, <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;Python&quot;</span>];<br><span class="hljs-keyword">var</span> arrRet = arr.<span class="hljs-title function_">copyWithin</span>(<span class="hljs-number">0</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;ArrRet =&quot;</span>, arrRet);<br><span class="hljs-keyword">var</span> arrRet2 = arr.<span class="hljs-title function_">copyWithin</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;ArrRet2 =&quot;</span>, arrRet2);<br></code></pre></td></tr></table></figure><p><a href="code/array11.html">代码运行</a></p><h2 id="数组填充fill"><a href="#数组填充fill" class="headerlink" title="数组填充fill"></a>数组填充fill</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">array.<span class="hljs-title function_">fill</span>(value, start, end);<br></code></pre></td></tr></table></figure><h2 id="从字符串创建数组from"><a href="#从字符串创建数组from" class="headerlink" title="从字符串创建数组from"></a>从字符串创建数组from</h2><p>from() 方法用于通过拥有 <strong>length</strong> 属性的对象或<strong>可迭代</strong>的 对象 来 <strong>返回 一个数组</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(object, mapFunction, thisValue);<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>object</td><td>必需，要转换为数组的对象。</td></tr><tr><td>mapFunction</td><td>可选，数组中每个元素要调用的函数,返回值存入数组</td></tr><tr><td>thisValue</td><td>可选，映射函数(mapFunction)中的 this 对象。</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mapFunction</span>(<span class="hljs-params">a</span>)&#123;<span class="hljs-comment">//转换为数字后*2返回</span><br>  <span class="hljs-keyword">var</span> a_ = <span class="hljs-title class_">Number</span>(a)*<span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">return</span> a_;<br>&#125;<br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;12345&quot;</span>;<br><span class="hljs-keyword">var</span> newArr = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(str,mapFunctionm,<span class="hljs-literal">undefined</span>);<br><span class="hljs-keyword">var</span> newArr2 = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(str);<span class="hljs-comment">//按字符类型创建数组</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr2);<br></code></pre></td></tr></table></figure><p><a href="code/array12.html">代码运行</a></p><h2 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h2><p>在 JavaScript 中，我们可以使用 <strong>reverse</strong> 函数，实现将 数组 的元素进行反转，reverse 函数会 <strong>返回 反转后的数组</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">array.<span class="hljs-title function_">reverse</span>();<br></code></pre></td></tr></table></figure><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><p>在 JavaScript 中，我们可以使用 <strong>sort</strong> 函数，实现对 数组 的元素进行排序，sort 函数<strong>会修改原来的数组</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">array.<span class="hljs-title function_">sort</span>(sortfunction);<br></code></pre></td></tr></table></figure><p>sortfunction指定排序顺序，必须是函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1024</span>, <span class="hljs-number">109</span>, <span class="hljs-number">38</span>, <span class="hljs-number">88</span>, <span class="hljs-number">110</span>];<br>arr.<span class="hljs-title function_">sort</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;arr =&quot;</span>, arr);<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sortFunc</span>(<span class="hljs-params">a, b</span>)&#123;<br>    <span class="hljs-keyword">return</span> a - b;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseSortFunc</span>(<span class="hljs-params">a, b</span>)&#123;<br>    <span class="hljs-keyword">return</span> b - a;<br>&#125;<br>arr.<span class="hljs-title function_">sort</span>(sortFunc);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;arr =&quot;</span>, arr);<br>arr.<span class="hljs-title function_">sort</span>(reverseSortFunc);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;arr =&quot;</span>, arr);<br></code></pre></td></tr></table></figure><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="JavaScript对象特征"><a href="#JavaScript对象特征" class="headerlink" title="JavaScript对象特征"></a>JavaScript对象特征</h2><ol><li>对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。</li><li>对象有状态：对象具有状态，同一对象可能处于不同状态下。</li><li>对象具有行为：即对象的状态可能因为它的行为产生变迁。</li><li>在 JavaScript 中，将状态和行为统一抽象为 “属性”，考虑到 JavaScript 中将函数设计成一种特殊对象，所以 JavaScript 中的行为和状态都能用属性来抽象。</li></ol><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>在 JavaScript 中，创建一个 对象 有四种方法，即：通过 <strong>Object</strong> 方法创建、通过<strong>字面量方法</strong>创建、通过<strong>自定义函数（构造函数）</strong>创建 和 通过<strong>工厂模式创建</strong>。<br><strong>Object方法创建</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>obj.<span class="hljs-property">attr1</span> = value1;<br>obj.<span class="hljs-property">attr2</span> = value2;<br>obj.<span class="hljs-property">attr3</span> = value3;<br>...<br>obj.<span class="hljs-property">func</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">//todo</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>字面量创建</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>obj.<span class="hljs-property">attr1</span> = value1;<br>obj.<span class="hljs-property">attr2</span> = value2;<br>obj.<span class="hljs-property">attr3</span> = value3;<br>...<br>obj.<span class="hljs-property">func</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">//todo</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>自定义函数方法创建对象（类）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Obj</span>(<span class="hljs-params">attr1, attr2, attr3, ...</span>)&#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">attr1</span> = attr1;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">attr2</span> = attr2;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">attr3</span> = attr3;<br>...<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">func</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">//todo</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name,age,sex</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">Name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">Age</span> = age;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">Sex</span> = sex;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">Hi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;my name is &quot;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">Name</span>,<span class="hljs-string">&quot;, i am &quot;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">Age</span>,<span class="hljs-string">&quot;years old&quot;</span>,<span class="hljs-string">&quot;,i am a &quot;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">Sex</span>);<br>    &#125;<br>&#125;，<br><br><span class="hljs-keyword">var</span> xiaohon = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;小红&quot;</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&quot;girl&quot;</span>);<br>xiaohon.<span class="hljs-title class_">Hi</span>();<br></code></pre></td></tr></table></figure><p><a href="code/object.html">代码运行</a></p><h2 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h2><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>使用.和[]访问对象属性</p><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><p>访问后添加</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>使用<strong>delete方法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">delete</span> person.<span class="hljs-property">name</span>;<br></code></pre></td></tr></table></figure><h3 id="遍历对象属性"><a href="#遍历对象属性" class="headerlink" title="遍历对象属性"></a>遍历对象属性</h3><p>在 JavaScript 中，遍历一个 对象 的所有 属性 有五种方法，即：使用 <strong>for in</strong> 遍历、使用 <strong>Object.keys</strong> 遍历、使用 <strong>Object.getOwnPropertyNames</strong> 遍历、使用 - <strong>Object.getOwnPropertySymbols</strong> 遍历和使用 <strong>Reflect.ownKeys</strong> 遍历。</p><ul><li><strong>getOwnPropertyNames</strong><br>在 JavaScript 中，遍历一个 对象 的 属性 可以使用 <strong>getOwnPropertyNames()</strong> 方法，Object.getOwnPropertyNames() 方法会返回一个由指定对象的所有自身属性的属性名（<strong>包括不可枚举属性但不包括 Symbol 值作为名称的属性</strong>,这是和keys的区别，keys只包括可枚举类型）组成的 数组。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javscript">Object.getOwnPropertyNames(obj);<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> sym = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;symbol&quot;</span>);<br><span class="hljs-keyword">var</span> obj = &#123;<br>    [sym] : <span class="hljs-string">&#x27;symbol类型&#x27;</span>,<br>    <span class="hljs-number">1</span> : <span class="hljs-number">2</span>,<span class="hljs-comment">//1虽然是数字不可枚举类型，但做属性名会自动转字符串</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    相当于：</span><br><span class="hljs-comment">    &#x27;1&#x27; : 2,</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-string">&#x27;2&#x27;</span> : <span class="hljs-number">3</span>,<br>&#125;<br><span class="hljs-comment">//返回非symbol的所有属性名</span><br><span class="hljs-keyword">var</span> key1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;key1=&quot;</span>,key1);<span class="hljs-comment">//[&#x27;1&#x27;, &#x27;2&#x27;]</span><br><span class="hljs-comment">//返回非symbol的可枚举属性名</span><br><span class="hljs-keyword">var</span> key2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;key2=&quot;</span>,key2);<span class="hljs-comment">//[&#x27;1&#x27;, &#x27;2&#x27;]</span><br><span class="hljs-comment">//设置属性不可枚举</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(obj,&#123;<span class="hljs-comment">//一次定义多个属性，并设置它们的可枚举性。</span><br>    <span class="hljs-number">1</span>:&#123;<br>        <span class="hljs-attr">value</span>:<span class="hljs-number">2</span>,<br>        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span><span class="hljs-comment">//将属性‘1’设置为不可枚举</span><br>    &#125;<br>&#125;)<br><span class="hljs-comment">//返回非symbol的可枚举属性名</span><br><span class="hljs-keyword">var</span> key3 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;key3=&quot;</span>,key3);<span class="hljs-comment">//[&#x27;2&#x27;]</span><br></code></pre></td></tr></table></figure><ul><li><strong>getOwnPropertySymbols</strong><br>在 JavaScript 中，遍历一个 对象 的 属性 可以使用 getOwnPropertySymbols() 方法，Object.getOwnPropertySymbols() 方法会返回一个 数组，该数组<strong>包含了对象自身的所有 Symbol 属性的键名</strong>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//只返回symbol类型属性名</span><br><span class="hljs-keyword">var</span> key4 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;key4=&quot;</span>,key4);<span class="hljs-comment">//[Symbol(symbol)]</span><br></code></pre></td></tr></table></figure><ul><li><strong>ownKeys</strong><br>在 JavaScript 中，遍历一个 对象 的 属性 可以使用 ownKeys() 方法，Reflect.ownKeys 返回一个 数组，该数组包含对象自身的<strong>所有键名</strong>，<strong>不管键名是 Symbol 或 字符串，也不管是否可枚举。</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(obj);<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//返回所有属性名</span><br><span class="hljs-keyword">var</span> key5 = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;key5=&quot;</span>,key5);<span class="hljs-comment">//&#x27;1&#x27;, &#x27;2&#x27;, Symbol(symbol)</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> sym = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;symbol&quot;</span>);<br><span class="hljs-keyword">var</span> obj = &#123;<br>    [sym] : <span class="hljs-string">&#x27;symbol类型&#x27;</span>,<br>    <span class="hljs-number">1</span> : <span class="hljs-number">2</span>,<span class="hljs-comment">//1虽然是数字不可枚举类型，但做属性名会自动转字符串</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    相当于：</span><br><span class="hljs-comment">    &#x27;1&#x27; : 2,</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-string">&#x27;2&#x27;</span> : <span class="hljs-number">3</span>,<br><br><span class="hljs-comment">//返回非symbol的所有属性名</span><br><span class="hljs-keyword">var</span> key1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;key1=&quot;</span>,key1);<span class="hljs-comment">//[&#x27;1&#x27;, &#x27;2&#x27;]</span><br><span class="hljs-comment">//返回非symbol的可枚举属性名</span><br><span class="hljs-keyword">var</span> key2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;key2=&quot;</span>,key2);<span class="hljs-comment">//[&#x27;1&#x27;, &#x27;2&#x27;]</span><br><span class="hljs-comment">//设置属性不可枚举</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(obj,&#123;<span class="hljs-comment">//一次定义多个属性，并设置它们的可枚举性。</span><br>    <span class="hljs-number">1</span>:&#123;<br>        <span class="hljs-attr">value</span>:<span class="hljs-number">2</span>,<br>        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span><span class="hljs-comment">//将属性‘1’设置为不可枚举</span><br>    &#125;<br>&#125;)<br><span class="hljs-comment">//返回非symbol的可枚举属性名</span><br><span class="hljs-keyword">var</span> key3 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;key3=&quot;</span>,key3);<span class="hljs-comment">//[&#x27;2&#x27;]</span><br><span class="hljs-comment">//只返回symbol类型属性名</span><br><span class="hljs-keyword">var</span> key4 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;key4=&quot;</span>,key4);<span class="hljs-comment">//[Symbol(symbol</span><br><span class="hljs-comment">//返回所有属性名</span><br><span class="hljs-keyword">var</span> key5 = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;key5=&quot;</span>,key5);<span class="hljs-comment">//[&#x27;1&#x27;, &#x27;2&#x27;, Symbol(symbol)]</span><br></code></pre></td></tr></table></figure><p><a href="./code/object_getName.html">代码运行</a></p><h2 id="对象存在"><a href="#对象存在" class="headerlink" title="对象存在"></a>对象存在</h2><p>在 JavaScript 中，判断一个 对象 是否有某个 属性 有三种方法，即：<strong>使用点或者中括号运算符</strong>、使用 <strong>in</strong> 语句和使用 <strong>hasOwnProperty</strong> 方法。<br>访问到不存在属性时，会返回undefined</p><p><strong>in</strong>判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">attr <span class="hljs-keyword">in</span> obj;<br></code></pre></td></tr></table></figure><p>如果对象 obj 中，含有属性 attr，那么 in 语句返回 true，否则，返回 false。</p><p><strong>hasOwnProperty</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">obj.<span class="hljs-title function_">hasOwnProperty</span>(attr);<br></code></pre></td></tr></table></figure><p>hasOwnProperty 方法返回一个布尔值，判断对象是<strong>否包含特定的自身（非继承）属性</strong>(与in的区别)，如果存在，则返回 true，否则，返回 false。</p><h2 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h2><p>在 JavaScript 中，方法是能够在 对象 上执行的动作。JavaScript 方法是包含函数定义的 <strong>属性</strong>。  </p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>面向对象语言中 this 表示当前 <strong>对象 的一个引用</strong>。但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。<br><strong>JavaScript this特点详解</strong></p><ol><li>函数在定义的时候 this 是不确定的，只有在调用的时候才可以确定。</li><li>一般函数直接执行，内部 this <strong>指向全局 window</strong>，在<strong>严格模式</strong>下，<strong>this 是 undefined</strong>。</li><li>函数作为一个<strong>对象的方法</strong>，被该对象所调用，那么 <strong>this 指向的是该对象</strong>。</li><li>构造函数中的 this 其实是一个<strong>隐式对象</strong>，类似一个初始化的模型，所有<strong>方法和属性都挂载到了这个隐式对象身上</strong>，后续通过 new 关键字来调用，从而实现实例化。</li></ol><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>在 JavaScript 中，new 运算符用于<strong>创建一个用户定义的 对象</strong> 类型的实例或具有<strong>构造函数的内置对象</strong>的实例。</p><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>在 JavaScript 中，我们判断某个 变量 是什么 类型 的常常会用 typeof 运算符，但是使用 typeof 运算符不管引用的是什么类型的对象，它都返回的是 object <strong>类型的。而instanceof</strong> 运算符可以查看<strong>具体的类型</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">option <span class="hljs-keyword">instanceof</span> constructor;<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>option</td><td>是需要检测的对象。</td></tr><tr><td>constructor</td><td>是你确定的对象，返回的是这个 option 是否属于 constructor 这个类型的布尔值。</td></tr></tbody></table><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>在 JavaScript 中，用 <strong>new 关键字</strong>来调用的 函数，称为<strong>构造函数</strong>。<br>在使用对象字面量创建一系列同一类型的对象时，这些对象可能具有一些相似的特征(属性)和行为(方法)，此时会产生很多重复的代码，而使用构造函数就可以实现代码的复用。<br><strong>JavaScript构造函数执行流程</strong></p><ol><li>当以 new 关键字调用时，会创建一个新的内存空间，标记为对象的实例。</li><li>函数体内部的 this 指向该内存。</li><li>执行函数体内的代码。</li><li>默认返回 this</li></ol><h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h2><p>在 JavaScript 中 变量 的类型可以分为基本类型（也叫值类型）与复杂类型（也叫引用类型），其中，值类型就是 JavaScript 的基本数据类型，引用类型是复杂的对象类型。<br>值：字符串（string）、数值（number）、布尔值（boolean）、null、undefined。<br>引用类型：对象（Object）、数组（Array）、函数（Function）、日期（Date）、正则表达式（RegExp）。</p><table><thead><tr><th></th><th>值类型</th><th>引用类型</th></tr></thead><tbody><tr><td>概念</td><td>原始值指的是原始类型的值，也叫基本类型</td><td>引用值指的是引用类型（类） 的值</td></tr><tr><td>数据类型</td><td>字符串（string）、数值（number）、布尔值（boolean）、null、undefined。</td><td>对象（Object）、数组（Array）、函数（Function）、日期（Date）、正则表达式（RegExp）。</td></tr><tr><td>存储</td><td>栈（stack），占内存空间固定，使用后被销毁</td><td>堆（heap），占内存空间不固定，使用后不一定被销毁，只有一个对象没有任何引用时，系统的垃圾回收机制才会回收销毁</td></tr><tr><td>赋值方式</td><td>1. 值的拷贝,创建一个新对象<br>2. 保存与复制的是值本身<br>3. 两份数据在内存中是完全独立的</td><td>1. 引用的拷贝，创建一个新引用<br>2. 保存与复制的是指向对象的一个指针<br>3. 变量中的存储的地址赋值一份单独存储,<br>两个变量中修改其中一个对象，另外一个引用来访问的时候，也会访问到修改后的值。<br>4. 使用 new() 方法构造出的对象是引用型。<br></td></tr><tr><td>作用域</td><td>函数作用域，在函数内部修改时生效，函数销毁时失效</td><td>函数中被修改时修改的是运行时数据区中的值，即使函数被销毁，变量的值依旧被改变。</td></tr><tr><td>比较方式</td><td>值的比较</td><td>引用的比较</td></tr><tr><td>参数传递</td><td>值类型按值传递</td><td>引用类型按引用传递</td></tr><tr><td>检测类型</td><td>typeof 运算符</td><td>instanceof 运算符在函数内部修改时生效，函数销毁时失效</td></tr></tbody></table><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>每一个 对象 (除 null 外)创建的时候，就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型中 <strong>“继承”属性</strong>。<br><strong>prototype</strong><br>在 JavaScript 中，每个 函数 都有一个 <strong>prototype 属性</strong>，这个属性指向函数的原型对象。<br><strong><strong>proto</strong></strong><br>每个对象(除 null 外)都会有的属性，叫做 __proto__，这个属性会指向该对象的原型。<br>每个原型都有一个 <strong>constructor 属性</strong>，指向<strong>该关联的构造函数</strong>。</p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>在 JavaScript 中，每个继承父函数的子函数的对象都包含一个内部属性 _proto_。该属性包含一个指针，指向父函数的 prototype。</p><p>若父函数的原型对象的 <em>proto</em> 属性为再上一层函数，在此过程中就形成了原型链。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>JavaScript 中，实现继承有六种方法，即，分别为：使用<strong>原型链继承</strong>、借用<strong>构造函数继承</strong>、<strong>原型链+借用构造函数</strong>的组合继承、<strong>组合继承</strong>、 <strong>组合继承–优化</strong>版 以及 ES6 中 <strong>class</strong> 的继承。</p><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义父类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  thia.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;parent&#x27;</span>;<span class="hljs-comment">// name属性</span><br>&#125;<br><br><span class="hljs-comment">// 定义子类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>&#125;<br><span class="hljs-comment">// 在父类的原型上定义getName方法</span><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>&#125;<br><br><span class="hljs-comment">// 让子类继承父类</span><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();<br><br><span class="hljs-comment">// 实例化子类</span><br><span class="hljs-keyword">var</span> c1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c1.<span class="hljs-title function_">getName</span>());<span class="hljs-comment">// 输出&#x27;child&#x27;</span><br></code></pre></td></tr></table></figure><p>我们通过将 Child的 prototype 设置为了 Parent，从而实现了继承。</p><p>原型链继承的主要问题是<strong>如果属性是引用类型，这个属性会被所有实例共享</strong>，如果修改了一个，其他实例的属性也会被修改，比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义父类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  thia.<span class="hljs-property">array</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<span class="hljs-comment">// name属性</span><br>&#125;<br><br><span class="hljs-comment">// 定义子类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-comment">// 继承</span><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();<br><br><span class="hljs-comment">// 实例化子类</span><br><span class="hljs-keyword">var</span> c1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br><span class="hljs-keyword">var</span> c2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br><br><span class="hljs-comment">// 测试</span><br>c1.<span class="hljs-property">array</span>;<span class="hljs-comment">//[1,2,3]</span><br>c2.<span class="hljs-property">array</span>;<span class="hljs-comment">//[1,2,3]</span><br>c1.<span class="hljs-property">array</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">99</span>;<br>c1.<span class="hljs-property">array</span>;<span class="hljs-comment">//[99,2,3]</span><br>c2.<span class="hljs-property">array</span>;<span class="hljs-comment">//[99,2,3]</span><br><br></code></pre></td></tr></table></figure><h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><p>通过使用<code>call</code>或<code>apply</code>方法，<strong>可以在子类中执行父类型构造函数</strong>，从而实现继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 在父类的原型上定义属性</span><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">a</span> = <span class="hljs-string">&quot;我是父类prototype上的属性&quot;</span>;<br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name, age, gender</span>) &#123;<br>  <span class="hljs-comment">// 使用call继承父类的属性</span><br>    <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name, age);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">gender</span> = gender;<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-keyword">var</span> c1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;c1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;boy&#x27;</span>);<br><span class="hljs-keyword">var</span> c2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;c2&#x27;</span>,<span class="hljs-string">&#x27;1,&#x27;</span>,<span class="hljs-string">&#x27;boy&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c1.<span class="hljs-property">sayHello</span> == c2.<span class="hljs-property">sayHello</span>;)<span class="hljs-comment">// false，说明两个函数（引用类型）存储在不同的地址上</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c1.<span class="hljs-property">a</span>);<span class="hljs-comment">// undefined, 说明这种继承方式无法继承原型链上的属性</span><br></code></pre></td></tr></table></figure><p>构造函数继承无法继承原型链上的属性，<strong>只能继承父类构造函数内的属性和方法</strong>，优点是所有属性和方法，<strong>无论是否是引用类型，继承都是独立的</strong></p><h3 id="原型链和构造函数组合继承详解"><a href="#原型链和构造函数组合继承详解" class="headerlink" title="原型链和构造函数组合继承详解"></a>原型链和构造函数组合继承详解</h3><p>组合继承将两种方式一起使用<strong>使得子类的原型属性（即父类构造函数内的属性）不会被共享，且可以继承父类原型链上的属性和方法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">name, age</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>&#125;<br><span class="hljs-comment">// 父类原型添加属性</span><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">a</span> = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name, age, gender</span>) &#123;<br>    <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,name,age);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">gender</span> = gender;<br>&#125;<br><span class="hljs-comment">// 原型链继承</span><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();<br><span class="hljs-comment">// 修改子类构造函数指向</span><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span>; <span class="hljs-comment">//组合继承也是需要修复构造函数指向的</span><br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-keyword">var</span> c1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">var</span> c2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<br>c1.<span class="hljs-property">array</span> === c2.<span class="hljs-property">array</span>;<span class="hljs-comment">// false,说明地址不同，不会共享</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c1.<span class="hljs-property">a</span>);<span class="hljs-comment">// 1,可以访继承父类原型链上的属性</span><br></code></pre></td></tr></table></figure><p><strong>缺点：调用了两次Parent，在Child.prototype上添加了Parent的属性和方法</strong></p><h3 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">name, age</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">array</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>&#125;<br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name, age, gender</span>) &#123;<br>  <span class="hljs-comment">// 使用call继承父类的属性</span><br>    <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,name,age);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">gender</span> = gender;<br>&#125;<br><br><span class="hljs-comment">// create函数将创建一个空对象并指定该对象的原型</span><br><span class="hljs-comment">// 通过这个方法实现对父类原型链的继承</span><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-comment">// 修复构造函数指向</span><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Parent</span>;<br></code></pre></td></tr></table></figure><p>寄生组合继承<strong>只调用了一次<code>Parent()</code>函数</strong>，但是**<code>Child.prototype</code>的原始属性和方法会丢失**</p><h3 id="class-的继承"><a href="#class-的继承" class="headerlink" title="class 的继承"></a>class 的继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-comment">//调用类的构造方法</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">attr1, attr2</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">attr1</span> = attr1;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">attr2</span> = attr2;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 子类继承父类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">attr1, attr2, attr3</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(attr1, attr2); <span class="hljs-comment">//通过super调用父类的构造方法</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">attr3</span> = attr3;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Proxy对象"><a href="#Proxy对象" class="headerlink" title="Proxy对象"></a>Proxy对象</h2><p><strong>Proxy</strong> 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 包装的目标对象</span><br><span class="hljs-keyword">const</span> target = &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;1&#x27;</span><br>&#125;<br><br><span class="hljs-comment">// 一个通常以函数为属性的对象，定义了在执行各种操作时代理 p 的行为</span><br><span class="hljs-keyword">const</span> handler = &#123;<br><span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">target, property</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target, property);<span class="hljs-comment">// &#123;value: &#x27;1&#x27;&#125;   &#x27;1&#x27;</span><br>    <span class="hljs-keyword">return</span> target[property];<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 设置代理</span><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><span class="hljs-comment">// 使用代理读取属性，并触发get方法</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">value</span>);<br><span class="hljs-comment">//  &#123;value: &#x27;1&#x27;&#125;   &#x27;1&#x27;  get方法打印的值</span><br><span class="hljs-comment">//  ‘1’get方法返回的值被console.log打印</span><br></code></pre></td></tr></table></figure><p>下面是<code>handle</code>对象的方法</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>handler.getPrototypeOf()</td><td>Object.getPrototypeOf 方法的捕捉器，当读取代理对象的原型时，该方法就会被调用</td></tr><tr><td>handler.setPrototypeOf()</td><td>Object.setPrototypeOf 方法的捕捉器，主要用来拦截 Object.setPrototypeOf()</td></tr><tr><td>handler.isExtensible()</td><td>Object.isExtensible 方法的捕捉器，用于拦截对对象的 Object.isExtensible()。</td></tr><tr><td>handler.preventExtensions()</td><td>Object.preventExtensions 方法的捕捉器，主要用来拦截 Object.preventExtension（）</td></tr><tr><td>handler.getOwnPropertyDescriptor()</td><td>Object.getOwnPropertyDescriptor 方法的捕捉器，方法是 Object.getOwnPropertyDescriptor()的钩子。</td></tr><tr><td>handler.defineProperty()</td><td>Object.defineProperty 方法的捕捉器，用于拦截对象的 Object.defineProperty()操作。</td></tr><tr><td>handler.has()</td><td>in 操作符的捕捉器</td></tr><tr><td>handler.get()</td><td>属性读取操作的捕捉器</td></tr><tr><td>handler.set()</td><td>属性设置操作的捕捉器</td></tr><tr><td>handler.deleteProperty()</td><td>delete 操作符的捕捉器</td></tr><tr><td>handler.ownKeys()</td><td>Object.getOwnPropertyNames 和 Object.getOwnPropertySymbols 方法的捕捉器</td></tr><tr><td>handler.apply()</td><td>函数调用操作的捕捉器</td></tr><tr><td>handler.construct()</td><td>new 操作符的捕捉器</td></tr></tbody></table><h1 id="map映射"><a href="#map映射" class="headerlink" title="map映射"></a>map映射</h1><p>map和对象有点类似，都是以键值对的形式存储数据，他的使用方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 声明一个map</span><br><span class="hljs-keyword">var</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><span class="hljs-comment">// 使用set存入数据</span><br>myMap.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<br><span class="hljs-comment">// 使用get读取数据</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myMap.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;key&#x27;</span>));<span class="hljs-comment">// &#x27;1&#x27;</span><br><span class="hljs-comment">// 使用delete删除数据</span><br>myMap.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&#x27;key&#x27;</span>);<span class="hljs-comment">// 根据删除成功或失败返回true或false</span><br><span class="hljs-comment">// 使用clear清空map</span><br>myMap.<span class="hljs-title function_">clear</span>();<br><span class="hljs-comment">// size属性查看map的大小</span><br>myMap.<span class="hljs-property">size</span>;<br></code></pre></td></tr></table></figure><p>接下来是对象和map的区别：</p><ul><li><p>键的类型：</p><p>对象的键只能是<strong>字符串或symbol类型</strong>，而map接受所有类型，比如数组、数字、函数等</p></li><li><p>键的顺序：</p><p>在对象中，键的顺序并不是按顺序的，比如数字键会被提前，而map的键则是按照输入顺序</p></li><li><p>性能：</p><p>对象的属性查找性能通常在处理大量数据时较差，尤其是当键是非字符串类型时，浏览器和 JavaScript 引擎可能会执行额外的类型转换。</p></li><li><p>序列化：</p><p>对象可以直接与 JSON 进行序列化和反序列化。<code>JSON.stringify()</code> 和 <code>JSON.parse()</code> 支持对象的转换。<code>Map</code> 不能直接与 JSON 序列化工具一起使用。如果需要序列化 <code>Map</code>，需要先将其转换为数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 对象序列化与反序列化</span><br><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">const</span> json = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj); <span class="hljs-comment">// &#x27;&#123;&quot;a&quot;:1,&quot;b&quot;:2&#125;&#x27;</span><br><span class="hljs-keyword">const</span> parsed = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(json); <span class="hljs-comment">// &#123; a: 1, b: 2 &#125;</span><br><br><span class="hljs-comment">// map间接序列化</span><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>], [<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>]]);<br><span class="hljs-keyword">const</span> json = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>([...map]); <span class="hljs-comment">// &#x27;[[&quot;a&quot;,1],[&quot;b&quot;,2]]&#x27;</span><br><span class="hljs-keyword">const</span> parsed = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(json)); <span class="hljs-comment">// Map &#123; &#x27;a&#x27; =&gt; 1, &#x27;b&#x27; =&gt; 2 &#125;</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言实现KMP算法和个人理解</title>
    <link href="/2023/08/17/KMP%E7%AE%97%E6%B3%95%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
    <url>/2023/08/17/KMP%E7%AE%97%E6%B3%95%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p class="note note-info">以下内容皆为个人理解，可能存在不足或错误，请注意辨识。同时KMP不止一种实现方法</p><h1 id="什么是KMP算法"><a href="#什么是KMP算法" class="headerlink" title="什么是KMP算法"></a>什么是KMP算法</h1><p>KMP模式匹配算法是一种用来查找字符串的算法，由K,M,P（首字母）三位大佬提出，是一种朴素模式匹配算法更高效的方法。能有效缩短时间。</p><h1 id="KMP算法与朴素算法比较"><a href="#KMP算法与朴素算法比较" class="headerlink" title="KMP算法与朴素算法比较"></a>KMP算法与朴素算法比较</h1><p>朴素算法，是一种很直观的算法，我们定义一个i和j，两个字符串s和t，s为主串，t为要查找的子串，i是指向s某个位置的指针，j同理指向t。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> s[MAXSIZE];<br><span class="hljs-type">char</span> t[MAXSIZE];<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>接着将子串与主串的各自元素进行比较，若相同则i,j指针后移继续比较，直到j遍历完子串，说明完全相等，返回<strong>i-j</strong>，就是子串在主串的位置。而若是在中途出现不匹配的，则将j指向重新指向头部，i移动到<strong>i-j+1</strong>的位置，重新遍历。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> ( i &lt; <span class="hljs-built_in">strlen</span>(s) &amp;&amp; j &lt; <span class="hljs-built_in">strlen</span>(t))<br>&#123;<br><span class="hljs-keyword">if</span>( s[i] == t[j])<br>    &#123;<br>i++;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>i = i - j + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span> (j == <span class="hljs-built_in">strlen</span>(t))<br>    <span class="hljs-keyword">return</span> i-j;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//t不在s内</span><br></code></pre></td></tr></table></figure><p>也就是说，朴素算法出现某个元素对不上时，需要将指针回滚，这样原本遍历过的元素又要重新遍历一次，而KMP算法就是一种只向前的算法，将遍历过的元素利用起来。<br></p><p>举个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">s = <span class="hljs-string">&quot;ababbaa;</span><br><span class="hljs-string">t = &quot;</span>ababc<span class="hljs-string">&quot;;</span><br></code></pre></td></tr></table></figure><p>当我们比较到第5个元素时，发现s[4]与t[4]对不上，如果是朴素算法，我们接下来就是从s[1]与t[0]开始重新比较，但是我们可以看到</p><p>c的前面元素是abab，前两个和后两个是一样的，同时主串也是abab，也就是说，我们可以跳过子串的前2个元素，因为它们和主串的3，4元素是一样的，所以不必比较。也就是直接比较s[4]与s[2]。<br>像这种ab ab称为公共前后缀，比如ab efg ab，它们的最长公共前后缀就是ab，有多长，我们就可以跳过多少个元素。那么我们要怎么得出这个最长公共前后缀呢？<br></p><p>我们可以建立一个next数组，将每个部分的最长公共前后缀记录。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">t = <span class="hljs-string">&quot;ababaa&quot;</span><br></code></pre></td></tr></table></figure><p>对应的next数组为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">next = &#123;<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span>&#125;<br></code></pre></td></tr></table></figure><p>解释一下：a 只有一个 最长公共为0，ab没有公共 为0， aba最长公共为1， abab最长公共为2, ababa最长公共为3（aba）, ababaa最长公共为1（a）。</p><p>就是从第一个元素开始不断往后扩展，每扩展一次判定一次最长公共前后缀。next就是用于记录每次扩展后的最长公共前后缀。那么next如何利用到KMP算法呢？<br></p><h1 id="KMP算法C语言实现"><a href="#KMP算法C语言实现" class="headerlink" title="KMP算法C语言实现"></a>KMP算法C语言实现</h1><p>我们前面说了，在对比s和t中的元素时，若出现不等于的情况，可以直接跳过最长公共前后缀个元素，接着比较。s&#x3D;“ababbaa” t&#x3D;“ababc”。我们对比到第5个元素时，发现不相同，我们就看next数组的第4（就是5-1）个元素，它的值是2，说明前面这些元素最长公共前后缀是2，也就是说，我们可以跳过t的前2个元素，直接从t的第3个元素对比。具体代码实现为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">indexKMP</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> t)</span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">//主串s的元素</span><br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<span class="hljs-comment">//子串t的元素</span><br><span class="hljs-type">int</span> next[<span class="hljs-number">100</span>];<br>getNext(t, next);<br><span class="hljs-keyword">while</span>( i &lt; <span class="hljs-built_in">strlen</span>(s) &amp;&amp; j &lt; <span class="hljs-built_in">strlen</span>(t))&#123;<span class="hljs-comment">//当未达到主串或子串的末尾时，继续</span><br><span class="hljs-keyword">if</span>( s[i] == t[j])&#123;<span class="hljs-comment">//元素相等，主串指针和子串指针同时后移</span><br>i++;<br>j++;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//如果j等于0，则子串无法再回溯，说明主串的对应元素不是遍历过的子串中的一部分，下一个</span><br>i++;<span class="hljs-comment">//主串指针后移</span><br>&#125;<br><span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果不相等且j != 0 ，则需要对子串指针进行回溯</span><br>j = next[j<span class="hljs-number">-1</span>];<span class="hljs-comment">//回溯并跳过公共前后缀</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>( j == <span class="hljs-built_in">strlen</span>(t))<span class="hljs-comment">//子串被遍历完，说明子串存在于主串</span><br><span class="hljs-keyword">return</span> i - j;<br><span class="hljs-keyword">else</span> <br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="创建next数组"><a href="#创建next数组" class="headerlink" title="创建next数组"></a>创建next数组</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">getNext</span><span class="hljs-params">(<span class="hljs-built_in">string</span> t, <span class="hljs-type">int</span>* next)</span>&#123;<br><span class="hljs-type">int</span> f = <span class="hljs-number">0</span>;<span class="hljs-comment">//前缀末尾元素 和 最长公共前后缀长度</span><br><span class="hljs-type">int</span> b = <span class="hljs-number">1</span>;<span class="hljs-comment">//后缀末尾元素</span><br>next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>( b &lt; <span class="hljs-built_in">strlen</span>(t))&#123;<br><span class="hljs-keyword">if</span>(t[f] == t[b])&#123;<span class="hljs-comment">//相等</span><br>f++;<span class="hljs-comment">//前缀指针后移，同时也表示最长公共前后缀长度+1</span><br>next[b] = f;<span class="hljs-comment">//记录b位置的最长公共前后缀长度</span><br>b++;<span class="hljs-comment">//后缀指针后移</span><br>&#125;<br><span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//不相等</span><br><span class="hljs-keyword">if</span>( f == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//如果前缀指针指向0/当前最长公共前后缀长度为0 且t[f] != t[b]</span><br>next[b] = <span class="hljs-number">0</span>;<span class="hljs-comment">//b位置的最长公共前后缀长度为0</span><br>b++;<span class="hljs-comment">//后缀指针后移</span><br>&#125;<br><span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果f不为0且前后缀不等</span><br>f = next[f<span class="hljs-number">-1</span>];<span class="hljs-comment">//前缀指针回溯，并跳过公共部分</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一维二维指针形参对比</title>
    <link href="/2023/08/01/%E4%B8%80%E7%BB%B4%E4%BA%8C%E7%BB%B4%E6%8C%87%E9%92%88%E5%BD%A2%E5%8F%82%E5%AF%B9%E6%AF%94/"/>
    <url>/2023/08/01/%E4%B8%80%E7%BB%B4%E4%BA%8C%E7%BB%B4%E6%8C%87%E9%92%88%E5%BD%A2%E5%8F%82%E5%AF%B9%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<p>探究C语言中**p,与*p做形参的不同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span>* p = &amp;a;<br></code></pre></td></tr></table></figure><p>[TOC]</p><h1 id="以-p做形参："><a href="#以-p做形参：" class="headerlink" title="以*p做形参："></a>以*p做形参：</h1><p>以*<strong>p做形式参数</strong>时，可以通过</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span>* p)</span><br>&#123;<br>    *p = <span class="hljs-number">10</span>;<br>&#125;<br>--&gt;<br>    a = <span class="hljs-number">1</span><br>    *p = <span class="hljs-number">1</span>;<br><br></code></pre></td></tr></table></figure><p>来改变指针的值；<br>但如果在函数中将p指向另一个变量&#x2F;内存，函数结束后，p不会改变指向</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span>* <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> *p)</span><br>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    *p = &amp;a;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br>    p2 = f(p)<br>--&gt;<br>    a = <span class="hljs-number">1</span>;<br>*p = <span class="hljs-number">1</span>;<br>*p2 = <span class="hljs-number">10</span>;<br>    <br></code></pre></td></tr></table></figure><h1 id="以-p做形参"><a href="#以-p做形参" class="headerlink" title="以**p做形参"></a>以**p做形参</h1><p><strong>以**p做参数时候</strong>，可以通过</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C">f(<span class="hljs-type">int</span>** p )<br>&#123;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">100</span>;<br>    *p = &amp;b;<br>&#125;<br>--&gt;<br>    a = <span class="hljs-number">1</span>;<br>*p = <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><p>改变p的指向，将p指向另一个变量\地址。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当只需要改变输入的指针所指变量的值，而不需要改变指针所指地址时，使用一维指针；当需要改变输入的指针所指地址的时，选择用二维指针。</p>]]></content>
    
    
    
    <tags>
      
      <tag>小玩意</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Goang基础</title>
    <link href="/2023/07/15/Goang%E5%85%A5%E9%97%A8/"/>
    <url>/2023/07/15/Goang%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="语法注意事项"><a href="#语法注意事项" class="headerlink" title="语法注意事项"></a>语法注意事项</h1><p>每句语句的后面不需要有分号，区分大小写，导入了包但不使用里面的函数会报错，定义了变量不使用也会报错</p><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-comment">//包声明每个程序的开头都有一个package声明，表示文件所属代码包</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-comment">//导入所需要的代码包，导入包后不使用会报错</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//func声明一个函数</span><br>    fmt.Println(<span class="hljs-string">&quot;Hello World&quot;</span>)<span class="hljs-comment">//使用fmt包中的Println()函数</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="引用包"><a href="#引用包" class="headerlink" title="引用包"></a>引用包</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;包名&quot;</span><br><br><span class="hljs-comment">//引用多个包</span><br><span class="hljs-keyword">import</span>&#123;<br>    <span class="hljs-string">&quot;包1&quot;</span><br>    <span class="hljs-string">&quot;包2&quot;</span><br>&#125;<br><br><span class="hljs-comment">//实例</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br></code></pre></td></tr></table></figure><h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="25个关键字或保留字"><a href="#25个关键字或保留字" class="headerlink" title="25个关键字或保留字"></a>25个关键字或保留字</h2><blockquote><table class="reference"><tbody><tr><td style="width:25%">break</td><td style="width:25%">default</td><td style="width:25%">func</td><td style="width:25%">interface</td><td style="width:25%">select</td></tr><tr><td>case</td><td>defer</td><td>go</td><td>map</td><td>struct</td></tr><tr><td>chan</td><td>else</td><td>goto</td><td>package</td><td>switch</td></tr><tr><td>const</td><td>fallthrough</td><td>if</td><td>range</td><td>type</td></tr><tr><td>continue</td><td>for</td><td>import</td><td>return</td><td>var</td></tr></tbody></table></blockquote><h2 id="36个预定义字符"><a href="#36个预定义字符" class="headerlink" title="36个预定义字符"></a>36个预定义字符</h2> <table>  <tbody><tr>    <td>append</td>    <td>bool</td>    <td>byte</td>    <td>cap</td>    <td>close</td>    <td>complex</td>    <td>complex64</td>    <td>complex128</td>    <td>uint16</td>  </tr>  <tr>    <td>copy</td>    <td>false</td>    <td>float32</td>    <td>float64</td>    <td>imag</td>    <td>int</td>    <td>int8</td>    <td>int16</td>    <td>uint32</td>  </tr>  <tr>    <td>int32</td>    <td>int64</td>    <td>iota</td>    <td>len</td>    <td>make</td>    <td>new</td>    <td>nil</td>    <td>panic</td>    <td>uint64</td>  </tr>  <tr>    <td>print</td>    <td>println</td>    <td>real</td>    <td>recover</td>    <td>string</td>    <td>true</td>    <td>uint</td>    <td>uint8</td>    <td>uintptr</td>  </tr></tbody></table><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>布尔类型</td><td>布尔类型的值只能是true或false</td></tr><tr><td>数字类型</td><td>整型int、浮点型float32、float63</td></tr><tr><td>字符串类型</td><td>Go语言的字符串编码使用UTF-8或Unicode</td></tr><tr><td>字符类型</td><td>Go语言没有专门的字符类型，通常用byte类型：var c byte &#x3D; ‘a’</td></tr><tr><td>派生类型</td><td>包括<br><ul><li>指针类型</li><li>数组类型</li><li>结构化类型(struct)</li><li>Channel类型</li><li>函数类型</li><li>切片类型</li><li>接口类型</li><li>Map类型</li></td></tr></tbody></table><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>uint8</td><td>无符号8位整型(0-255)</td></tr><tr><td>uint16</td><td>0 到 65535</td></tr><tr><td>unit32</td><td>0 到 4294967295</td></tr><tr><td>unit64</td><td>0 到 18446744073709551615</td></tr><tr><td>int8</td><td>-128 到 127</td></tr><tr><td>int16</td><td>-32768 到 32767</td></tr><tr><td>int32</td><td>-2147483648 到 2147483647</td></tr><tr><td>int64</td><td>-9223372036854775808 到 9223372036854775807</td></tr></tbody></table><h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>float32</td><td>IEEE-754 32位浮点型数</td></tr><tr><td>float64</td><td>IEEE-754 64位浮点型数</td></tr><tr><td>complex64</td><td>32 位实数和虚数</td></tr><tr><td>complex128</td><td>64 位实数和虚数</td></tr></tbody></table><h2 id="其他数字类型"><a href="#其他数字类型" class="headerlink" title="其他数字类型"></a>其他数字类型</h2><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>byte</td><td>类似uint8</td></tr><tr><td>rune</td><td>类似int32</td></tr><tr><td>uint</td><td>32或64位</td></tr><tr><td>int</td><td>同unit大小</td></tr><tr><td>uintptr</td><td>无符号整型，用于存放一个指针</td></tr></tbody></table><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>Golang中的类型转换与Java不同，没有类型提升，不能自动转换数据类型，在进行类型转换时必须手动，哪怕是不同位数的同类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">int32</span> = <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">int64</span> = <span class="hljs-type">int64</span>(a)<span class="hljs-comment">//b=&gt;a</span><br><span class="hljs-keyword">var</span> c <span class="hljs-type">float32</span> = <span class="hljs-type">float32</span>(b)c=&gt;b<br></code></pre></td></tr></table></figure><h2 id="其他类型转spring"><a href="#其他类型转spring" class="headerlink" title="其他类型转spring"></a>其他类型转spring</h2><ul><li><p>使用fmt包中的Spfintf()函数：</p><p>  Sprintf()可以将参数根据指定的格式转换为字符串，并返回结果</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-keyword">var</span> a <span class="hljs-type">int8</span> = <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> str <span class="hljs-type">string</span><br>str = fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>,a)<br>fmt.Printf(<span class="hljs-string">&quot;type:%T\nstr = %v&quot;</span>,str,str)<br><br><span class="hljs-comment">//输出结果：</span><br><span class="hljs-keyword">type</span>:<span class="hljs-type">string</span><br>str = <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>声明变量一般使用关键字<strong>var</strong></p><h3 id="单变量声明"><a href="#单变量声明" class="headerlink" title="单变量声明"></a>单变量声明</h3><ul><li><p>**指定变量类型，若没有初始化则为默认值**：</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> v_name v_type<br><span class="hljs-comment">//实例</span><br><span class="hljs-keyword">var</span> num <span class="hljs-type">int</span><br><span class="hljs-comment">//声明了整型变量num，默认值为0</span><br><span class="hljs-keyword">var</span> num <span class="hljs-type">int</span> = <span class="hljs-number">10</span><br><span class="hljs-comment">//声明的同时赋值</span><br></code></pre></td></tr></table></figure></li><li><p><strong>根据值自动判断变量类型</strong></p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> v_name = value<br><span class="hljs-comment">//实例</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-literal">false</span><br><span class="hljs-comment">//声明了a=false，自动判断为布尔类型</span><br></code></pre></td></tr></table></figure></li><li><p><strong>使用:&#x3D;声明变量</strong></p><p>  <strong>这种写法只能在函数体内使用</strong></p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">v_name :=value<br><span class="hljs-comment">//实例</span><br>num :=<span class="hljs-number">10</span><br><span class="hljs-comment">//注意，若是在使用:=之前就已经使用var声明变量，则报错</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="多变量声明"><a href="#多变量声明" class="headerlink" title="多变量声明"></a>多变量声明</h3><p>和单变量类似，三种方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//类型相同，非全局变量</span><br><span class="hljs-keyword">var</span> vname1,vname2,vname3 <span class="hljs-keyword">type</span><br>vname1, vname2, vname3 = v1, v2, v3<br><br><span class="hljs-keyword">var</span> vname1,vname2,vname3 = v1, v2, v3<span class="hljs-comment">//不需要声明类型，自动判断</span><br><br>vname1, vname2, vname3 :=v1, v2, v3<span class="hljs-comment">//变量没有被声明过</span><br><br><br><span class="hljs-comment">//这种写法一般用于声明全局变量</span><br><span class="hljs-keyword">var</span>&#123;<br>    vname1 v_type1<br>    vname2 v_type2<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>常量是一个简单值得标识符，在程序运行时，不会被修改的量，常量的定义格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> identifier [<span class="hljs-keyword">type</span>] = value<br><span class="hljs-comment">//type可省略</span><br><span class="hljs-comment">//实例</span><br><span class="hljs-keyword">const</span> b <span class="hljs-type">string</span> = <span class="hljs-string">&quot;abc&quot;</span><br><span class="hljs-keyword">const</span> c = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>多个相同类型的声明可以简写为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> c_name1, c_name2, = value1, value2<br></code></pre></td></tr></table></figure><h1 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h1><ul><li><p>if:</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> 条件&#123;<br>    <br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>  条件不需要使用括号括起来，if后面必须跟着大括号不能单独一行，否则报错。</p></li><li><p>switch：</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> 表达式;&#123;<br>    <span class="hljs-keyword">case</span> 表达式<span class="hljs-number">1</span>:<br>    语句<br>    <span class="hljs-keyword">case</span> 表达式<span class="hljs-number">2</span>:<br>    语句<br>    <span class="hljs-keyword">default</span> :<br>    语句<br>&#125;<br></code></pre></td></tr></table></figure><p>  在golang中执行完一个case后自动退出switch，不需要使用break，若想执行一个case后继续往下执行，可以使用<strong>fallthrough</strong><br></p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> 表达式&#123;<br>    <span class="hljs-keyword">case</span> 表达式<span class="hljs-number">1</span>:<br>    语句<br>    <span class="hljs-keyword">fallthrough</span><br>    <span class="hljs-keyword">case</span> 表达式<span class="hljs-number">2</span>:<br>语句<br>&#125;<br></code></pre></td></tr></table></figure><p>  golang的case后的表达式可以有多个表达式用逗号隔开，只要满足其中一个就会执行case语句</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> 表达式&#123;<br>    <span class="hljs-keyword">case</span> 表达式<span class="hljs-number">1</span>,表达式<span class="hljs-number">2</span>:<br>    执行语句<br>&#125;<br></code></pre></td></tr></table></figure><p>  switch后也可以不带表达式，可以当作if使用</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">switch</span> &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>&lt;a&lt;<span class="hljs-number">10</span>:<br>    语句<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>&lt;=a&lt;<span class="hljs-number">20</span>:<br>    语句<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>for循环</p><p>golang的for循环与C语言类似，但少了括号</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> 循环变量初始化; 循环条件; 循环变量迭代&#123;<br>    语句<br>&#125;<br></code></pre></td></tr></table></figure><p>for循环的第二种使用方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> 循环判断条件&#123;<br>语句<br>&#125;<br></code></pre></td></tr></table></figure><p>第三种使用方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span>&#123;<br>    语句<br>&#125;<br></code></pre></td></tr></table></figure><p>这种写法会无限循环，一般配合break使用。</p><p>后两种写法相当于while，所以golang中并没有while语句</p><ul><li><p>使用for循环遍历字符串的两种方法</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//传统方式</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(str); i++&#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%c&quot;</span>,str[i])<br>&#125;<br><span class="hljs-comment">//使用range</span><br><span class="hljs-keyword">for</span> index, val := <span class="hljs-keyword">range</span> str&#123;   <br>    fmt.Printf(<span class="hljs-string">&quot;index=%d,val=%c&quot;</span>,index,val)<br>&#125;<br></code></pre></td></tr></table></figure><p>  第二种方法把下标赋值给index，把值赋值给val，如果字符串含有中文，第一种方式会出现乱码，因为它是按字节遍历的，而一个汉字的utf8编码占3个字节，所以会乱码。如果用第二种方式则不会乱码，因为range是按照字符的方式遍历</p></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML学习笔记2.0</title>
    <link href="/2023/07/04/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-0/"/>
    <url>/2023/07/04/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-0/</url>
    
    <content type="html"><![CDATA[<p class=" note note-warning">这不是H5,以下内容包含了HTML5移除的标识属性，新浏览器可能不再适用</p><h1 id="HTML基本标记"><a href="#HTML基本标记" class="headerlink" title="HTML基本标记"></a>HTML基本标记</h1><p>一个完整的HTML文档必须包含三个部分：</p><ul><li>由&lt;html&gt;元素定义的文档版本信息</li><li>由&lt;head&gt;定义各项声明的文档头部</li><li>由&lt;body&gt;定义的文档主体部分</li></ul><h2 id="HTML头部标记head"><a href="#HTML头部标记head" class="headerlink" title="HTML头部标记head"></a>HTML头部标记head</h2><p>&lt;head&gt;元素的作用范围是整篇文档，&lt;head&gt;元素中可以有<strong>&lt;meta&gt;信息元、文档样式表定义（CSS）和脚本（JS）等信息</strong>，定义在头部的内容一般不会在网页上显示。</p><h2 id="标题标记title"><a href="#标题标记title" class="headerlink" title="标题标记title"></a>标题标记title</h2><p>页面的标题一般用来说明网页的用途，显示在浏览器的标题栏中。标题信息设置在头部内，语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>标题内容<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="元信息标记meta"><a href="#元信息标记meta" class="headerlink" title="元信息标记meta"></a>元信息标记meta</h2><p>meta元素提供的信息不显示在网页中，一般用来定义页面信息的说明、关键字、刷新等。在html里meta不需要结束标记，一个尖括号内就是一个meta内容。写在头部</p><h3 id="设置页面关键字"><a href="#设置页面关键字" class="headerlink" title="设置页面关键字"></a>设置页面关键字</h3><p>一个页面可以有多个meta。meta的元素有<strong>name</strong>和<strong>http-equiv</strong>，其中<strong>name</strong>属性主要用于描述网页，以便于搜索引擎查找、分类。搜索信息都是通过输入关键字来实现的，它是针对搜索引擎的信息。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;keywords&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;输入具体的关键字&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>说明</strong>：<strong>name</strong>为属性名称，这里是<strong>keywords</strong>，也就是设置网页的关键字属性，而在<strong>content</strong>中则定义具体的关键字。</p><h3 id="设置页面说明"><a href="#设置页面说明" class="headerlink" title="设置页面说明"></a>设置页面说明</h3><p>也是为了方便搜索引擎查找，用来详细说明网页的内容，页面说明在网页中不显示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;设置页面说明&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>说明</strong>：<strong>name</strong>为属性名称，这里设置为<strong>description</strong>，也就是页面说明，在content中定义具体的描述语言</p><h3 id="定义编辑工具"><a href="#定义编辑工具" class="headerlink" title="定义编辑工具"></a>定义编辑工具</h3><p>很多编辑软件都可以制作网页，在源代码的头部可以设置网页编剧工具的名称。在网页中不显示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;generator&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;编辑软件的名称&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>说明</strong>：<strong>name</strong>为属性名称，这里设置为<strong>generator</strong>，也就是设置编辑工具，在content中定义具体的编辑软件名称</p><h3 id="添加作者信息"><a href="#添加作者信息" class="headerlink" title="添加作者信息"></a>添加作者信息</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;author&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;作者的名字&quot;</span></span><br></code></pre></td></tr></table></figure><p><strong>说明</strong>：<strong>name</strong>为属性名称，这里设置为<strong>author</strong>，也就是设置作者信息，在content中定义具体的信息</p><h3 id="设置网页文字及语言"><a href="#设置网页文字及语言" class="headerlink" title="设置网页文字及语言"></a>设置网页文字及语言</h3><p>在网页中还可以设置语言的编码方式，这样浏览器就可以正确的选择语言，而不需要人工选择。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;content-type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html; charset=字符集类型&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p><strong>说明</strong>：在该语法中，<strong>http-equiv</strong>用于传送HTTP通信协议的标头，而在<strong>content</strong>中才是具体的属性值。<strong>charset</strong>用于设置网页的内码语系，也就是字符集类型，国内常用的是<strong>GB码</strong>，往往设置为<strong>gb2312</strong>，即简体中文。英文是<strong>ISO-8859-1</strong>字符集，此外还有其他。</p><h3 id="设置页面的定时跳转"><a href="#设置页面的定时跳转" class="headerlink" title="设置页面的定时跳转"></a>设置页面的定时跳转</h3><p>使用&lt;meta&gt;标记可以使网页在经过一定时间后自动刷新，这可以通过将<strong>http-equiv</strong>属性值设置为<strong>refresh</strong>来实现。<strong>content</strong>属性值可以设置为更新时间</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meata</span> <span class="hljs-attr">http-euiv</span>=<span class="hljs-string">&quot;refresh&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;跳转的时间;URL=跳转地址&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>说明</strong>：<strong>refresh</strong>表示刷新，<strong>content</strong>中设置刷新的时间和刷新后的链接地址，两者用分号隔开。<strong>默认情况下，时间以秒为单位</strong></p><h2 id="页面注释-lt-–-–-gt"><a href="#页面注释-lt-–-–-gt" class="headerlink" title="页面注释&lt;!– –&gt;"></a>页面注释&lt;!– –&gt;</h2><p><del>最讨厌的事：让我写注释和别人不写注释</del></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--注释内容--&gt;</span><br></code></pre></td></tr></table></figure><p><strong>说明</strong>：肚子饿了</p><h2 id="标题字"><a href="#标题字" class="headerlink" title="标题字"></a>标题字</h2><h3 id="标题字标记h"><a href="#标题字标记h" class="headerlink" title="标题字标记h"></a>标题字标记h</h3><p>从&lt;h1&gt;到&lt;h6&gt;共有6个级别的标题，h表示headline。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>一级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>二级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>三级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br></code></pre></td></tr></table></figure><p class = "note note-info">对于不同浏览器，其确切的点阵尺寸大小也不相同，但一级标题大约是标注文字高度的2~3倍，六级标记则比标志文字略小</p><h3 id="标题字对齐属性align"><a href="#标题字对齐属性align" class="headerlink" title="标题字对齐属性align"></a>标题字对齐属性align</h3><p>默认是左对齐，若需要选择其他方式则需要使用<strong>align</strong>参数进行设置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;align= 对齐方式&gt;<br></code></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>含义</th></tr></thead><tbody><tr><td>left</td><td>左对齐</td></tr><tr><td>center</td><td>居中对齐</td></tr><tr><td>right</td><td>右对齐</td></tr></tbody></table><h2 id="段落标记"><a href="#段落标记" class="headerlink" title="段落标记"></a>段落标记</h2><h3 id="段落标记p"><a href="#段落标记p" class="headerlink" title="段落标记p"></a>段落标记p</h3><p>&lt;p&gt;用来起始一个段落，可以没有结束标记&lt;&#x2F;p&gt;，而每一个新段落的开始同时表示上一个段落的结束。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>段落1<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>段落2<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>段落3<br></code></pre></td></tr></table></figure><p>同时还可以配合<strong>align</strong>使用，调整段落的位置。</p><h3 id="换行符br"><a href="#换行符br" class="headerlink" title="换行符br"></a>换行符br</h3><p>&lt;br&gt;的作用是在不另起一段的情况下将当前文本强制换行</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br></code></pre></td></tr></table></figure><p class="note note-info">&ltb;r>是唯一可以为文字分行的方法，其他标记如&lt;p>，可以为文字分段</p><h3 id="不换行nobr"><a href="#不换行nobr" class="headerlink" title="不换行nobr"></a>不换行nobr</h3><p>在网页中，如果一段文字过长，浏览器会自动对这段文字进行换行处理。可以使用nobr来禁止自动换行</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">nobr</span>&gt;</span>不换行文字<span class="hljs-tag">&lt;/<span class="hljs-name">nobr</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="水平线"><a href="#水平线" class="headerlink" title="水平线"></a>水平线</h2><p>&lt;hr&gt;标记代表水平分割模式，在浏览器中显示一条线，可以使用size属性修改线条的粗细，color设置线条的颜色</p><h2 id="其他标记"><a href="#其他标记" class="headerlink" title="其他标记"></a>其他标记</h2><h3 id="插入空格"><a href="#插入空格" class="headerlink" title="插入空格"></a>插入空格</h3><p>可以用许多不同的方法分开文字，包括空白、标签和Enther，这些都被称为空格，因为它们可增加字与字之间的距离。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">&amp;nbsp<br></code></pre></td></tr></table></figure><p><strong>说明</strong>：在网页中可以有多个空格，一个**&amp;nbsp**表示一个半角空格</p><h3 id="插入特殊符号"><a href="#插入特殊符号" class="headerlink" title="插入特殊符号"></a>插入特殊符号</h3><p>网页有时候需要用到一些特殊字符，比如现在我写博客记录HTML的知识，出现了&lt;p&gt;，如果直接写就会被识别为段落标记，这时可以用类似上面空格的方法，写入特殊字符。由前缀“&amp;”、字符名称和后缀‘;“构成。</p><table><thead><tr><th>特殊字符</th><th>符号的代码</th></tr></thead><tbody><tr><td>“</td><td>&amp;quot</td></tr><tr><td>&amp;</td><td>&amp;amp</td></tr><tr><td>&lt;</td><td>&amp;lt</td></tr><tr><td>&gt;</td><td>&amp;gt</td></tr><tr><td>&amp;times;</td><td>&amp;times</td></tr><tr><td>&amp;sect;</td><td>&amp;sect</td></tr><tr><td>&amp;copy;</td><td>&amp;copy</td></tr><tr><td>&amp;reg;</td><td>&amp;reg</td></tr><tr><td>&amp;trade;</td><td>&amp;trade</td></tr></tbody></table><h1 id="建立超链接"><a href="#建立超链接" class="headerlink" title="建立超链接"></a>建立超链接</h1><h2 id="内部链接"><a href="#内部链接" class="headerlink" title="内部链接"></a>内部链接</h2><h3 id="内部链接-1"><a href="#内部链接-1" class="headerlink" title="内部链接"></a>内部链接</h3><p>与自身网站页面相关的链接被称为内部链接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;链接地址&quot;</span>&gt;</span>文本<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="链接的目标窗口"><a href="#链接的目标窗口" class="headerlink" title="链接的目标窗口"></a>链接的目标窗口</h3><p>默认情况下，超链接都会在原来的浏览器窗口中打开，可以使用<strong>target</strong>属性来控制打开的目标窗口</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;链接目标&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;目标窗口打开方式&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>含义</th></tr></thead><tbody><tr><td>-self</td><td>在当前页面中打开链接</td></tr><tr><td>-blank</td><td>在一个全新的空白窗口中打开链接</td></tr><tr><td>-top</td><td>在顶层框架中打开链接，也可以理解为在根框架中打开链接</td></tr><tr><td>-parent</td><td>在当前框架的上一层里打开链接</td></tr></tbody></table><h2 id="锚点链接"><a href="#锚点链接" class="headerlink" title="锚点链接"></a>锚点链接</h2><p>用于页面内跳转</p><h3 id="建立锚点"><a href="#建立锚点" class="headerlink" title="建立锚点"></a>建立锚点</h3><p>利用锚点名称可以链接到相应的位置，名称可以是英文或数字或者混合，不能有名称相同的锚点</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;锚点的名称&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="链接同一页面的锚点"><a href="#链接同一页面的锚点" class="headerlink" title="链接同一页面的锚点"></a>链接同一页面的锚点</h3><p>在建立锚点以后，就可以创建到锚点的链接，需要用**#<strong>号以及锚点的名称作为</strong>href**的属性值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">“#锚点名称</span>&quot;&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p class="note note-info">如果锚点在屏幕上已经可见，那么浏览器可能不会跳转。</p><h3 id="链接到其他页面的锚点"><a href="#链接到其他页面的锚点" class="headerlink" title="链接到其他页面的锚点"></a>链接到其他页面的锚点</h3><p>锚点链接不但可以链接到同义页面，也可以在不同页面中设置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;链接的文件地址&quot;</span> #<span class="hljs-attr">锚点名称</span>&quot;&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="外部链接"><a href="#外部链接" class="headerlink" title="外部链接"></a>外部链接</h2><p>外部链接是指跳转到当前网站之外的资源中</p><h3 id="链接到http"><a href="#链接到http" class="headerlink" title="链接到http"></a>链接到http</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://...&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="链接到E-mail"><a href="#链接到E-mail" class="headerlink" title="链接到E-mail"></a>链接到E-mail</h3><p>在网页上创建E-mail链接可以使浏览者快速反馈自己的意见，当读者点击时，可以立即打开浏览器默认的E-mail处理程序，收件人的邮箱地址由E-mail超链接中指定的地址自动更新，无需浏览者输入。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mailto:邮箱地址&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="链接到FTP"><a href="#链接到FTP" class="headerlink" title="链接到FTP"></a>链接到FTP</h3><p>FTP代表文件传输协议，一个站点通常包含一些上传和下载的目录，大部分FTP网站需要用户使用用户名和密码来登录</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;ftp://地址&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>新版的edge浏览器似乎取消了对FTP的支持</p><h3 id="链接到Telnet"><a href="#链接到Telnet" class="headerlink" title="链接到Telnet"></a>链接到Telnet</h3><p>Telnet通常用来登录一些BBS网站，也是一种远程登录方式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;telnet://地址&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;文件地址&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>只要文件不是网页，单击链接的时候就会自动下载文件</p><h1 id="使用图像"><a href="#使用图像" class="headerlink" title="使用图像"></a>使用图像</h1><h2 id="插入图像及其属性"><a href="#插入图像及其属性" class="headerlink" title="插入图像及其属性"></a>插入图像及其属性</h2><p>插入图像的标记只有一个，那就是<strong>img</strong>标记，img元素的相关属性如下</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>src</td><td>图像的源文件</td></tr><tr><td>alt</td><td>提示文字</td></tr><tr><td>width，height</td><td>宽度和高度</td></tr><tr><td>border</td><td>边框</td></tr><tr><td>vspace</td><td>垂直间距</td></tr><tr><td>hspace</td><td>水平间距</td></tr><tr><td>align</td><td>排序</td></tr><tr><td>dynsrc</td><td>设定avi文件的播放</td></tr><tr><td>loop</td><td>设定avi文件循环播放次数</td></tr><tr><td>loopdelay</td><td>设定avi文件循环播放延迟</td></tr><tr><td>start</td><td>设定avi文件播放方式</td></tr><tr><td>lowsrc</td><td>设定低分辨率图片</td></tr><tr><td>usemap</td><td>映像地图</td></tr></tbody></table><h3 id="图像的源文件src"><a href="#图像的源文件src" class="headerlink" title="图像的源文件src"></a>图像的源文件src</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;图像文件地址&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以使用http:&#x2F;&#x2F;关键字作为图像的地址</p><h3 id="图像的提示文字alt"><a href="#图像的提示文字alt" class="headerlink" title="图像的提示文字alt"></a>图像的提示文字alt</h3><p>当图片被下载后，把鼠标悬停在图像上会显示提示文字，如果没下载，则显示空白，悬停空白页会显示提示文字</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;图像地址&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;提示文字的内容&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="图像的高度和宽度width、height"><a href="#图像的高度和宽度width、height" class="headerlink" title="图像的高度和宽度width、height"></a>图像的高度和宽度width、height</h3><p>如果不定义高度和宽度，则按原始尺寸显示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;图像地址&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;图像宽度&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;图像高度&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>单位是像素，无论设置什么大小，整张图片都会被加载，所以不会改变加载速度</p><h2 id="图像的超链接"><a href="#图像的超链接" class="headerlink" title="图像的超链接"></a>图像的超链接</h2><p>图像页可以设置超链接，同一个图像的不同部分也可以链接到不同的文档，这就是<strong>热区链接</strong></p><h3 id="图像的超链接-1"><a href="#图像的超链接-1" class="headerlink" title="图像的超链接"></a>图像的超链接</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;链接地址&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;图像地址&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>由于使用&lt;a&gt;,所以可以配合前面说过的属性使用。</p><h3 id="热区链接"><a href="#热区链接" class="headerlink" title="热区链接"></a>热区链接</h3><p>在HTML中可以把图片划分为多个热点区域，每一个热点区域链接到不同的网页，这种效果的是指是把一幅图片分为不同的热点区域，再让不同区域进行链接，这就是映射地图。</p><p><strong>语法</strong>：首先要先在图像文件中设置映像图像名，在图像的属性中使用&lt;usemap&gt;标记添加图像要引用的映射图像的名称</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;图像地址&quot;</span> <span class="hljs-attr">usemap</span>=<span class="hljs-string">&quot;映像图像名称&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后定义热区图像以及热区的链接属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;映射图像名称&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">area</span> <span class="hljs-attr">shape</span>=<span class="hljs-string">&quot;#热区形状&quot;</span> <span class="hljs-attr">coords</span>=<span class="hljs-string">&quot;热区坐标&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;链接地址&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>说明</strong>：<strong>name</strong>用来定义映射图名称，<strong>shape</strong>定义热区形状，<strong>coords</strong>定义热区的坐标，不同的热区形状有不同的坐标写法，推荐使用***<a href="https://www.adobe.com/cn/products/dreamweaver.html">Dreamweaver</a><em><strong>绘制,下面是</strong>shaper</em>*属性值和对应得<strong>coords</strong>写法</p><table><thead><tr><th>shape</th><th>coords</th></tr></thead><tbody><tr><td>rect-正方形</td><td>x1,y1,x2,y2</td></tr><tr><td>circle-圆形</td><td>x,y,r</td></tr><tr><td>poly-多边形</td><td>x1,y1,x2,y2,x3,y3……xn,yn</td></tr></tbody></table><h1 id="使用列表"><a href="#使用列表" class="headerlink" title="使用列表"></a>使用列表</h1><p>HTML列表共有三种：无序列表，有序列表，定义列表</p><h2 id="有序列表ol"><a href="#有序列表ol" class="headerlink" title="有序列表ol"></a>有序列表ol</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>有序列表项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>有序列表项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>有序列表项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>有序列表项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="有序列表的序号类型type"><a href="#有序列表的序号类型type" class="headerlink" title="有序列表的序号类型type"></a>有序列表的序号类型type</h3><p>默认情况下，有序列表的序号是用数字表示，但可以通过<strong>type</strong>属性改变序号的类型</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;序号类型&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>有序列表项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><p>序号类型有5种：</p><table><thead><tr><th>类型值</th><th>列表项目的序号类型</th></tr></thead><tbody><tr><td>1</td><td>数字1，2，3…</td></tr><tr><td>a</td><td>小写字母a,b,c…</td></tr><tr><td>A</td><td>大写字母A,B,C…</td></tr><tr><td>i</td><td>小写罗马字母i,ii,iii,iv…</td></tr><tr><td>I</td><td>大写罗马字母I,II,III,IV…</td></tr></tbody></table><p class="note note-info">type属性仅仅适用于有序列表和无序列表，并不适用于目录列表、自定义项和菜单列表</p><h3 id="有序列表的起始数值start"><a href="#有序列表的起始数值start" class="headerlink" title="有序列表的起始数值start"></a>有序列表的起始数值start</h3><p>默认情况下，有序列表的序号是从1开始的，通过start属性可以调整序号的起始值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">start</span>=<span class="hljs-string">&quot;起始值&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>有序列表项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>无序列表除了不使用数字和字母以外，其他于有序列表相似</p><h3 id="无序列表ul"><a href="#无序列表ul" class="headerlink" title="无序列表ul"></a>无序列表ul</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="无序列表的类型type"><a href="#无序列表的类型type" class="headerlink" title="无序列表的类型type"></a>无序列表的类型type</h3><p>默认情况下是&amp;bull;而通过type参数可以调整无序列表的项目符号</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;符号类型&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>type</strong>可以设置的值有：</p><table><thead><tr><th>类型值</th><th>列表项目的符号</th></tr></thead><tbody><tr><td>disc</td><td>&amp;bull;实心圆</td></tr><tr><td>circle</td><td>&amp;omicron;空心圆</td></tr><tr><td>square</td><td>■正方形</td></tr></tbody></table><h2 id="定义列表标记dl"><a href="#定义列表标记dl" class="headerlink" title="定义列表标记dl"></a>定义列表标记dl</h2><p>定义列表由两部分组成：<strong>定义条件</strong>和<strong>定义描述</strong>&lt;dt&gt;用来指定需要解释的名词，&lt;di&gt;是具体的解释</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>定义条件<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>定义描述<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br></code></pre></td></tr></table></figure><p>实例与效果：</p><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>定义列表<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>定义列表由定义条件和定义描述构成，用来解释指定的名词<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br></code></pre></td></tr></table></figure><dl>    <dt>定义列表</dt>    <dd>定义列表由定义条件和定义描述构成，用来解释指定的名词</dd></dl></blockquote><p class="note note-info">尽管在一个自定义列表之外使用&lt;dd>标记缩进文本非常有用，但这并不是有效的HTML语法，可能会在部分浏览器中造成难以预料的后果</p><h2 id="菜单列表标记menu"><a href="#菜单列表标记menu" class="headerlink" title="菜单列表标记menu"></a>菜单列表标记menu</h2><p>菜单列表在浏览器和无序列表的显示效果是相同的，它的功能也可以通过无序列表来实现</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">menu</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">menu</span>&gt;</span><br></code></pre></td></tr></table></figure><p>实例与效果：</p><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Html">前端三件套：<br><span class="hljs-tag">&lt;<span class="hljs-name">menu</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>HTML<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>CSS<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>JavaScript<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">menu</span>&gt;</span><br></code></pre></td></tr></table></figure><p>前端三件套：</p><menu>    <li>HTML</li>    <li>CSS</li>    <li>JavaScript</li></menu></blockquote><h1 id="使用表格"><a href="#使用表格" class="headerlink" title="使用表格"></a>使用表格</h1><h2 id="创建表格"><a href="#创建表格" class="headerlink" title="创建表格"></a>创建表格</h2><h3 id="表格的基本构成table、tr、td"><a href="#表格的基本构成table、tr、td" class="headerlink" title="表格的基本构成table、tr、td"></a>表格的基本构成table、tr、td</h3><p>表格由<strong>行、列、单元格</strong>组成，一般通过三个标记来创建，分别是表格标记&lt;table&gt;、行标记&lt;tr&gt;、单元格&lt;td&gt;</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tl</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>第一行，第一列<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>第二行，第二列<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tl</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tl</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>第二行，第一列<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>第二行，第二列<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tl</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="设置表格的标题caption"><a href="#设置表格的标题caption" class="headerlink" title="设置表格的标题caption"></a>设置表格的标题caption</h3><p>可以使用&lt;caption&gt;来设置标题单元格，表格的标题一般位于整个表格的第一行，一个表格只能有一个</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">caption</span>&gt;</span>表格标题<span class="hljs-tag">&lt;/<span class="hljs-name">caption</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>单元格内容<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><p>实例与效果</p><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">caption</span>&gt;</span>成绩表<span class="hljs-tag">&lt;/<span class="hljs-name">caption</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>语文<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>100<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>数学<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>100<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>英语<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>100<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><table>    <caption>成绩表</caption>    <tr>        <td>语文</td>        <td>100</td>    </tr>    <tr>        <td>数学</td>        <td>100</td>    </tr>    <tr>        <td>英语</td>        <td>100</td>    </tr></table></blockquote><h3 id="表头th"><a href="#表头th" class="headerlink" title="表头th"></a>表头th</h3><p>表格的表头**&lt;th&gt;<strong>实际是</strong>&lt;td&gt;**单元格的一种变体，实质上仍是一种单元格，一般位于表格的第一行和第一列，用来表示这一行或列的内容类别。一般，浏览器会以粗体和居中的方式显示<th>元素中的内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>单元格内容<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>单元格内容<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><p>th的起始标记必须有，但结束标记是可有可无的。</p><h2 id="表格的基本属性"><a href="#表格的基本属性" class="headerlink" title="表格的基本属性"></a>表格的基本属性</h2><h3 id="表格的宽度width"><a href="#表格的宽度width" class="headerlink" title="表格的宽度width"></a>表格的宽度width</h3><p>如果不指定宽度，浏览器就会根据内容的多少自动调整宽度</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;宽度&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>说明</strong>：表格宽度的值可以是像素，也可以是百分比，百分比的话会根据浏览器窗口大小改变</p><h3 id="表格的高度height"><a href="#表格的高度height" class="headerlink" title="表格的高度height"></a>表格的高度height</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;高度&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>说明</strong>：同上，单位可以是像素也可以是百分比。</p><h3 id="表格的对齐方式align"><a href="#表格的对齐方式align" class="headerlink" title="表格的对齐方式align"></a>表格的对齐方式align</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;对齐方式&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>参数如下：</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>left</td><td>整个表格在浏览器页面中左对齐</td></tr><tr><td>center</td><td>整个表格在浏览器页面中居中对齐</td></tr><tr><td>right</td><td>整个表格再浏览器页面中右对齐</td></tr></tbody></table><p class="note note-info">虽然会改变表格的对齐方式，但单元格内的对齐方式并没有改变，要改变，可以在对应的行、列或单元格内用align定义</p><h2 id="表格边框"><a href="#表格边框" class="headerlink" title="表格边框"></a>表格边框</h2><h3 id="表格边框宽度border"><a href="#表格边框宽度border" class="headerlink" title="表格边框宽度border"></a>表格边框宽度border</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;边框宽度&quot;</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><p>只要宽度不为0，就会出现边框</p><h3 id="表格边框颜色bordercolor"><a href="#表格边框颜色bordercolor" class="headerlink" title="表格边框颜色bordercolor"></a>表格边框颜色bordercolor</h3><p>默认情况下，边框颜色为灰色，可以通过bordercolor设置颜色</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;边框宽度&quot;</span> <span class="hljs-attr">bordercolor</span>=<span class="hljs-string">&quot;边框颜色&quot;</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>说明</strong>：边框颜色可以是十六进制的颜色值，也可以是对应颜色的英文。</p><h3 id="内框宽度cellspacing"><a href="#内框宽度cellspacing" class="headerlink" title="内框宽度cellspacing"></a>内框宽度cellspacing</h3><p>表格的内框宽度用于设置表格内每单元格之间的间距</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">cellspacing</span>=<span class="hljs-string">&quot;内框宽度值&quot;</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><p>内框的单位是像素</p><h3 id="表格内文字与边框间距cellpadding"><a href="#表格内文字与边框间距cellpadding" class="headerlink" title="表格内文字与边框间距cellpadding"></a>表格内文字与边框间距cellpadding</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">cellpadding</span>=<span class="hljs-string">&quot;文字与边框的距离&quot;</span></span><br></code></pre></td></tr></table></figure><h2 id="表格背景"><a href="#表格背景" class="headerlink" title="表格背景"></a>表格背景</h2><h3 id="表格背景颜色bgcolor"><a href="#表格背景颜色bgcolor" class="headerlink" title="表格背景颜色bgcolor"></a>表格背景颜色bgcolor</h3><p>表格的背景颜色属性<strong>bgcolor</strong>是针对整个表格的，bgcolor定义的颜色可以被行、列或单元格定义的背景颜色覆盖</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">bgcolor</span>=<span class="hljs-string">“背景颜色</span>&quot;&gt;</span><br>                     <br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="表格背景图像"><a href="#表格背景图像" class="headerlink" title="表格背景图像"></a>表格背景图像</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">background</span>=<span class="hljs-string">&quot;背景图像地址&quot;</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="表格的行属性"><a href="#表格的行属性" class="headerlink" title="表格的行属性"></a>表格的行属性</h2><h3 id="高度控制height"><a href="#高度控制height" class="headerlink" title="高度控制height"></a>高度控制height</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;行的高度&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="边框颜色bordercolor"><a href="#边框颜色bordercolor" class="headerlink" title="边框颜色bordercolor"></a>边框颜色bordercolor</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">bordercolor</span>=<span class="hljs-string">&quot;边框的颜色&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="行的背景bgcolor、background"><a href="#行的背景bgcolor、background" class="headerlink" title="行的背景bgcolor、background"></a>行的背景bgcolor、background</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">bgcolor</span>=<span class="hljs-string">&quot;行的背景颜色&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">background</span>=<span class="hljs-string">&quot;行的背景图片地址&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="行文字的水平对齐方式align"><a href="#行文字的水平对齐方式align" class="headerlink" title="行文字的水平对齐方式align"></a>行文字的水平对齐方式align</h3><p>默认为左对齐</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;对齐方式&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br></code></pre></td></tr></table></figure><p>align的属性值有以下三种：</p><table><thead><tr><th>属性值</th><th>效果</th></tr></thead><tbody><tr><td>left</td><td>左对齐</td></tr><tr><td>center</td><td>水平居中</td></tr><tr><td>right</td><td>右对齐</td></tr></tbody></table><h3 id="行文字的垂直对齐方式valign"><a href="#行文字的垂直对齐方式valign" class="headerlink" title="行文字的垂直对齐方式valign"></a>行文字的垂直对齐方式valign</h3><p>默认为垂直居中对齐</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">valign</span>=<span class="hljs-string">&quot;对齐方式&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br></code></pre></td></tr></table></figure><p>行文字的垂直对齐方式有三种：</p><table><thead><tr><th>属性值</th><th>效果</th></tr></thead><tbody><tr><td>top</td><td>顶端对齐</td></tr><tr><td>middle</td><td>垂直居中</td></tr><tr><td>bottom</td><td>底部对齐</td></tr></tbody></table><h2 id="单元格属性"><a href="#单元格属性" class="headerlink" title="单元格属性"></a>单元格属性</h2><p class="note note-warning">注意，该部分内容可能仅适用于ie等浏览器。经尝试edge、火狐、Google均不再使用</p><h3 id="单元格大小width、height"><a href="#单元格大小width、height" class="headerlink" title="单元格大小width、height"></a>单元格大小width、height</h3><p>默认情况下，党员个的宽度和高度会根据内容自动调整</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;宽度&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;高度&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="水平跨度clospan"><a href="#水平跨度clospan" class="headerlink" title="水平跨度clospan"></a>水平跨度clospan</h3><p>在使用表格时，有时候需要将两个或多个相邻的单元格合并</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">clospan</span>=<span class="hljs-string">&quot;跨度的列数&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="垂直跨度rowspan"><a href="#垂直跨度rowspan" class="headerlink" title="垂直跨度rowspan"></a>垂直跨度rowspan</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">rowspan</span>=<span class="hljs-string">&quot;跨度的行数&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="对齐方式align、valign"><a href="#对齐方式align、valign" class="headerlink" title="对齐方式align、valign"></a>对齐方式align、valign</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;水平对齐方式&quot;</span> <span class="hljs-attr">valign</span>=<span class="hljs-string">&quot;垂直对齐方式&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="单元格的背景色"><a href="#单元格的背景色" class="headerlink" title="单元格的背景色"></a>单元格的背景色</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">bgcolor</span>=<span class="hljs-string">&quot;背景色&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="单元格的边框颜色bordercolor"><a href="#单元格的边框颜色bordercolor" class="headerlink" title="单元格的边框颜色bordercolor"></a>单元格的边框颜色bordercolor</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">bordercolor</span>=<span class="hljs-string">&quot;边框颜色&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="单元格的亮边框bordercolorlight"><a href="#单元格的亮边框bordercolorlight" class="headerlink" title="单元格的亮边框bordercolorlight"></a>单元格的亮边框bordercolorlight</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">bordercolorlight</span>=<span class="hljs-string">&quot;颜色&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="单元格的暗边框bordercolordark"><a href="#单元格的暗边框bordercolordark" class="headerlink" title="单元格的暗边框bordercolordark"></a>单元格的暗边框bordercolordark</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">borderdark</span>=<span class="hljs-string">&quot;颜色&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="表格的结构"><a href="#表格的结构" class="headerlink" title="表格的结构"></a>表格的结构</h2><p>还有一些标记是用来做表格结构的，包括表首标记<strong>&lt;thead&gt;<strong>、表主体标记</strong>&lt;tbody&gt;<strong>以及表尾标记</strong>&lt;tfoo&gt;</strong></p><h3 id="表格的表首标记thead"><a href="#表格的表首标记thead" class="headerlink" title="表格的表首标记thead"></a>表格的表首标记thead</h3><p>用于定义表格最上端表首的样式，可以设置背景颜色、文字对齐方式、文字的垂直对齐方式等</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">thead</span> <span class="hljs-attr">bgcolor</span>=<span class="hljs-string">&quot;背景颜色&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;水平对齐方式&quot;</span> <span class="hljs-attr">valign</span>=<span class="hljs-string">&quot;垂直对齐方式&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br></code></pre></td></tr></table></figure><p>一个表格内只能有一个表首，<strong>&lt;thead&gt;里还可以包含&lt;**tr&gt;,&lt;td&gt;，且&lt;thead&gt;可以在&lt;table&gt;内的任意位置，</strong>无论在哪，&lt;thead&gt;内的行列单元格都会被放在第一行作为表首**</p><h3 id="表格的表主体标记tbody"><a href="#表格的表主体标记tbody" class="headerlink" title="表格的表主体标记tbody"></a>表格的表主体标记tbody</h3><p>表主体样式用于统一表主体部分的样式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">tbody</span> <span class="hljs-attr">bgcolor</span>=<span class="hljs-string">&quot;背景颜色&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;水平对齐方式&quot;</span> <span class="hljs-attr">valign</span>=<span class="hljs-string">&quot;垂直对齐方式&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="使用表单"><a href="#使用表单" class="headerlink" title="使用表单"></a>使用表单</h1><p>制作动态网页时常常用到表单，表单主要用来收集客户端提供的相关信息，使网页具有交互性，如文本域、列表框、复选框等</p><h2 id="表单标记form"><a href="#表单标记form" class="headerlink" title="表单标记form"></a>表单标记form</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="提交表单action"><a href="#提交表单action" class="headerlink" title="提交表单action"></a>提交表单action</h3><p>action用于指定表单数据提交到哪个地址进行处理</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;表单的处理地址&quot;</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="表单名称name"><a href="#表单名称name" class="headerlink" title="表单名称name"></a>表单名称name</h3><p><strong>name</strong>用于给表单命名，这一属性不是表单的必要属性，但是为了防止表单提交到后台处理程序时出现混乱，一般需要给表单命名</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;表单名称&quot;</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="传送方法method"><a href="#传送方法method" class="headerlink" title="传送方法method"></a>传送方法method</h3><p>method属性用于指定在数据提交单服务器的时候使用哪种HTTP提交方法，可取值为<strong>get或post</strong><br></p><ul><li>get：表单数据被传送到action属性指定的URL，然后这个新URL被送到处理程序上</li><li>post：表单数据被包含在表单主体中，然后被送到处理程序上</li></ul><h3 id="编码方式enctype"><a href="#编码方式enctype" class="headerlink" title="编码方式enctype"></a>编码方式enctype</h3><p>用于设置表单信息提交的编码方式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;编码方式&quot;</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>enctype属性为表单定义了MIME编码方式，编码方式取值如下：</p><table><thead><tr><th>enctype的取值</th><th>取值的含义</th></tr></thead><tbody><tr><td>application&#x2F;x-www-form-urlencoded</td><td>默认的编码形式</td></tr><tr><td>multipart&#x2F;form-data</td><td>MIME编码，上传文件的表单必须选择该项</td></tr></tbody></table><h3 id="目标显示方式target"><a href="#目标显示方式target" class="headerlink" title="目标显示方式target"></a>目标显示方式target</h3><p>target用来指定目标窗口的打开方式，表单的目标窗口往往用来显示表单的返回信息</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;目标窗口的打开方式&quot;</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>说明：</strong>打开方式有4个选项：**_blank、_parent、_self、_top**</p><h2 id="插入表单"><a href="#插入表单" class="headerlink" title="插入表单"></a>插入表单</h2><h3 id="文字字段text"><a href="#文字字段text" class="headerlink" title="文字字段text"></a>文字字段text</h3><p>用户可以在文字字段内输入字符或者单行文字</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;控件名称&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;文字字段的默认取值&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;控件的长度&quot;</span> <span class="hljs-attr">maxlength</span>=<span class="hljs-string">&quot;最长字符数&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p><strong>说明：</strong>该语法中包含的参数的含义、取值如下：</p><table><thead><tr><th>参数类型</th><th>含义</th></tr></thead><tbody><tr><td>type</td><td>用来指定插入哪种表单元素</td></tr><tr><td>name</td><td>密码域的名称，用于和页面中其他控件加以区别，名称由英文或数字以及下划线组成，有大小写区分</td></tr><tr><td>value</td><td>用来定义密码域的默认值，以星号*显示</td></tr><tr><td>size</td><td>确定文本框在页面中显示的长度，以字符为单位</td></tr><tr><td>maxlength</td><td>用来设置密码域的文本框中最多可以输入的字符数</td></tr></tbody></table><h3 id="密码域password"><a href="#密码域password" class="headerlink" title="密码域password"></a>密码域password</h3><p>密码域是一种特殊的文字字段，他的属性和文字字段是相同的，单密码域在输入时会显示为*号</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;控件名称&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;文字字段的默认取值&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;控件的长度&quot;</span> <span class="hljs-attr">maxlength</span>=<span class="hljs-string">&quot;最长字符数&quot;</span></span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：密码域仅仅是使周围人看不见密码，但并不能使数据安全。</p><h3 id="单选按钮radio"><a href="#单选按钮radio" class="headerlink" title="单选按钮radio"></a>单选按钮radio</h3><p>可以使用户从选择列表中选择一个选项</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;单选按钮名称&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;单选按钮的取值&quot;</span> <span class="hljs-attr">checked</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><strong>说明</strong>：单选按钮必须设置<strong>value</strong>的值，对于一个选择列表中的所有单选按钮来说，往往要设置为相同的名称，传递时才能更好地对某一个选择内容进行判断，在一个单选按钮组中只有一个单选按钮可以设置为<strong>checked</strong>，checked可以设置初始默认选项，若所有单选按钮都不设置，则没有初始选项</p><blockquote><p>效果与实例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;form1&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;单选按钮名称&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;单选按钮的取值&quot;</span> <span class="hljs-attr">checked</span>/&gt;</span>设置checked<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;单选按钮名称&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;单选按钮的取值&quot;</span>&gt;</span>不设置checked<br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><form>    <input name="单选按钮名称" type="radio" value="单选按钮的取值" checked/>设置checked    <input name="单选按钮名称" type="radio" value="单选按钮的取值">不设置checked</form><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;form2&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;单选按钮名称&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;单选按钮的取值&quot;</span>&gt;</span>不设置checked<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;单选按钮名称&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;单选按钮的取值&quot;</span>&gt;</span>不设置checked<br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><form name="form2">    <input name="单选按钮名称" type="radio" value="单选按钮的取值">不设置checked    <input name="单选按钮名称" type="radio" value="单选按钮的取值">不设置checked</form></blockquote><h3 id="复选框checkbox"><a href="#复选框checkbox" class="headerlink" title="复选框checkbox"></a>复选框checkbox</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;复选款名称&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">vaue</span>=<span class="hljs-string">&quot;复选框的取值&quot;</span> <span class="hljs-attr">checked</span>/&gt;</span><br></code></pre></td></tr></table></figure><h3 id="普通按钮button"><a href="#普通按钮button" class="headerlink" title="普通按钮button"></a>普通按钮button</h3><p>一般配合JavaScript使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;按钮名称&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;按钮的取值&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;处理程序&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><strong>说明</strong>：value的取值就是按钮上显示的文字</p><h3 id="提交按钮submit"><a href="#提交按钮submit" class="headerlink" title="提交按钮submit"></a>提交按钮submit</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;按钮名称&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;按钮的取值&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h3 id="重置按钮reset"><a href="#重置按钮reset" class="headerlink" title="重置按钮reset"></a>重置按钮reset</h3><p>重置按钮用来清除用户在页面中输入的信息</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;按钮名称&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;按钮取值&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h3 id="图像域image"><a href="#图像域image" class="headerlink" title="图像域image"></a>图像域image</h3><p>使用一副图像作为按钮</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;图像域名称&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;image&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;图像路径&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h3 id="隐藏域hidden"><a href="#隐藏域hidden" class="headerlink" title="隐藏域hidden"></a>隐藏域hidden</h3><p>有时候想传送一些数据，这些数据对于用户来说是不可见的。可以通过一个隐藏域来传送这样额数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;隐藏域名称&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;隐藏域的取值&quot;</span></span><br></code></pre></td></tr></table></figure><h3 id="文件域file"><a href="#文件域file" class="headerlink" title="文件域file"></a>文件域file</h3><p>文件域在上传文件时常常用到，它用于查找硬盘中的文件路径，然后通过表单将选中的文件上传，在上传图像时也常常用到。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;文字域名称&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;控件长度&quot;</span> <span class="hljs-attr">maxlength</span>=<span class="hljs-string">&quot;最长字符数&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h2 id="菜单和列表"><a href="#菜单和列表" class="headerlink" title="菜单和列表"></a>菜单和列表</h2><p>菜单和列表主要用来选择给定答案中的一种，这类选择中往往答案比较多。菜单和列表主要是为了节省页面的空间，他们都是通过**&lt;select&gt;和&lt;option&gt;**标记来实现</p><h3 id="下拉菜单"><a href="#下拉菜单" class="headerlink" title="下拉菜单"></a>下拉菜单</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;下拉菜单名称&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;选项值&quot;</span> <span class="hljs-attr">selected</span>&gt;</span>显示内容<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>说明</strong>：选项值是提交表单时的值，而在选项显示内容才是真正在页面中显示的，<strong>selected</strong>表示该选项在默认情况下是选中的，一个下拉菜单只能由一个默认选项被选中。下拉菜单的宽度是由最长文本的宽度决定的。</p><blockquote><p>效果与实例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;下拉菜单名称&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">selected</span>&gt;</span>选项1<br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span> &gt;</span>选项2<br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span> &gt;</span>选项3<br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;4&quot;</span> &gt;</span>选项4<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><select name="下拉菜单名称">    <option value="1" selected>选项1    <option value="2" selected>选项2    <option value="3" selected>选项3    <option value="4" selected>选项4</select></blockquote><h3 id="列表项"><a href="#列表项" class="headerlink" title="列表项"></a>列表项</h3><p>页面中的列表项可以显示几条信息，一旦超出这个数，就会产生滚动条。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;列表项名称&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;显示的列表项数&quot;</span> <span class="hljs-attr">multiple</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;选项值&quot;</span> <span class="hljs-attr">selected</span>&gt;</span>选项显示内容<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>说明</strong>：<strong>size</strong>用于设置列表项数，当超过这个数时就会出现滚动条。</p><blockquote><p>效果与实例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;列表项名称&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">multiple</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">selected</span>&gt;</span>选项1<br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span> &gt;</span>选项2<br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span> &gt;</span>选项3<br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;4&quot;</span> &gt;</span>选项4<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><select name="列表项名称" size="2" multiple>    <option value="1" selected>选项1    <option value="2" >选项2    <option value="3" >选项3    <option value="4" >选项4</select></blockquote><h2 id="文本域textarea"><a href="#文本域textarea" class="headerlink" title="文本域textarea"></a>文本域textarea</h2><p>当要让浏览器填入多行文字时，就应该使用哦文本域而不应该使用文字字段。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;文本域名称&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;列数&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;行数&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>说明</strong>：在语法中，不能使用value属性来建立一个在文本域中显示的初始值，且应当在<strong>textarea</strong>标记的开头和结尾之间包含想要在文本域内显示的任何文本。</p><blockquote><p>效果与实例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;18&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span>文本显示内容<span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br></code></pre></td></tr></table></figure><textarea name="1" cols="18" rows="3"> 文本显示内容</textarea></blockquote><h2 id="id标记"><a href="#id标记" class="headerlink" title="id标记"></a>id标记</h2><p>id标记是一个较为特色的标记，它主要用于标示一个唯一的元素。这个元素可以是文字字段，可以是密码域，也可以是其他的表单元素，甚至可以是一幅图像、一个表单</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;id= 元素的标识名&gt;<br></code></pre></td></tr></table></figure><p><strong>说明</strong>：在定义标签名时最好根据含义命名</p><blockquote><p>实例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">if</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure></blockquote><h1 id="添加多媒体"><a href="#添加多媒体" class="headerlink" title="添加多媒体"></a>添加多媒体</h1><p>除了文本和图像，还可以添加视频、动画、声音等元素</p><h2 id="设置滚动效果"><a href="#设置滚动效果" class="headerlink" title="设置滚动效果"></a>设置滚动效果</h2><h3 id="滚动标记marquee"><a href="#滚动标记marquee" class="headerlink" title="滚动标记marquee"></a>滚动标记marquee</h3><p>使用<strong>marquee</strong>不仅可以移动文字，还可以移动图片、表格等。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">marquee</span>&gt;</span>......<span class="hljs-tag">&lt;/<span class="hljs-name">marquee</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>说明</strong>：在标记之间添加要进行滚动的内容，并可以在标记之间设置为你或图像的属性</p><blockquote><p>实例与效果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">marquee</span>&gt;</span>滚动<span class="hljs-tag">&lt;/<span class="hljs-name">marquee</span>&gt;</span><br></code></pre></td></tr></table></figure><p><marquee>滚动</marquee></p></blockquote><h3 id="设置滚动方向direction"><a href="#设置滚动方向direction" class="headerlink" title="设置滚动方向direction"></a>设置滚动方向direction</h3><p>默认是从右向左移动，可以通过<strong>direction</strong>设置不同的滚动方向</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">marquee</span> <span class="hljs-attr">direction</span>=<span class="hljs-string">&quot;滚动方向&quot;</span>&gt;</span>......<span class="hljs-tag">&lt;/<span class="hljs-name">marquee</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>说明</strong>：滚动方向有四个取值：<strong>up、down、left、right</strong>，即向上、向下、向左、向右</p><h3 id="滚动方式behavior"><a href="#滚动方式behavior" class="headerlink" title="滚动方式behavior"></a>滚动方式behavior</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">marquee</span> <span class="hljs-attr">behavior</span>=<span class="hljs-string">&quot;滚动方式&quot;</span>&gt;</span>......<span class="hljs-tag">&lt;/<span class="hljs-name">marquee</span>&gt;</span><br></code></pre></td></tr></table></figure><p>滚动方式如下：</p><table><thead><tr><th>behavior</th><th>滚动效果</th></tr></thead><tbody><tr><td>scroll</td><td>循环滚动，默认效果</td></tr><tr><td>slide</td><td>只滚动一次就停止</td></tr><tr><td>alternate</td><td>来回交替滚动</td></tr></tbody></table><h3 id="滚动速度srollamount"><a href="#滚动速度srollamount" class="headerlink" title="滚动速度srollamount"></a>滚动速度srollamount</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">marquee</span> <span class="hljs-attr">srollamount</span>=<span class="hljs-string">&quot;滚动速度&quot;</span>&gt;</span>......<span class="hljs-tag">&lt;/<span class="hljs-name">marquee</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>说明</strong>：实际上是设置每次滚动时移动的长度，单位是像素</p><p class="note note-warning">edge已不支持<h3 id="滚动延迟scrolldelay"><a href="#滚动延迟scrolldelay" class="headerlink" title="滚动延迟scrolldelay"></a>滚动延迟scrolldelay</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">marquee</span> <span class="hljs-attr">scrolldelay</span>=<span class="hljs-string">&quot;时间间隔&quot;</span>&gt;</span>......<span class="hljs-tag">&lt;/<span class="hljs-name">marquee</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>说明</strong>：时间间隔的单位是毫秒</p><h3 id="滚动循环loop"><a href="#滚动循环loop" class="headerlink" title="滚动循环loop"></a>滚动循环loop</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">marquee</span> <span class="hljs-attr">loop</span>=<span class="hljs-string">&quot;循环次数&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">marquee</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>说明</strong>：默认情况下会一直滚动下去，可以设置滚动几次后停止</p><h3 id="滚动范围width、height"><a href="#滚动范围width、height" class="headerlink" title="滚动范围width、height"></a>滚动范围width、height</h3><p>如果不设置滚动范围，默认情况下，水平滚动的文字背景与文字同高、与浏览器窗口同宽，使用了width和height参数可以调整其水平和垂直的范围</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">marquee</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;背景宽度&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;背景高度&quot;</span>&gt;</span>......<span class="hljs-tag">&lt;/<span class="hljs-name">marquee</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="滚动背景颜色bgcolor"><a href="#滚动背景颜色bgcolor" class="headerlink" title="滚动背景颜色bgcolor"></a>滚动背景颜色bgcolor</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">marquee</span> <span class="hljs-attr">bgcolor</span>=<span class="hljs-string">&quot;背景颜色&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">marquee</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>说明</strong>：背景颜色为十六进制的颜色</p><h3 id="空白空间hspace、vspace"><a href="#空白空间hspace、vspace" class="headerlink" title="空白空间hspace、vspace"></a>空白空间hspace、vspace</h3><p>默认情况下，滚动对象周围的文字或图像是与滚动背景紧密结合的，使用<strong>hspace、vspace</strong>可以设置他们之间的空白空间</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">marquee</span> <span class="hljs-attr">hspace</span>=<span class="hljs-string">&quot;水平范围&quot;</span> <span class="hljs-attr">vspace</span>=<span class="hljs-string">&quot;垂直范围&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">marquee</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="插入多媒体文件"><a href="#插入多媒体文件" class="headerlink" title="插入多媒体文件"></a>插入多媒体文件</h2><h3 id="插入Flsh动画"><a href="#插入Flsh动画" class="headerlink" title="插入Flsh动画"></a>插入Flsh动画</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">embed</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;文件地址&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;宽度&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;高度&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">embed</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="插入音频和视频"><a href="#插入音频和视频" class="headerlink" title="插入音频和视频"></a>插入音频和视频</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">embed</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;多媒体文件地址&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;播放界面的宽度&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;播放界面的高度&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">embed</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="HTML5入门基础"><a href="#HTML5入门基础" class="headerlink" title="HTML5入门基础"></a>HTML5入门基础</h1><h2 id="HTML5中语法中的三个要点"><a href="#HTML5中语法中的三个要点" class="headerlink" title="HTML5中语法中的三个要点"></a>HTML5中语法中的三个要点</h2><h3 id="可以省略的标签的元素"><a href="#可以省略的标签的元素" class="headerlink" title="可以省略的标签的元素"></a>可以省略的标签的元素</h3><p>在HTML5中，有些元素可以省略标签，具体有三种：</p><ul><li><p>不允许写结束符的标签:</p><p>  area、base、br、col、command、embed、hr、img、input、keygen、link、meta、param、source、track、wbr</p></li><li><p>可以省略结束符的标签</p><p>  li、dt、dd、p、rt、rp、optground、option、colground、thead、tbody、tfoot、tr、td、th</p></li><li><p>可以省略整个标签</p><p>  HTML、head、body、colground、tbody</p></li></ul><h3 id="取得boolean的属性"><a href="#取得boolean的属性" class="headerlink" title="取得boolean的属性"></a>取得boolean的属性</h3><p>例如disabled属性和readonly属性，通过默认属性的值来表达”值为true”。此外，在属性值为true时，可以将属性值设为属性名称本身，也可以将值设为空字符串，如：一下checked的值都为true</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">checked</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">checked</span>=<span class="hljs-string">&quot;checked&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">checked</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="省略属性的引用符"><a href="#省略属性的引用符" class="headerlink" title="省略属性的引用符"></a>省略属性的引用符</h3><p>在HTML4中设置属性值时，可以适用双引号或单引号来引用，在HTML5中，只要属性值<strong>不包含空格、括号，单引号、双引号、等于号等字符</strong>，都可以省略属性的引用符。如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;text&#x27;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">text</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="HTML5中新增的元素和废除的元素"><a href="#HTML5中新增的元素和废除的元素" class="headerlink" title="HTML5中新增的元素和废除的元素"></a>HTML5中新增的元素和废除的元素</h2><h3 id="新增的结构元素"><a href="#新增的结构元素" class="headerlink" title="新增的结构元素"></a>新增的结构元素</h3><p>HTML4缺少了结构，必须分析标题的级别，才能看出各个部分的划分方式。边栏、页眉、页脚、导航条等都用通用的<strong>div</strong>元素表示</p><p>HTML5新增了一些新元素，专门用来标识这些常见的结构，不再需要为Div的命名操心，对于手机、阅读器等设备更有好处</p><ul><li>section：可以表达书本的一部分或一章，或者一章内的一节</li><li>header：页面主体的头部，并非head元素</li><li>footer：页面的底部（页脚），可以是一封邮件签名的所在</li><li>nav：到其他页面的链接合集</li><li>article：博文、杂志、文章汇编等中的一篇文章</li></ul><h4 id="section"><a href="#section" class="headerlink" title="section"></a>section</h4><p>表示页面中的一个内容区块，比如章节、页眉、或页面中的其他部分，可以与h1,h2等元素结合起来使用，标示文档结构。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="header"><a href="#header" class="headerlink" title="header"></a>header</h4><p>表示页面中的一个内容区块或者整个页面的标题</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="footer"><a href="#footer" class="headerlink" title="footer"></a>footer</h4><p>表示整个页面或者页面中的一个内容区块的脚注，一般来说，他会包含作者的姓名日期等</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="nav"><a href="#nav" class="headerlink" title="nav"></a>nav</h4><p>表示页面中导航链接的部分</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="article"><a href="#article" class="headerlink" title="article"></a>article</h4><p>表示页面中的一块与上下文无相关的独立内容，如博客中的一篇文章，报纸中的一篇文章</p><h3 id="新增块级元素"><a href="#新增块级元素" class="headerlink" title="新增块级元素"></a>新增块级元素</h3><p>HTML5还增加了一些纯语义性的块级元素：</p><ul><li>aside：定义页面内容之外的内容，比如侧边栏</li><li>figur：定义媒介内容的分组，以及它们的标题</li><li>figcaption：媒介内容的标题说明</li><li>dialog：定义对话（会话）</li></ul><p>aside元素表示一段独立的流内容，一般表示文档主题流内容中的一个独立单元，使用figcaption为figue元素组添加标题，如下：插入了图片和图片的标题</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML4写法 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;index.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;xxxy有限公司&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    xxxy有限公司<br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-comment">&lt;!-- HTML5写法 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">figure</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;index.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;xxxy有限公司&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">figcaption</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>            xxxy有限公司<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">figcaption</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">figure</span>&gt;</span><br></code></pre></td></tr></table></figure><p>HTML5通过采用figure元素对此进行了改正，当和figue和figcaption同时出项时，我们通过语义化就能联想到这是<strong>图片对应的标题</strong></p><p><br>dialog元素用于表达人们之间的对话。在HTML5中，<strong>dt</strong>用于表示说话者，<strong>dd</strong>则表示说话内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dialog</span> <span class="hljs-attr">open</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>问<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>问题内容<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>答<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>回答内容<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dialog</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="新增的行内的语义元素"><a href="#新增的行内的语义元素" class="headerlink" title="新增的行内的语义元素"></a>新增的行内的语义元素</h3><ul><li>mark：定义有记号的文本</li><li>time：定义日期&#x2F;时间</li><li>meter：定义预定义范围内的度量</li><li>progress：定义运行中的进度</li></ul><p><strong>mark</strong>用来高显某些字符，如<mark>这样</mark></p><hr><p><strong>time</strong>元素用来定义时间或日期，该元素可以代表24小时中的某一时刻，允许有时间差在设置时间或日期时，只需将该元素的属性<strong>datetime</strong>设为相应的时间或日期即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">time</span> <span class="hljs-attr">datetime</span>=<span class="hljs-string">&quot;2023-7-18&quot;</span>&gt;</span>今天是2023年7月8日<span class="hljs-tag">&lt;/<span class="hljs-name">time</span>&gt;</span><br></code></pre></td></tr></table></figure><p>页面在解析时，获取的是属性datetime中的值<br></p><hr><p><strong>progress</strong>是新增的状态交互元素，用来表示页面中某个任务的完成进度，比如下载文件时，可以通过该元素动态展示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">progress</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">progress</span>&gt;</span><br></code></pre></td></tr></table></figure><p>value为当前进度，max为最大值，若不填则进度条会来回动<br></p><p>填：<progress value="1" max="2"></progress><br></p><p>不填：<progress></progress></p><hr><p><strong>meter</strong>元素用于表示在一定数量范围中的值，如投票中，各个人占的比例，或考试分数等，和progress相比适用于静态</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meter</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;当前度量&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;理论最大值,默认1&quot;</span> <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;理论最小值，默认0&quot;</span>  <span class="hljs-attr">high</span>=<span class="hljs-string">&quot;高值区的下限&quot;</span> <span class="hljs-attr">low</span>=<span class="hljs-string">&quot;低值区的上限&quot;</span> <span class="hljs-attr">optimum</span>=<span class="hljs-string">&quot;最优值&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">meter</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>说明</strong>：当<strong>value</strong>位于[min,low]、[low,high]、[high,max]不同区间时，浏览器会有不同的视觉效果。<strong>optimum</strong>不写则默认在[low,high]区间</p><blockquote><p>实例与效果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--不写optimum--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meter</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">high</span>=<span class="hljs-string">&quot;60&quot;</span> <span class="hljs-attr">low</span>=<span class="hljs-string">&quot;30&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">meter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meter</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">high</span>=<span class="hljs-string">&quot;60&quot;</span> <span class="hljs-attr">low</span>=<span class="hljs-string">&quot;30&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">meter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meter</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;70&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">high</span>=<span class="hljs-string">&quot;60&quot;</span> <span class="hljs-attr">low</span>=<span class="hljs-string">&quot;30&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">meter</span>&gt;</span><br></code></pre></td></tr></table></figure><p><meter value="10" max="100" min="0" high="60" low="30"></meter><br><meter value="50" max="100" min="0" high="60" low="30"></meter><br><meter value="70" max="100" min="0" high="60" low="30"></meter></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--使用optimum并位于高区间--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meter</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">high</span>=<span class="hljs-string">&quot;60&quot;</span> <span class="hljs-attr">low</span>=<span class="hljs-string">&quot;30&quot;</span> <span class="hljs-attr">optimum</span>=<span class="hljs-string">&quot;90&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">meter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meter</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">high</span>=<span class="hljs-string">&quot;60&quot;</span> <span class="hljs-attr">low</span>=<span class="hljs-string">&quot;30&quot;</span> <span class="hljs-attr">optimum</span>=<span class="hljs-string">&quot;90&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">meter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meter</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;70&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">high</span>=<span class="hljs-string">&quot;60&quot;</span> <span class="hljs-attr">low</span>=<span class="hljs-string">&quot;30&quot;</span> <span class="hljs-attr">optimum</span>=<span class="hljs-string">&quot;90&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">meter</span>&gt;</span><br></code></pre></td></tr></table></figure><p><meter value="10" max="100" min="0" high="60" low="30" optimum="90"></meter><br><meter value="50" max="100" min="0" high="60" low="30" optimum="90"></meter><br><meter value="70" max="100" min="0" high="60" low="30" optimum="90"></meter></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--使用optimum并位于低区间--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meter</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">high</span>=<span class="hljs-string">&quot;60&quot;</span> <span class="hljs-attr">low</span>=<span class="hljs-string">&quot;30&quot;</span> <span class="hljs-attr">optimum</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">meter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meter</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">high</span>=<span class="hljs-string">&quot;60&quot;</span> <span class="hljs-attr">low</span>=<span class="hljs-string">&quot;30&quot;</span> <span class="hljs-attr">optimum</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">meter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meter</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;70&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">high</span>=<span class="hljs-string">&quot;60&quot;</span> <span class="hljs-attr">low</span>=<span class="hljs-string">&quot;30&quot;</span> <span class="hljs-attr">optimum</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">meter</span>&gt;</span><br></code></pre></td></tr></table></figure><p><meter value="10" max="100" min="0" high="60" low="30" optimum="20"></meter><br><meter value="50" max="100" min="0" high="60" low="30" optimum="20"></meter><br><meter value="70" max="100" min="0" high="60" low="30" optimum="20"></meter></p></blockquote><h3 id="新增的嵌入多媒体元素与交互性元素"><a href="#新增的嵌入多媒体元素与交互性元素" class="headerlink" title="新增的嵌入多媒体元素与交互性元素"></a>新增的嵌入多媒体元素与交互性元素</h3><ul><li><p><strong>video</strong>：定义视频</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;视频地址&quot;</span> <span class="hljs-attr">controls</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure>  <table>  <tbody><tr>      <th align="left" width="20%">属性</th>          <th align="left" width="20%">值</th>          <th align="left" width="50%">描述</th>        </tr>      <tr>      <td>      autoplay      </td>          <td>autoplay</td>          <td>如果出现该属性，则视频在就绪后马上播放。</td>        </tr>      <tr>      <td>      controls      </td>          <td>controls</td>          <td>如果出现该属性，则向用户显示控件，比如播放按钮。</td>        </tr>      <tr>      <td>      height      </td>          <td><i>pixels</i></td>          <td>设置视频播放器的高度。</td>            </tr>      <tr>      <td>      loop      </td>          <td>loop</td>          <td>如果出现该属性，则当媒介文件完成播放后再次开始播放。</td>        </tr>      <tr>      <td>      muted      </td>          <td>muted</td>          <td>如果出现该属性，视频的音频输出为静音。</td>        </tr>      <tr>      <td valign="top">      poster      </td>          <td valign="top"><em>URL</em></td>          <td valign="top">规定视频正在下载时显示的图像，直到用户点击播放按钮。</td>          </tr>      <tr>      <td>      preload      </td>          <td>auto<br>          metadata<br>          none</td>          <td>如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 "autoplay"，则忽略该属性。      </td>        </tr>      <tr>      <td>      src      </td>          <td><i>URL</i></td>          <td>要播放的视频的 URL。</td>        </tr>      <tr>      <td>      width      </td>          <td><i>pixels</i></td>          <td>设置视频播放器的宽度。</td>        </tr>      </tbody>      </table></li></ul><p><strong>说明</strong>：可以在video中间插入文字”您的浏览器不支持播放视频”，这样浏览器不支持该元素的时候，就会看到这行字</p><ul><li><p><strong>audio</strong>：定义音频</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;地址&quot;</span> <span class="hljs-attr">controls</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>embed</strong>：用来插入各种多媒体，格式可以是MIDI.WAV,AIFF,AU,MP3等</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">embed</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;地址&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="新增的input元素的类型"><a href="#新增的input元素的类型" class="headerlink" title="新增的input元素的类型"></a>新增的input元素的类型</h3><ul><li><p><strong>url类型</strong>：是专门用来输入url地址的文本框，若输入不是url地址则不允许提交</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;url&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>email类型</strong>：如果不是email格式，无法提交</p></li><li><p><strong>date类型</strong>：date类型是以日历的形式来方便用户输入的</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;date&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure>  <form>      <input type="date" />  </form></li><li><p><strong>datetime类型</strong>：专门用来输入本地日期和时间的文本框，提交时会进行检查</p></li></ul><h3 id="废除的元素"><a href="#废除的元素" class="headerlink" title="废除的元素"></a>废除的元素</h3><ul><li><strong>能够使用CSS 代替的元素</strong>：对于basefont、big、center、font、s、strike、tt、u这些元素，由于它们的功能都是纯粹为页面样式服务的，而HTML5中提倡把页面样式功能放在CSS样式表中</li><li><strong>不再使用frame框架</strong>：对于framset元素、frame元素和noframes元素，由于frame框架对网页可用性存在负面影响，在HTML5中不再支持frame框架，只支持iframe框架。</li><li>只有部分浏览器支持的元素</li><li>对于applet、bgsound、blink、marquee等元素，由于只有部分浏览器支持这些元素，所以在HTML5中被废除，其中applet元素可被embed元素或objec元素替代，bgsound元素由audio元素替代，marquee由JavaScript编程的方式替代</li><li>其他被废除的元素<ul><li>废除acronym元素，使用abbr元素替代</li><li>废除dir元素，使用ul元素替代</li><li>废除isindex元素，使用form元素与input元素相结合的方式替代</li><li>废除listing元素，使用pre元素替代</li><li>废除xmp元素，使用code元素替代</li><li>废除nextid元素，使用GUIDS替代</li><li>废除plaintext元素，使用”text&#x2F;plian”MIME类型替代</li></ul></li></ul><h2 id="新增和废除的属性"><a href="#新增和废除的属性" class="headerlink" title="新增和废除的属性"></a>新增和废除的属性</h2><h3 id="新增的属性"><a href="#新增的属性" class="headerlink" title="新增的属性"></a>新增的属性</h3><h4 id="表单相关的属性"><a href="#表单相关的属性" class="headerlink" title="表单相关的属性"></a>表单相关的属性</h4><p>新增与表单相关的属性如下：</p><p>可以对 input(type&#x3D;text)、select、textarea 与 button 标签指定 autofocus 属性。可以让标签在页面打开时自动获得焦点。</p><p>可以对 input(type&#x3D;text) 与 textarea 标签指定 placeholder 属性，它会对用户的输入进行提示，提示用户可以输入的内容。</p><p>可以对 input、output、select、textarea、button 与 fieldset 指定 form 属性，申明它属于哪个表单，然后将其放置在页面上任意位置，而不是表单之内。</p><p>可以对 input(type&#x3D;text) 与 textarea 标签指定 required 属性。该属性表示在用户提交的时候进行检查，检查该标签内一定要有输入内容。</p><p>为 input 标签增加了几个新的属性：autocomplete、min、max、multiple、pattern 与 step。同时还有一个新的 list 标签与 datalist 标签配合使用。datalist 标签与 autocomplete 属性配合使用。multiple 属性允许在上传文件时一次上传多个文件。</p><p>为 input 标签与 button 标签增加了新属性 formaction、formenctype、formmethod、formnovalidate 与 formtarget，他们可以重载 form 标签的 action、enctype、method、novalidate 与 target 属性。为 fieldset 标签增加了 disabled 属性，可以把它的子标签设为 disabled(无效)状态。</p><p>为 input 标签、button标签、form标签、增加了 novalidate 属性，该属性可以取消提交时进行的有关检查，表单可以被无条件的提交。</p><h4 id="链接相关属性"><a href="#链接相关属性" class="headerlink" title="链接相关属性"></a>链接相关属性</h4><p>新增与链接相关的属性如下：</p><p>为 a 与 area 标签增加了 media 属性，该属性规定目标URL是为什么类型的媒介&#x2F;设备进行优化的，只能在 href 属性存在时使用。</p><p>为 area 标签增加了 hreflang 属性与 rel 属性，以保持与 a 标签、link标签的一致。</p><p>为 link 标签增加了新属性 sizes。该属性可以与 icon 标签结合使用(通过rel属性)，该属性指定关联图标(icon标签)的大小。</p><p>为 base 标签增加了 target 属性，主要目的是保持与 a 标签的一致性。</p><h4 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h4><p>除了上面介绍的与表达和链接相关的属性外，HTML5还增加了下面的属性：</p><p>为 ol 标签增加属性 reversed，它指定列表倒序显示。</p><p>为 meta 标签增加 charset 属性，因为这个属性已经被广泛支持了，而且为文档的字符编码的指定提供了一种比较良好的方式。</p><p>为 menu 标签增加了两个新的属性—-type 与 label。label 属性为菜单定义一个可见的标注，type 属性让菜单可以以上下文菜单、工具条与列表菜单的三种形式出现。</p><p>为 style 标签增加 scoped 属性，用来规定样式的作用范围，譬如只针对页面上某个树起作用。</p><p>为 script 标签增加 async 属性，它定义脚本是否异步执行。</p><p>为 html 标签增加属性 manifest，开发离线 Web 应用时它与 API 结合使用，定义一个 URL，在这个 URL 上描述文档的缓存信息。</p><p>为 iframe 标签增加三个属性 sandbox、seamless 与 srcdoc、用来提高页面安全性，防止不信任的 Web 页面执行某些操作。</p><h3 id="废除的属性"><a href="#废除的属性" class="headerlink" title="废除的属性"></a>废除的属性</h3><table><tbody>        <th>HTML4中使用的属性</th>        <th>使用该属性的元素</th>        <th>在HTML5中的替代方案</th>    <tr>    <td>rev</td>    <td>link、a</td>    <td>rel</td>    </tr>    <tr>    <td>charset</td>    <td>link、a</td>    <td>在被链接的资源的中使用HTTP Content-type头标签</td>    </tr>    <tr>    <td>shape、coords</td>    <td>a</td>    <td>使用area标签代替a标签</td>    </tr>    <tr>    <td>longdesc</td>    <td>img、iframe</td>    <td>使用a标签链接到校长描述</td>    </tr>    <tr>    <td>target</td>    <td>link</td>    <td>多余属性，被省略</td>    </tr>    <tr>    <td>nohref</td>    <td>area</td>    <td>多余属性，被省略</td>    </tr>    <tr>    <td>profile</td>    <td>head</td>    <td>多余属性，被省略</td>    </tr>    <tr>    <td>version</td>    <td>html</td>    <td>多余属性，被省略</td>    </tr>    <tr>    <td>name</td>    <td>img</td>    <td>id</td>    </tr>    <tr>    <td>scheme</td>    <td>meta</td>    <td>只为某个表单域使用scheme</td>    </tr>    <tr>    <td>archive、chlassid、codebose、codetype、declare、standby</td>    <td>object</td>    <td>使用data与typc属性类调用插件。需要使用这些属性来设置参数时，使用param属性</td>    </tr>    <tr>    <td>valuetype、type</td>    <td>param</td>    <td>使用name与value属性，不声明之的MIME类型</td>    </tr>    <tr>    <td>axis、abbr</td>    <td>td、th</td>    <td>使用以明确简洁的文字开头、后跟详述文字的形式。可以对更详细内容使用title属性，来使单元格的内容变得简短</td>    </tr>    <tr>    <td>scope</td>    <td>td</td>    <td>在被链接的资源的中使用HTTP Content-type头标签</td>    </tr>    <tr>    <td>align</td>    <td>caption、input、legend、div、h1、h2、h3、h4、h5、h6、p</td>    <td>使用CSS样式表替代</td>    </tr>    <tr>    <td>alink、link、text、vlink、background、bgcolor</td>    <td>body</td>    <td>使用CSS样式表替代</td>    </tr>    <tr>    <td>align、bgcolor、border、cellpadding、cellspacing、frame、rules、width</td>    <td>table</td>    <td>使用CSS样式表替代</td>    </tr>    <tr>    <td>align、char、charoff、height、nowrap、valign</td>    <td>tbody、thead、tfoot</td>    <td>使用CSS样式表替代</td>    </tr>    <tr>    <td>align、bgcolor、char、charoff、height、nowrap、valign、width</td>    <td>td、th</td>    <td>使用CSS样式表替代</td>    </tr>    <tr>    <td>align、bgcolor、char、charoff、valign</td>    <td>tr</td>    <td>使用CSS样式表替代</td>    </tr>    <tr>    <td>align、char、charoff、valign、width</td>    <td>col、colgroup</td>    <td>使用CSS样式表替代</td>    </tr>    <tr>    <td>align、border、hspace、vspace</td>    <td>object</td>    <td>使用CSS样式表替代</td>    </tr>    <tr>    <td>clear</td>    <td>br</td>    <td>使用CSS样式表替代</td>    </tr>    <tr>    <td>compace、type</td>    <td>ol、ul、li</td>    <td>使用CSS样式表替代</td>    </tr>    <tr>    <td>compace</td>    <td>dl</td>    <td>使用CSS样式表替代</td>    </tr>    <tr>    <td>compace</td>    <td>menu</td>    <td>使用CSS样式表替代</td>    </tr>    <tr>    <td>width</td>    <td>pre</td>    <td>使用CSS样式表替代</td>    </tr>    <tr>        <td>align、hspace、vspace</td>    <td>img</td>    <td>使用CSS样式表替代</td>    </tr>    <tr>    <td>align、noshade、size、width</td>    <td>hr</td>    <td>使用CSS样式表替代</td>    </tr>    <tr>    <td>align、frameborder、scrolling、marginheight、marginwidth</td>    <td>iframe</td>    <td>使用CSS样式表替代</td>    </tr>    <tr>    <td>autosubmit</td>    <td>menu</td>    <td>使用submit</td>    </tr>    </tbody></table><h1 id="HTML5的结构"><a href="#HTML5的结构" class="headerlink" title="HTML5的结构"></a>HTML5的结构</h1><p>新增的结构元素主要功能就是解决之前div漫天的情况，增强语义</p><h2 id="新增的主体结构元素"><a href="#新增的主体结构元素" class="headerlink" title="新增的主体结构元素"></a>新增的主体结构元素</h2><h3 id="article元素"><a href="#article元素" class="headerlink" title="article元素"></a>article元素</h3><p>article可以包含独立的内容项，可以包含一个论坛帖子、一篇杂志文章、用户评价等，这个元素可以将信息各部分进行任意分组，而不论信息原来的性质，每个article元素的内容都有独立的结构，可以使用header和footer等标签，它们不仅仅可以用在正文中，还可以用在各个节</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我家乌龟到了我的房间<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>            时间：<span class="hljs-tag">&lt;<span class="hljs-name">time</span>&gt;</span>18:06<span class="hljs-tag">&lt;/<span class="hljs-name">time</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>            这是正文，可爱捏。乌龟正面是这样的*^*<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">small</span>&gt;</span>我家的是中华花龟<span class="hljs-tag">&lt;/<span class="hljs-name">small</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br></code></pre></td></tr></table></figure><p>另外，article元素也可以用来表示插件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">artice</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><br>        article表示插件<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    &lt;<span class="hljs-tag">&lt;<span class="hljs-name">object</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;allowFullScreen&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">embed</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;600&quot;</span>  <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;395&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">embed</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">object</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">artice</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="section元素"><a href="#section元素" class="headerlink" title="section元素"></a>section元素</h3><p>用于对网站或app中页面上的内容进行分块，一个sectino元素通常由内容及其标题组成，但section元素也并非是一个普通的容器当一个容器元素需要被重新定义样式或者定义脚本行为时，还是推荐使用Div控制</p><p>section和article的区别：section元素更强调分段，而article强调独立性和完整性。</p><h3 id="nav元素"><a href="#nav元素" class="headerlink" title="nav元素"></a>nav元素</h3><p>nav元素再HTML5中用于包裹一个导航链接组，用于说明这是一个导航组，在同一个页面中可以存在多个nav</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ur</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;地址&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;地址&quot;</span>&gt;</span>简介<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;地址&quot;</span>&gt;</span>xxx<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ur</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="aside元素"><a href="#aside元素" class="headerlink" title="aside元素"></a>aside元素</h3><p>用来表示当前页面或文章的附属信息部分，它可以包含与当前页面或主要内容相关的引用、侧边栏、广告、导航条等，以及其他类似的有别于主要内容的部分。<strong>aside</strong>元素主要有以下两个用法：</p><ul><li><p>包含在<strong>article</strong>元素内作为主要内容的附属信息部分，其中内容可以是与当前文章有关的资料</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>主要内容标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>主要内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&gt;</span>附属信息<span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在<strong>artice</strong>元素外作为页面或站点全局的附属信息，比如侧边栏</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ur</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>侧边栏<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>侧边栏<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ur</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="新增的非主体结构"><a href="#新增的非主体结构" class="headerlink" title="新增的非主体结构"></a>新增的非主体结构</h2><h3 id="header元素"><a href="#header元素" class="headerlink" title="header元素"></a>header元素</h3><p>header元素是一种具有引导和导航作用的结构元素，通常用来放置整个页面或页面内的一个内容区块的标题，header还可以包含表格、表单或logo图片</p><h3 id="hgroup元素"><a href="#hgroup元素" class="headerlink" title="hgroup元素"></a>hgroup元素</h3><p>该元素位于正文的开头，可以在这些元素中添加h1标签，用于显示标题，通常是不需要hgroup标签的，hgroup标签是将标题及其子标题进行分组的元素，一个内容区块的标签及其子标题为一组：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">hroup</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>主标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>副标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">hroup</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>正文内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="footer元素"><a href="#footer元素" class="headerlink" title="footer元素"></a>footer元素</h3><p>footer通常包括其相关区块的脚注信息，如作者等，在HTML5之前通常使用类似下面的代码来实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tooter&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ur</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>作者<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>联系方式<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ur</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在HTML5中用更加语义化的footer：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">ur</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>作者<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>联系方式<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ur</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="address元素"><a href="#address元素" class="headerlink" title="address元素"></a>address元素</h3><p>通常用于文档的结尾没用来在文档只能呈现联系信息，包括名字】站点链接、邮箱等，浏览器显示地址的方式与周围其他文本不同，edge等浏览器用斜体的方式显示</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区块链技术与应用</title>
    <link href="/2023/06/28/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <url>/2023/06/28/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>学习课程为北京大学肖臻老师《区块链技术与应用》公开课</p><h1 id="加密货币"><a href="#加密货币" class="headerlink" title="加密货币"></a>加密货币</h1><p>比特币被称为加密货币(<strong>Crypto-currency</strong>)，但并没有加密 ，区块链上的所有内容都是公开的,包括账户地址，交易信息等。区块链中的密码学有<strong>哈希</strong>和<strong>签名</strong><br></p><ul><li><p>哈希：</p><p>  密码学中的哈希函数被称为<strong>Cryptographic hash function</strong>,他有两个重要性质</p><ul><li><p><strong>collision resistance</strong>：直译为碰撞抗性，碰撞是指哈希碰撞，也就是两个不同输入，有同一个哈希值，一般来说哈希碰撞无可避免，因为<strong>输入空间远远大于输出空间</strong>。<strong>collision resistance</strong>是指<strong>无法人为制造哈希碰撞</strong>，唯一的办法只能是brute-force(暴力破解)。这个性质使得数据一旦被串改，哈希值就会变化，因为无法找到另一个数据的哈希值与原数据相等。</p>  <p class="note note-info">没有任何一个哈希函数可以被数学证明collision resistance，只能靠实践中经验，有的哈希函数以前被认为是collision resistance，但后来找到了人为制造哈希碰撞的方法，著名的例子就是MD5</p>  </li><li><p><strong>hiding</strong>:直译为隐藏，就是说哈希运算是不可逆的，没法从哈希值倒推出原始数据，哈希值不会泄露数据的任何信息<p class ="note note-info">hiding成立的条件是，输入空间足够大，且哈希值分布均匀</p></p><p>  这两个性质结合，可以组成一个<strong>digital commitment</strong>（电子承诺）或者说是<strong>digital equivalent of sealed envelope</strong>（密封信件的电子等效物），举个例子，假设有人可以预测股市，但是提前发布预测会对结果产生影响，有结果后再发布预测则无法证明是否是提前预测的，解决方法就是使用sealed envelope密封信封把预测内容装起来，交给一个机构保管。两个性质的结合就能在电子世界产生同样的结果，将预测通过哈希发布出去，由于<strong>collision resistance</strong>我无法修改预测，由于<strong>hiding</strong>大家不知道我预测了什么。但是两种性质的前提是输入空间够大，输出均匀，对于股票，股票种类是有限的，所以可以通过暴力求解。对于这种，我们可以取一个<strong>nonce</strong>（随机数），一起进行哈希。</p></li><li><p><strong>puzzle friendly</strong>:除了密码学的两个性质以外，比特币用到的哈希函数还要求第三个性质，<strong>该性质要求哈希值计算事先不可预测，仅仅根据输入很难预测出输出</strong>，例如，我要使一个哈希值存在某个范围内，只能通过不停运算试出来。</p><p>  比特币中使用的哈希函数是<strong>SHA256</strong>：secure hash algorithm,安全哈希算法，满足以上三个性质</p></li></ul></li><li><p>签名：</p><p>  讲签名先讲下比特币中的账户管理，开户不需要任何人的批准，只需要创立一个public key公钥和private key私钥的对，公私钥的概念来源于非对称加密，将公钥发布出去，大家使用我的公钥加密，发送给我后，我用自己的私钥解密。比特币系统中，公钥就相当于账号，私钥相当于密码，但是比特币系统是不加密的，信息公开，实际上公私钥是用来签名的。当我们发布一个交易的时候，用自己的私钥进行签名，其他人收到这个交易之后，再用我的公钥去验证这个签名的正确性。</p>  <p class ="note note-info">账户都是本地独立的生成公私钥对，不需要任何人的批准，那么有没有可能生成两个一样的密钥呢？理论可行，实际不可行，如果是256位的哈希值，产生相同公私钥的可能性是微乎其微的，前提是产生公私钥的时候有个好的随机源，而且之后每一次签名也要有好的随机源，非则会有私钥泄露的风险</p></li></ul><h1 id="比特币中的数据结构"><a href="#比特币中的数据结构" class="headerlink" title="比特币中的数据结构"></a>比特币中的数据结构</h1><ul><li><p>哈希指针：</p><p>  区块链和普通链表的区别，有个不同就是用哈希指针代替了普通指针，除了创世区块，每个区块里都有个哈希指针指向前一个区块，做哈希运算时，会把前一个区块的全部内容包括里面的哈希指针一起做哈希运算，得到哈希指针。指向最后一个块的哈希指针存在了系统里，这样，只要任意一个块被篡改，后面全部哈希指针全都对不上，就算改了一路，也无法改变存在系统里的指向最后一个块的哈希值。</p></li><li><p>Merkle tree:梅克尔树，还有一种叫<strong>binary tree</strong>二叉树，两者的不同就是，Merkle tree用哈希指针代替了普通指针，用于快速查找更改。每个数据块哈希一次，每两个哈希值再合起来进行哈希，一步步往上，形成树形结构，最后得出根哈希值。Merkle tree的用途可以提供<strong>Merkle proof</strong>，梅克尔证明。</p><p>  比特币中的节点分为<strong>全节点</strong>（保存整个区块，block header block body的内容）和<strong>轻节点</strong>（只保存block header）,如果要向一个轻节点证明，某个交易已经写入到区块链的：<strong>找到交易所在位置，从该位置一直往上直到根节点的路径，这条路劲就是Merkle proof</strong>，如果最下面的节点是奇数个，该单生节点重复一次和自己组成一对进行哈希。</p><p>  <img src="https://img1.imgtp.com/2023/06/30/ibl1PQGc.png" alt="Merkle tree"></p></li></ul><h1 id="BTC协议"><a href="#BTC协议" class="headerlink" title="BTC协议"></a>BTC协议</h1><ul><li><p><strong>double spending attack</strong>:双花攻击，花两次攻击。数字货币所面临的一个主要挑战就是如何防范双花攻击，数字货币是一个文件，就算有发行商的签名，别人无法伪造，也可以通过复制，把钱花两次。所以要核实是否被花过，是否真的在对方手里。</p><p>  去中心化的数字货币需要解决<strong>谁有铸币权</strong>和<strong>如何验证交易有效性</strong>，在比特币中，铸币权由挖矿决定。</p><p>  <img src="https://img1.imgtp.com/2023/07/02/sFSb9O4s.png" alt="交易验证"></p><p>  如图所示，A铸币得了10元，给了BC各5元， 在A支付货币的交易中，需要有A的私钥签名，A的公钥，其他人用A的公钥验证，还要有A支付货币的来源，和收款方BC的公钥取哈希值。而作为收款人的BC则需要知道A的公钥，用于验证签名，以及是否是A的账户。若交易不合法则不加入区块中。</p>  <p class ="note note-info">如何知道BC的公钥地址呢？公钥是公开的，但比特币并没有提供查询功能，所以需要BC自己告诉A，可以发布公钥到个人网站，张贴二维码等方式。若是有人假装是A，用自己私钥签名和附上自己公钥呢？所以货币来源A(10)也带有A的公钥，除了要验证A的签名还要和货币来源公钥做对比</p></li></ul><h2 id="Block-head-和Block-body"><a href="#Block-head-和Block-body" class="headerlink" title="Block head 和Block body"></a>Block head 和Block body</h2><table><thead><tr><th>Block header</th><th>Block body</th></tr></thead><tbody><tr><td>version-版本</td><td>transaction list-交易列表</td></tr><tr><td>hash of previous-指向前一个区块块头的哈希指针</td><td>merkle tree-梅克尔树</td></tr><tr><td>Merkle root hash-梅克尔树根哈希</td><td></td></tr><tr><td>target-挖矿难度，目标阈值，加密后为nBits</td><td></td></tr><tr><td>nonce-挖矿用的随机数</td><td></td></tr></tbody></table><p><img src="https://img1.imgtp.com/2023/07/05/hegyL02m.png" alt="区块链"></p><h2 id="全节点和轻节点"><a href="#全节点和轻节点" class="headerlink" title="全节点和轻节点"></a>全节点和轻节点</h2><p><strong>full node-全节点</strong>是保存所有信息的，所以全节点又被称为<strong>fully validating node</strong>直译为完全验证节点；<strong>light node-轻节点</strong>只保存block header的内容，一般来说轻节点无法独立验证交易的合法性，轻节点没有参与区块链的维护，大部分节点是轻节点。</p><p>每个账户都可以发布交易，这个交易会广播给所有节点，那么谁来决定哪些交易合法非法，能否被写到下一个区块呢？<strong>账本的内容需要取得分布式的共识</strong>，比特币中的共识协议要解决的问题是小部分节点可能是有恶意的，一种想法是直接投票：一个节点把交易打包后，广播给所有节点，让所有人投票是否合法能否加入，这种方法是不行的，如果一半的节点“行政不作为”不投票，则永远无法通过，而且投票比较耗时还有网络延迟的问题，还有个更大的问题，就是会：投票要决定谁是membership，谁才有投票权，如果是制定一个标准比如联盟链，大多数是公司，那么这种情况投票是可行的，但是在比特币系统中创建账户是很容易的，有恶意的节点可以产生大量账户，当超过一半时，就能操控结果，这就是<strong>sybil attack女巫攻击</strong>指一个人像女巫一样拥有多个身份伪装，所以<strong>简单的直接投票是不行的</strong></p><blockquote><p>Sybil来自于一部电影《Sybil》女主拥有16个人格，扮演着不同角色</p></blockquote><p>比特币系统中确实是使用投票，但不是根据账户数量，而是根据算例来投票：每个节点都可以在本地组装一个区块，把认为合法的交易放入，然后开始尝试各种<strong>nonce</strong>值，在区块头里有个域<strong>H(block header)&lt;&#x3D;target</strong>看哪个节点先找到符合要求的nonce,他就有了<strong>记账权</strong>，发布区块后，其他节点收到之后，验证区块的合法性和nonce的正确性，假设交易不合法，这个区块就不会被节点接收。所以这是与算力挂钩的，获得记账权的几率就是自身算力在全网算力中的百分比，无论开多少账户，同一台机器的算力是不变的，全网的算力也是不变的。有效的防止了女巫攻击</p><h1 id="BTC实现"><a href="#BTC实现" class="headerlink" title="BTC实现"></a>BTC实现</h1><p>比特币是<strong>基于分布式账本transaction-based ledger</strong>的，没有显示余额的信息。想知道一个账户有多少余额就得通过交易记录推算。比特币中的全节点要维护一个叫<strong>UTXO</strong>的数据结构（<strong>Unspent Transaction Output没有被花掉的交易输出</strong>），一个交易可以有多个输出和输入，输入就是发款人，输入就是收款人，比如A-&gt;B(5BTC)这笔交易中，A给了B钱，B就是输入，A就是输入，也可以有多个输入输出如：A-&gt;B(5BTC),A-&gt;C(3BTC)这两个可以放在同一笔交易里，输入都是A，输入是BC，若B把钱花了，C没有，<strong>UTXO</strong>这个集合里的元素会记录这个交易的哈希值以及这个输出是在交易里的第几个输出。这两个信息就可以做到定位。每个交易都会消耗一些输出同时也会产生新的输出。且<strong>总输入&#x3D;总输出</strong>，也有不等于的情况，需要给记账节点交易费，防止节点只打包自己的区块，而不帮其他人记账，目前比特币中的交易费都比较小，但随着挖矿奖励的减少，交易费的占比会逐渐增大。</p><p><img src="https://img1.imgtp.com/2023/07/05/DkkyD8W8.png" alt="UTXO"></p><p>还有一种余额查询方式是<strong>基于账户account-based ledger</strong>的模式，如<strong>以太坊</strong>，这种模式显式地记录每个账户上有多少个币</p><p>下面是比特币块头数据和数据大小、类型</p><p><img src="https://img1.imgtp.com/2023/07/06/QC00iFe3.png" alt="块头内容"></p><p>挖矿就是不断尝试各种<strong>nonce</strong>，目前挖矿难度极高，<strong>nonce</strong>是32位无符号整型，而<strong>target</strong>是256位，所以可能这2^32个数里找不到一个满足条件的，而块头唯三能修改的就<strong>merkle root hash</strong>、<strong>time</strong>和<strong>nonce</strong>，其中time时间戳只能小范围的改动，影响不大。在每个区块里的第一个交易是<strong>铸币交易</strong>，是矿工给自己的输入为<strong>coinbase</strong>输入为自己地址的交易，<strong>coinbase</strong>可以随便写内容，所以可以通过修<strong>coinbase</strong>来修改<strong>merkle root hash</strong></p><p><img src="https://img1.imgtp.com/2023/07/06/egLyhGGG.png" alt="修改merkle root"></p><p><strong>如何防止回滚交易</strong>：在比特币中，如果有分叉的链，则最长合法链为有效链，若在商品交易中，写入交易后，又从前一个区块写入另一笔交易，将原本支付给商家的比特币转给自己，接着沿着新链往下挖，则使交易回滚，白嫖了商品，所以在商家在交易被写入后，等待6个区块（10分钟一个区块，大约一小时）才开始给买家发货。这样回滚难度就会大幅度增加。</p><h1 id="比特币网络"><a href="#比特币网络" class="headerlink" title="比特币网络"></a>比特币网络</h1><p>应用层：BitCoin Blocck chain</p><p>网络层：P2P Overlay Network</p><p>比特币网络的设计原则是<strong>简单、鲁棒</strong>而不是高效（鲁棒性是系统的健壮性，是系统异常和危险情况下生存的关键），每个节点维护一个邻居节点的集合，消息传播在网络中采取叫<strong>flooding</strong>（洪水，淹没，泛滥）的方式：节点第一次听到消息的时候，传播给其他所有的邻居节点，同时记录下，下次再收到这个消息的时候不再转发。</p><h2 id="邻居节点的选取"><a href="#邻居节点的选取" class="headerlink" title="邻居节点的选取"></a>邻居节点的选取</h2><p>邻居节点的选取是<strong>随机的</strong>，没有考虑底层的拓扑结构，这样设计的好处是<strong>增强鲁棒性</strong>，但<strong>牺牲了效率</strong>，向身边人转账和向美国转账速度其实是差不多的。 </p><h3 id="交易池"><a href="#交易池" class="headerlink" title="交易池"></a>交易池</h3><p>比特币中的每个节点要维护一个<strong>等待上链</strong>的交易的集合：第一次听到某个合法交易的时候，把交易加入集合，并转发给邻居节点，若两个冲突交易（如双花）同时发布，每个节点由于位置不同，先收到的交易也不同，会取先接收到的交易放入集合，把后收到的冲突交易认为是非法的，不接收它。当节点听到新区块发布且包含池中的交易时，节点就会把集合内的对应交易删掉，如果新区块内的交易和池中的交易冲突，那么节点也会把对应交易从集合里删除，防止double spending</p><h1 id="BTC挖矿难度"><a href="#BTC挖矿难度" class="headerlink" title="BTC挖矿难度"></a>BTC挖矿难度</h1><p>挖矿就是不断改变尝试<strong>block header</strong>里的<strong>nonce</strong>，使得<strong>H(Block Header)&lt;&#x3D;target</strong>即：块头的哈希值小于等于目标阈值，target越小，<strong>difficult挖矿难度</strong>越大</p><ul><li><p><strong>为什么要调整挖矿难度：</strong><br>  为了控制出块的时间，随着设备的改进、挖矿人员的增加，算力在不断增加，所以要增大难度，否则出块速度会不断增加。而出块时间过短可能会引起区块链经常性的分叉，而这种分叉会让恶意节点更容易发动分叉攻击，存在多条同长分叉时，算力会被分散，这时恶意节点专注于自己的分叉，即使没有51%的算力也可以很容易发起攻击。</p></li><li><p><strong>如何调整挖矿难度：</strong></p><p>  比特币中设定，每2016个区块（大约2个星期）就调整一次挖矿难度，<strong>target&#x3D;target*actual time&#x2F;expected time</strong>,即：<em><em>本次的难度&#x3D;上次难度</em> （实际出矿时间 &#x2F; 预期出矿时间）</em><em>，实际代码当中，调整都有四倍的限度，比如实际时间超过8个星期（正常2星期，2</em>4&#x3D;8），也只会算8星期，主要避免系统出现意外情况而导致难度出现大幅度变动；若实际时间不足半个星期（正常2星期，2的四分之一为0.5）也只会算为半个星期，所以实际时间最大值为8星期，最小值为0.5星期。</p></li><li><p><strong>如何保证所有人都调整：</strong></p><p>  难度调整是写在代码中的，虽然因为区块链的开源的，恶意节点也许可以不调整或修改挖矿难度，但是修改了挖矿难度就会<strong>target改变目标阈值</strong>，而算出满足阈值的<strong>nonce</strong>之后，要给链上的所有人验证，这时候验证是不一定能通过的，因为别人的阈值不一样。而且就算满足target，因为修改了难度，城市的矿工也不会认同这个非法区块，block header里有个<strong>nBits</strong>，它 是target编码后的版本，只有四个字节，target有32个字节，所以本身并不在块头中，</p></li></ul><h1 id="BTC挖矿"><a href="#BTC挖矿" class="headerlink" title="BTC挖矿"></a>BTC挖矿</h1><h2 id="全节点和轻节点详细"><a href="#全节点和轻节点详细" class="headerlink" title="全节点和轻节点详细"></a>全节点和轻节点详细</h2><ul><li>全节点：<ul><li>一直在线</li><li>在本地硬盘上维护完整的区块链信息</li><li>在内存里维护UTXO集合，以便快速检验交易的正确性</li><li>监听比特币网络上的交易信息，验证每个交易的合法性</li><li>决定哪些交易会被打包到区块里</li><li>监听别的矿工挖出来的区块，验证其合法性</li><li>挖矿：<ul><li>决定沿着哪条链挖下去？缺省情况下沿着最长合法链挖矿</li><li>当出现等长的分叉时，选择哪个分叉？缺省情况下选择最先听到的分叉</li></ul></li></ul></li><li>轻节点：<ul><li>不是一直在线</li><li>不用保存整个区块链，只要保存每个区块的块头</li><li>不用保存全部交易，只保存与自己相关的交易</li><li>无法检验大多数交易的合法性，只能检验与自己相关的交易的合法性</li><li>无法检测网上发布的区块的合法性，但能验证难度，因为只用到块头</li><li>可以验证挖矿的难度</li><li>只能检测哪个是最长链，不知道哪个是最长合法链，轻节点假设矿工是理智的，不会沿着非法区块挖下去</li></ul></li></ul><p>比特币网络中大多数节点是轻节点，如果只是转账而不挖矿的话，只使用轻节点就可以了<br><br>随着时代的发展，挖矿设备也在不断变化，第一代使用的是CPU挖矿，第二代使用GPU挖矿，GPU的并行计算能力比CPU强，CPU主要用于控制，所以GPU挖矿增加了算了又减少了对性能的浪费，但仍然有部分功能使用不到，比如关系到浮点数计算的元件。到了第三代，使用的是ASIC芯片application-specific integrated circuit专用集成电路挖矿，这是专门为挖矿设计的芯片，它上面没有多余的电路，整个芯片就是为了比特币计算哈希值而设计的，是性价比最高的。而且为一种加密货币设计的Asics芯片就只能挖这种货币，不能挖其他的加密货币，除非这两种币使用同一个mining puzzle。ASIC芯片的研发周期很长，如比特币的芯片可能需要一年，且比特币的竞争越来越激烈，定制的ASIC芯片可能用不了几个月就过时了，又得买更新的强大的芯片。所以购买ASIC矿机的时机非常重要。<br></p><p>整个趋势由通用设备转向专用设备，实际上这种趋势与比特币最初的去中心化是违背的，所以现在有的货币采用了<strong>ASIC resistance 抗ASIC化</strong>，目的是让通用计算机也能够参与挖矿的过程。<br></p><p>挖矿的另一个趋势，就是大型矿池的出现，单个矿工就算用了ASIC芯片，收入也是不稳定的，对于所有人每10分钟挖出一个区块，但是对于个人，挖出区块可能得一年。矿池就是将矿工集合起来，一个节点驱动着许多矿机：</p><p>一个矿池一般有一个<strong>pool manager矿主</strong>下面连着许多<strong>miner矿工</strong>，矿工只负责计算哈希值，其他的全节点的功能交给矿主如监听交易，打包区块等。收益分配用工作量证明分配：矿工计算时会得到部分<strong>share</strong>和<strong>most valid block 几乎有效的区块</strong>哈希值与实际哈希值相似，把这个<strong>share</strong>提交给矿主，矿主记录起来作为工作量证明，除此外没有其他用途，<del>没有功劳也有苦劳啊</del>，一个矿工尝试的<strong>nonce</strong>越多，它得到的<strong>share</strong>就越多，那么矿工挖到矿之后能不能提交呢？答案是不能，因为哈希值除了nonce还有其他值共同决定，而打包区块是矿主，收款人也是矿主的地址，如果改了地址，哈希值也会改变。</p><p><strong>大型矿池的弊端</strong>：大型矿池使算力更加集中，<strong>GHASH</strong>矿池有段时间甚至占据了全网近50%的算力，好在矿主主动配合减低比例，而现在虽然没出现这种情况，但仍然有51%攻击的风险，一个组织可以有多个矿池，而且通过降低管理费等亏本方法吸引群众入池，使自己组织占据大量算力，而且矿工只负责计算哈希值，由矿主分配工作，他们可能并不知道自己在发动攻击。</p><h1 id="BTC-比特币脚本"><a href="#BTC-比特币脚本" class="headerlink" title="BTC-比特币脚本"></a>BTC-比特币脚本</h1><p><img src="https://img1.imgtp.com/2023/07/13/0Dv15d0u.jpg" alt="09-BTC-1.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>区块链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>devcpp播放音乐</title>
    <link href="/2023/06/25/devcpp%E6%92%AD%E6%94%BE%E9%9F%B3%E4%B9%90/"/>
    <url>/2023/06/25/devcpp%E6%92%AD%E6%94%BE%E9%9F%B3%E4%B9%90/</url>
    
    <content type="html"><![CDATA[<h1 id="使用dev-cpp播放音乐"><a href="#使用dev-cpp播放音乐" class="headerlink" title="使用dev cpp播放音乐"></a>使用dev cpp播放音乐</h1><p>对于其他的编译器也通用，但<strong>devcpp需要设置点内容，否则会报错</strong></p><h2 id="头文件和库"><a href="#头文件和库" class="headerlink" title="头文件和库"></a>头文件和库</h2><p>首先播放音乐需要以下库和头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mmsystem.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment (lib,<span class="hljs-string">&quot;winmm.lib&quot;</span>)<span class="hljs-comment">//用来加载静态库</span></span><br></code></pre></td></tr></table></figure><h2 id="使用函数播放"><a href="#使用函数播放" class="headerlink" title="使用函数播放"></a>使用函数播放</h2><p>使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">mciSendString()<br></code></pre></td></tr></table></figure><p>进行文件的打开，播放，停止等操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C">mciSendString(<span class="hljs-string">&quot;open 2.mp3&quot;</span><span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br><span class="hljs-comment">//打开2.mp3文件</span><br>mciSendString(<span class="hljs-string">&quot;open 2.mp3 alias a&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br><span class="hljs-comment">//打开2.mp3文件并取别名为a</span><br>mciSendString(<span class="hljs-string">&quot;play a&quot;</span>)<br><span class="hljs-comment">//播放a</span><br>mciSendString(<span class="hljs-string">&quot;repeat a&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br><span class="hljs-comment">//循环播放a</span><br>mciSendString(<span class="hljs-string">&quot;close a&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br><span class="hljs-comment">//关闭播放</span><br></code></pre></td></tr></table></figure><hr><h2 id="Devcpp配置"><a href="#Devcpp配置" class="headerlink" title="Devcpp配置"></a>Devcpp配置</h2><p>在工具-编译选项-编译器的第二个框内输入</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">-<span class="hljs-keyword">static</span>-libgcc -lgdi32<br></code></pre></td></tr></table></figure><p>然后在项目-项目属性中，输入</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-lwinmm</span><br></code></pre></td></tr></table></figure><p>然后就可以运行了</p>]]></content>
    
    
    
    <tags>
      
      <tag>C语言</tag>
      
      <tag>小玩意</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>easyX制作菜单页面</title>
    <link href="/2023/06/11/%E8%8F%9C%E5%8D%95%E9%A1%B5%E9%9D%A2/"/>
    <url>/2023/06/11/%E8%8F%9C%E5%8D%95%E9%A1%B5%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;graphics.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span><span class="hljs-comment">//开始按钮 </span><br>&#123;<br>outtextxy(<span class="hljs-number">500</span>,<span class="hljs-number">300</span>,<span class="hljs-string">&quot;start&quot;</span>);<br>rectangle(<span class="hljs-number">370</span>,<span class="hljs-number">290</span>,<span class="hljs-number">650</span>,<span class="hljs-number">320</span>);<br>&#125; <br><span class="hljs-type">void</span> <span class="hljs-title function_">startif</span><span class="hljs-params">()</span><span class="hljs-comment">//判断鼠标是否在按钮内，是否点击 </span><br>&#123;<br>ExMessage msg ;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">do</span><br>&#123;peekmessage(&amp;msg);<br><span class="hljs-keyword">if</span>(msg.x &gt;= <span class="hljs-number">370</span> &amp;&amp; msg.x &lt;= <span class="hljs-number">650</span> &amp;&amp; msg.y &gt;= <span class="hljs-number">290</span> &amp;&amp; msg.y &lt;= <span class="hljs-number">320</span>)<span class="hljs-comment">//在按钮内则按钮变红 </span><br>&#123;cleardevice();<br>BeginBatchDraw();<br>settextcolor(RED);<br>setlinecolor(RED);<br>start();<br>FlushBatchDraw();<br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//按钮外变白 </span><br>&#123;<br>cleardevice();<br>settextcolor(WHITE);<br>setlinecolor(WHITE);<br>start();<br>FlushBatchDraw();<br>&#125;<br><br>&#125;<span class="hljs-keyword">while</span>(!msg.lbutton || !(msg.x &gt;= <span class="hljs-number">370</span> &amp;&amp; msg.x &lt;= <span class="hljs-number">650</span> &amp;&amp; msg.y &gt;= <span class="hljs-number">290</span> &amp;&amp; msg.y &lt;= <span class="hljs-number">320</span>));<span class="hljs-comment">//左键退出 </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;开始&quot;</span>); <br><span class="hljs-keyword">break</span>;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://img1.imgtp.com/2023/06/11/Tx1OeEcJ.png" alt="正常效果"></p><p><img src="https://img1.imgtp.com/2023/06/11/DtyHCP7R.png" alt="鼠标停留效果"></p><p>不难写，但要注意<strong>BeginBatchDraw()</strong> 和 <strong>FludBatchDraw()</strong> 的位置，不加会闪。</p>]]></content>
    
    
    
    <tags>
      
      <tag>小玩意</tag>
      
      <tag>easyX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言数据结构与算法</title>
    <link href="/2023/06/11/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <url>/2023/06/11/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p class="note note-info">    使用书籍《大话数据结构》-程杰</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="基础概念和术语"><a href="#基础概念和术语" class="headerlink" title="基础概念和术语"></a>基础概念和术语</h2><p><img src="https://img1.imgtp.com/2023/07/21/S67KbB12.png" alt="&gt;"></p><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p><strong>数据是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合</strong>，数据不仅仅包含整型，实型等数据类型，还包括字符及声音、图像、视频等非数值类型。对于数值类型可以进行数值运算，对于字符数据类型，需要进行非数值的处理，而声音、图像等则可以通过编码手段变成字符数据类型来处理。</p><h3 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h3><p><strong>数据元素是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录</strong>。<br>比如在人类中，人就是数据元素，在畜类中，猪马牛羊就是数据元素。</p><h3 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h3><p><strong>一个数据元素可以由多个数据项组成，数据项是数据不可分割的最小单位</strong>。<br>比如人这个数据元素，可以有眼鼻手脚等数据项，也可以有名字、性别等数据项。而数据项是数据不可分割的最小单位，但真正讨论问题时，数据元素才是数据结构中建立数据模型的着眼点，就好像讨论电影，讨论的是主角这个数据元素，而不是它名字、性别等数据项。</p><h3 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h3><p><strong>数据对象是性质相同的数据元素的集合，是数据的子集。</strong>，性质相同指的是数据元素具有相同数量和类型的数据项。数据对象是数据的子集，所以有相同的性质，在日常使用中，在不产生混淆的情况下，通常把数据对象简称为数据。</p><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p><strong>数据结构是相互之间存在一种或多种特定关系的数据元素的集合</strong>，简单理解，结构就是关系。</p><h2 id="逻辑结构和物理结构"><a href="#逻辑结构和物理结构" class="headerlink" title="逻辑结构和物理结构"></a>逻辑结构和物理结构</h2><p><strong>逻辑结构是指数据对象中数据元素间的相互关系</strong>。逻辑结构分以下四种：</p><ol><li><p><strong>集合结构</strong></p><p> 集合结构中的元素除了同属于一个集合外，它们之间没有其他关系</p><p> <img src="https://img1.imgtp.com/2023/07/21/Z1ZV4kqi.png" alt="集合结构.png"></p></li><li><p><strong>线性结构</strong></p><p> 线性结构中，数据元素是一对一的关系：</p><p> <img src="https://img1.imgtp.com/2023/07/21/ZLfahrem.png" alt="线性结构.png"></p></li><li><p><strong>树形结构</strong></p><p> 树形结构中的数据元素<strong>存在</strong>一对多的层次关系：</p><p> <img src="https://img1.imgtp.com/2023/07/21/DMXOfSHd.png" alt="树形结构.png"></p></li><li><p><strong>图形结构</strong></p><p> 图形结构的数据元素是多对多的关系：</p><p> <img src="https://img1.imgtp.com/2023/07/21/deRZbtsK.png" alt="图形结构.png"></p></li></ol><p><strong>物理结构是指数据的逻辑结构在计算机中的存储形式</strong>。物理结构有两种：</p><ol><li><p><strong>顺序存储结构</strong>：</p><p> 是把数据元素存放在地址连续的存储单元内，其数据间的逻辑关系和物理关系是一致的。比如我们创建数组的时候，计算机会在内存中开辟一段连续的空间，第一个数据放第一个位置，第二个数据放第二个。像排队一样：</p><p> <img src="https://img1.imgtp.com/2023/07/21/As14SzBW.png" alt="顺序存储结构.png"></p></li><li><p><strong>链式存储结构</strong>：</p><p> <strong>是把结构元素存放在任意的存储单元内，这组存储单元可以是连续的，也可以是不连续的。</strong>这种存储关系并不能反映逻辑关系，因此需要用一个指针数据元素的地址，这样通过地址就能找到相关联数据元素的位置。就像银行排队，取号后想坐那都行：</p><p> <img src="https://img1.imgtp.com/2023/07/21/P04eSC9y.png" alt="链式存储结构.png"></p></li></ol><p>逻辑结构是面向问题的，而物理结构是面向计算机的，其基本目的就是将数据及其逻辑关系存储到计算机内存中。</p><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><strong>数据类型是指一组性质相同的值的集合及定义在此集合上的一些操作的总称</strong>。<br>数据类型是按照值得不同进行划分的。在高级语言中，每个变量、常量、表达式都有各自的取值类型，<strong>类型就用来说明变量或表达式的取值范围和所能进行的操作</strong><br>为什么要设计出数据类型呢？为了节约内存，比如计算1+1&#x3D;2，显然不需要开辟出适合实型甚至字符运算的内存空间，于是就对数据分类，分出了多种数据类型：</p><ul><li>原子类型：是不可以再分解的基本类型，包括整型、实型、字符型等</li><li>结构类型：由若干个类型组合而成，是可以再分解的，例如整型数组是由若干整型数据组成的。</li></ul><p>比如C语言中的int a，给a赋值时就不能超出int类型的范围，运算时只能是int类型所允许的运算。<br>因为不同的计算机由不同的硬件系统，这就要求程序语言最终通过编译器或解释器转换成底层语言，如汇编甚至是机器语言的数据类型来实现的。可事实上高级语言的开发者根本不关心这个，它不需要知道计算机内部是如何表示的，CPU进行几次开关操作，这些如何实现对高级语言开发者根本不重要。于是我们就会考虑，无论什么计算机、什么计算机语言，大都会面临如整数运算、实型运算、字符运算等操作，我们可以考虑把它们都<strong>抽象</strong>出来<br><strong>抽象是指抽取出事物具有的普遍性的本质</strong>。它是抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节，只保留了实现目标所必需的信息。</p><h3 id="抽象数据类型-1"><a href="#抽象数据类型-1" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><p>我们对已有的数据类型进行抽象，就由了抽象数据类型。<strong>抽象数据类型(Abstarct Date Type,ADT)</strong>:是指一个数学模型及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。<br>比如各个计算机甚至手机，都有“整型”类型，那么整型就是一个抽象数据类型，尽管它在不同设备上实现方法可能不同，但由于其定义的数学特性相同，在计算机编程者开来，它们都是相同的。因此，<strong>“抽象”的意义在于数据类型的数学抽象特征。</strong><br>而且，抽象数据类型不仅仅指哪些已经定义并实现的数据类型，还可以是计算机编程者在设计软件程序时自己定义的数据类型，比如我们编写绘图的软件系统，会用到坐标，总会有成对的x，y出现，我们就定义一个叫point的抽象数据类型，它有x,y两个整型变量，这样我们就很方便地操作一个point数据变量就能知道这一点的坐标了。<br>事实上，抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性。抽象数据类型把实际生活中的问题分解为多个规模校且容易处理的问题，然后建立一个计算机能处理的数据模型，并把每个功能模块的实现细节作为一个独立的单元，从而使具体实现过程隐藏起来。<br>描述抽象数据类型的标准格式：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs erlang">ADT 抽象数据类型名<br>Data<br>数据元素之间逻辑关系的定义<br>Operation<br>操作<span class="hljs-number">1</span><br>初始条件<br>操作结果<br>操作<span class="hljs-number">2</span><br>...<br>操作N<br>...<br><span class="hljs-keyword">end</span>ADT<br></code></pre></td></tr></table></figure><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="算法的定义"><a href="#算法的定义" class="headerlink" title="算法的定义"></a>算法的定义</h2><p><strong>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</strong></p><h2 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h2><ul><li><p><strong>输入和输出</strong>：</p><p>  <strong>算法具有零个或多个输入</strong>，且算法<strong>至少有一个或多个输出</strong>，算法一定需要输出，输出的形式可以是打印也可以是返回值。</p></li><li><p><strong>有穷性</strong></p><p>  <strong>算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。</strong>而且这个有限并不纯是数学意义的，而是在实际应用中合理的、可以接收的“有边界”。总不能一个算法算上几十年才才结束。</p></li><li><p><strong>确定性</strong></p><p>  <strong>算法的每一步骤都有确定的含义，不会出现二义性。</strong>算法在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果。算法的每个步骤被精确定义而无歧异。</p></li><li><p><strong>可执行性</strong></p><p>  <strong>算法的每一步都必须是可行的，也就是说，每一步都能通过执行有限次数完成。</strong>意味着算法可以转化为程序上机运行，并得到正确结果。尽管在目前也存在那种没有实现的极为复杂的算法。</p></li></ul><h2 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h2><ul><li><p><strong>正确性</strong>：</p><p>  至少应该具有输入、输出和加工处理无歧义性、能够正确反映问题的需求、能够得到问题的正确答案。大体分为以下四个层次：</p><ol><li>算法程序没有语法错误</li><li>对于合法输入数据能给出满足要求的输出结果</li><li>对于非法输入数据能给出满足规格说明的结果</li><li>对于精心选择甚至刁难的测试数据都有满足要求的输出结果</li></ol></li><li><p><strong>可读性</strong>：</p><p>  算法设计的另一目的是便于阅读、理解和交流。</p></li><li><p><strong>健壮性</strong>：</p><p>  当输入数据不合法时，算法也能做出相应的处理，而不是产生异常或奇怪的结果。</p></li><li><p><strong>时间效率高和存储量低</strong>：</p><p>  时间效率指的是算法的执行时间，存储量需求指的是算法在执行过程中需要的最大存储空间，主要指算法程序运行时所占用的内存空间或外部硬盘存储空间。</p></li></ul><h2 id="算法效率的量度方法"><a href="#算法效率的量度方法" class="headerlink" title="算法效率的量度方法"></a>算法效率的量度方法</h2><ul><li><p>时候统计方法：</p><p>  主要通过设计好的程序和数据，利用计算机计时器对不同算法编制的程序的运行时间比较，但这种方法有很大缺陷：</p><ol><li>必须先编制好程序，如果编制出来就是种坏的算法，那不是很浪费时间吗？</li><li>时间的比较依赖计算机硬件和软件等因素，有时会掩盖算法本身的优缺点，而所用的系统、编译器、运行框架不同都会影响时间，就算同一台机器，CPU使用率和内存占用情况不同，也会造成细微的差距</li><li>算法的测试数据设计困难，效率高的算法在小的测试数据面前往往得不到体现，如果有100万个测试数据，算法间的差距就很大了。</li></ol></li></ul><p>所以对于事后统计的方法，我们不予考虑</p><ul><li><p>事前估计分析方法：</p><p>  一个高级语言编写的程序在计算机上运行时所消耗的时间取决于以下：</p><ol><li>算法采用的策略方法</li><li>编译产生的代码质量</li><li>问题的输入规模</li><li>机器执行指令的效率</li></ol></li></ul><p>第1条是算法好坏的根本，第2条要由软件来支持，第4条看硬件性能。也就是说，<strong>一个程序的运行时间，依赖于算法的好坏和问题的输入规模</strong>。输入规模就是输入量的多少。举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//从1加到100</span><br><span class="hljs-comment">//第一种算法：</span><br><span class="hljs-type">int</span> i,sum=<span class="hljs-number">0</span>,n=<span class="hljs-number">100</span>;<span class="hljs-comment">//执行1次</span><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i&lt;=n; i++)<span class="hljs-comment">//执行n+1次</span><br>&#123;<br> sum=sum+<span class="hljs-number">1</span>;  <span class="hljs-comment">//执行1次</span><br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,sum);<span class="hljs-comment">//执行1次</span><br><span class="hljs-comment">//第二种算法：</span><br><span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>,n=<span class="hljs-number">100</span>;<span class="hljs-comment">//执行1次</span><br>sum=(<span class="hljs-number">1</span>+n)*<span class="hljs-number">2</span>/n;<span class="hljs-comment">//执行1次</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,sum);<span class="hljs-comment">//执行1次</span><br></code></pre></td></tr></table></figure><p>可以看出，第一种算法执行了1+(n+1)+n+1&#x3D;2n+3次；而第二种算法是3次，忽略开头结尾，把循环看成一个整体，两个算法就是n次与1次的差距。<br>测定运行时间最可靠的方法就是计算对运算时间有消耗的基本操作的执行次数。对于第一种算法，同样问题的输入规模是n，需要一段代码运行n次。那么操作数量是f(n)&#x3D;n，而第二种，则是f(n)&#x3D;1。将两个函数绘制图像可以发现，随着n值得增大，它们在时间效率上得差异也就越来越大。</p><h2 id="函数得渐近增长"><a href="#函数得渐近增长" class="headerlink" title="函数得渐近增长"></a>函数得渐近增长</h2><p><strong>函数得渐近增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n&gt;N,都有f(n)&gt;g(n)，那么我们说f(n)的增长渐近快于g(n)<strong>，对于n+8和n+1，随着n的增大，我们可以</strong>忽略后面的加法常数</strong>，它们并不影响最终的算法变化。<br>而对于2n、3n^2这类，即使把乘数去掉也不会影响，也就是说<strong>与最高次项相乘的常数并不重要。</strong><br>而对于n，n^2，n^3会发现，<strong>最高次项的指数大的，函数随着n的增长，结果也会变得增长特别快</strong><br>最后，对于3n+1和3n^2和3n^2+n，当n的值越来越大，3n+1的值和其他两者差距也会越来越大，最终甚至可以忽略不记，而另外两者的值随着n的增大越来越相近，所以<strong>判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注最高次项的阶数</strong>。<br>判断一个苏纳法好不好，我们不能只通过少量的数据，<strong>某个算法，随着n的增大，它会越来越优与另一个算法</strong>，通过算法时间复杂度来估算算法时间效率</p><h2 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h2><h3 id="算法时间复杂度定义："><a href="#算法时间复杂度定义：" class="headerlink" title="算法时间复杂度定义："></a>算法时间复杂度定义：</h3><p><strong>在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n)&#x3D;O(f(n))。它表示随着问题规模n的增大，算法执行时间的增长率和f(n)的增长率系统，称作算法的渐进时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数</strong><br>这样用大写O()来体现算法时间复杂度的记法，称之为大P记法</p><h3 id="推到大O阶方法"><a href="#推到大O阶方法" class="headerlink" title="推到大O阶方法"></a>推到大O阶方法</h3><ol><li>用常数1取代运行时间中的所有加法常数</li><li>在修改后的运行次数函数中，只保留最高阶项</li><li>如果最高阶项去除与这个项相乘的常数</li></ol><p>举几个例子：</p><ul><li><p>常数阶：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>,n = <span class="hljs-number">100</span>;<span class="hljs-comment">//执行一次</span><br>sum = (<span class="hljs-number">1</span>+n)*n/<span class="hljs-number">2</span>;<span class="hljs-comment">//执行一次</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, sum)<span class="hljs-comment">//执行一次</span><br></code></pre></td></tr></table></figure><p>  这个算法的运行次数函数是f(n)&#x3D;3，把常数项3改为1，保留最高此项发现并没有，所以这个算法的时间复杂度为O(1)，这种与问题的大小无关，时间恒定的算法，称之为常数阶</p></li><li><p>线性阶：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; n; i++)<br>&#123;<br>    <span class="hljs-comment">//时间复杂度为O(1)的程序步骤序列</span><br>&#125;<br></code></pre></td></tr></table></figure><p>  它的时间复杂度为O(n)</p></li><li><p>对数阶：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> count = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(count &lt; n)<br>&#123;<br>    count -= count * <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>  有多少个2相乘后大于n，则会退出循环，2^x&#x3D;n，x&#x3D;log2(n)，所以这个循环的时间复杂度为O(logn).</p></li><li><p>平方阶：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i, j;<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; j++)<br>&#123;<br>    <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>    &#123;<br><span class="hljs-comment">//时间复杂度为0(1)的程序步骤序列</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>  这段代码的时间复杂度为O(n^2)；如果外循环的次数改为m，时间复杂度就是O(m*n)。</p><h3 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h3><p>  <img src="https://img1.imgtp.com/2023/07/22/Ickf1NjL.png" alt="时间复杂度"></p></li></ul><h3 id="最坏情况与平均情况"><a href="#最坏情况与平均情况" class="headerlink" title="最坏情况与平均情况"></a>最坏情况与平均情况</h3><p>假设我们要查找n个随机数字组中的某个数字，最好的情况是第一个数字就是，那么算法的时间复杂度为O(1),但也有可能这个数字是最后一位，那么算法的时间复杂度就是O(n)，这是最坏的情况。<strong>最坏情况运算时间是一种保证，那就是运行时间将不会再坏。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。</strong>而平均运行时间也就是从概率的角度看，这个数字在每一个位置的可能性是系统的，所以平均的查找时间为n&#x2F;2次后发现这个目标。<br><strong>平均时间是所有情况中最有意义的，因为它是期望的运行时间。</strong>也就是说，我们运行一段程序代码时，是希望，看到平均运行时间的。可现实中，平均运行时间很难通过分析得到，一般都是通过运行一定数量的实验数据后估算出来的。<br>对于算法的分析，一种方法是计算所有情况的平均值，这种时间复杂度的计算方法称为平均时间复杂度。另一个种方法是计算最坏情况下的时间复杂度，这种方法称为最坏时间复杂度。<strong>一般在没有特殊说明的情况下，都是指最坏时间复杂度</strong>。</p><h2 id="算法空间复杂度"><a href="#算法空间复杂度" class="headerlink" title="算法空间复杂度"></a>算法空间复杂度</h2><p><strong>算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：O(f(n))，其中n为问题规模，f(n)为语句关于n所占存储空间的函数</strong><br>一般情况下，除了需要存储程序本身的指令、常数变量和输入数据外，还需要存储对数据操作的存储单元。若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为<strong>O(1)。</strong><br>通常，若不加限定的使用“复杂度”，是指时间复杂度，必要时，可以考虑使用空间换取时间。</p><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>线性表是数据结构中最常用最简单的一种结构</p><h2 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h2><p>线性表就好像排队，一个跟着一个，有一个打头的，有一个收尾的，每个人都知道前后是谁。<strong>线性表(List):零个或多个数据元素的有限序列</strong>。<br>首先，线性表是<strong>有序的</strong>，元素之间是有顺序的，若元素有多个，则第一个无前驱，最后一个无后继，其他每个元素都有且只有一个前驱和后继。<br>然后，线性表强调是<strong>有限的</strong>，实际上计算机处理的对象都是有限的，无限只存在于数学概念中。</p><p><img src="https://img1.imgtp.com/2023/07/25/W33R0Lx4.png" alt="线性表"></p><p><strong>线性表元素的个数n(n&gt;&#x3D;0)定义为表的长度，若n&#x3D;0，称为空表</strong>。在非空的线性表中，每个元素都有确定的位置，如a1是第一个数据元素，ai是第i个数据元素，称i为数据元素ai在线性表中的<strong>位序</strong>。</p><h2 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的抽象数据类型</h2><p><img src="https://img1.imgtp.com/2023/07/25/UNGMrYqu.png" alt="1690288730371.png"></p><p><img src="https://img1.imgtp.com/2023/07/25/pGxMxPYx.png" alt="1690288776485.png"></p><p>对于不同的应用，线性表的操作是不同的，上述操作是最基本的</p><h2 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>线性表的顺序存储结构，指的是用一段地址连续的内存单元依次存储线性表的数据元素</strong>，线性表可以用C语言的数组来实现，线性表的顺序存储的结构代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 20  <span class="hljs-comment">//存储空间初始分配量</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<span class="hljs-comment">//元素类型，这里定义为int</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    ElemType data[MAXSIZE];<span class="hljs-comment">//用数组存储数据元素，最大为MAXSIZE</span><br>    <span class="hljs-type">int</span> length;<span class="hljs-comment">//线性表当前长度</span><br>&#125;SqList;<br></code></pre></td></tr></table></figure><p>描述顺序存储结构需要三个属性：</p><ul><li>存储空间的起始位置：数组data，它的起始位置就是存储空间的存储位置</li><li>线性表的最大存储容量：数组长度MAXSIZE</li><li>线性表的当前长度：length</li></ul><h3 id="数据长度和线性表长度的区别"><a href="#数据长度和线性表长度的区别" class="headerlink" title="数据长度和线性表长度的区别"></a>数据长度和线性表长度的区别</h3><p>数组的长度是存放线性表的存储空间的长度，这个长度一般是不变的，也可以用编程手段实现动态分配，不过会带来性能上的损耗。而线性表的长度是线性表中数据元素的个数，随着元素的插入删除，这个值会发生改变。在任意时刻，线性表的长度小于等于数组的长度。</p><h2 id="顺序存储结构的插入与删除"><a href="#顺序存储结构的插入与删除" class="headerlink" title="顺序存储结构的插入与删除"></a>顺序存储结构的插入与删除</h2><h3 id="获得元素操作"><a href="#获得元素操作" class="headerlink" title="获得元素操作"></a>获得元素操作</h3><p>如果我们要实现GetElem操作，即将线性表的第i个元素返回，只要i的数值在下标范围内，把i-1的值返回就成了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRUE 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FALSE 0</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;<br><span class="hljs-comment">//Status是函数的类型，其值是函数结果状态码，如OK等</span><br><span class="hljs-comment">//初始条件：顺序线性表L已存在，1&lt;=i&lt;=ListLenth(L)</span><br><span class="hljs-comment">//操作结果：用e返回L中的第i个数据元素的值</span><br>Status <span class="hljs-title function_">GetElem</span><span class="hljs-params">(Sqlist L, <span class="hljs-type">int</span> i, ELemType *e)</span><br>&#123;<br><span class="hljs-keyword">if</span>(L.length == <span class="hljs-number">0</span> || i &lt; <span class="hljs-number">1</span> || i &gt; L.length)<br>        <span class="hljs-keyword">return</span> ERROR;<br>    *e = L.data[i<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>如果我们要实现ListInsert(*L,i,e)，即在线性表L中的第i个位置插入心元素e，该如何操作？插入算法的思路如下：</p><ul><li>如果插入位置不合理，抛出异常</li><li>如果线性表长度大于等于数组长度，则抛出异常或动态增加容量</li><li>从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置</li><li>将要插入元素填入位置处</li><li>表长加1</li></ul><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始条件:顺序线性表L已存在，1&lt;=i&lt;=Listlength(L)</span><br><span class="hljs-comment">//操作结果：在L中第i个位置之前插入心得数据元素e，L的长度加1</span><br>Status <span class="hljs-title function_">ListInsert</span><span class="hljs-params">(SqList *L,<span class="hljs-type">int</span> i,ElemType e)</span><br>&#123;<br><span class="hljs-type">int</span> k;<br>    <span class="hljs-keyword">if</span> (L-&gt;length == MAXSIZE) <span class="hljs-comment">//顺序表已满</span><br>        <span class="hljs-keyword">return</span> ERROE;<br>    <span class="hljs-keyword">if</span> (i&lt;<span class="hljs-number">1</span> || i&gt; L-&gt;length+<span class="hljs-number">1</span>)<span class="hljs-comment">//当i不在范围内时</span><br>        <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">if</span>(i&lt;=L-&gt;length)<span class="hljs-comment">//插入位置不在表尾</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(k = L-&gt;length - <span class="hljs-number">1</span>; k &gt;= i - <span class="hljs-number">1</span>; k--)<span class="hljs-comment">//将插入位置之后的数据元素向后移动一位</span><br>            L-&gt;data[k+<span class="hljs-number">1</span>]=L-&gt;data[k];<br>    &#125;<br>    L-&gt;data[i<span class="hljs-number">-1</span>] = e;<span class="hljs-comment">//插入新元素</span><br>    L-&gt;length++；<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>删除算法的思路：</p><ul><li>如果删除位置不合理，抛出异常</li><li>取出删除元素</li><li>从删除元素位置开始遍历最后一个元素位置，分别将它们都向前移动一位</li><li>表长减1</li></ul><p>代码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">ListDelete</span><span class="hljs-params">(SqList *L， <span class="hljs-type">int</span> i, ElemType *e)</span><br>&#123;<br>    <span class="hljs-type">int</span> k;<br>    <span class="hljs-keyword">if</span> (L-&gt;length == <span class="hljs-number">0</span>)<span class="hljs-comment">//线性表为空</span><br>        <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">if</span>(i &gt; L-&gt;length || i &lt; <span class="hljs-number">1</span>)<span class="hljs-comment">//删除位置不正确</span><br>        <span class="hljs-keyword">return</span> ERROR;<br>    *e = L-&gt;data[i<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">if</span> (i&lt;L-&gt;length)如果删除不是最后位置<br>    &#123;<br>        <span class="hljs-keyword">for</span>(k = i; k &lt; L-&gt;length)<br>            L-&gt;data[k<span class="hljs-number">-1</span>]=L-&gt;data[k];<span class="hljs-comment">//将删除位置后继元素前移</span><br>    &#125;<br>    L-&gt;length--;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线性表顺序存储结构的优缺点"><a href="#线性表顺序存储结构的优缺点" class="headerlink" title="线性表顺序存储结构的优缺点"></a>线性表顺序存储结构的优缺点</h3><ul><li><strong>优点：</strong><ul><li>无须为表示表中元素之间的逻辑关系而增加额外的存储空间</li><li>可以快速地存取表中任意位置的元素</li></ul></li><li><strong>缺点：</strong><ul><li>插入和删除操作需要移动大量数据</li><li>当线性表长度变化较大时，难以确定存储空间的容量</li><li>造成存储空间的“碎片”</li></ul></li></ul><h2 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h2><h3 id="顺序存储结构不足的解决方法"><a href="#顺序存储结构不足的解决方法" class="headerlink" title="顺序存储结构不足的解决方法"></a>顺序存储结构不足的解决方法</h3><p>线性表的顺序存储结构插入和删除时需要移动大量元素，这需要耗费时间，要解决这个问题，我们可以：<br>让所有元素都不考虑相邻位置，哪里有空位就到哪里，而只是让每个元素知道它下一个元素的位置在哪里。</p><h3 id="线性表链式存储结构定义"><a href="#线性表链式存储结构定义" class="headerlink" title="线性表链式存储结构定义"></a>线性表链式存储结构定义</h3><p>线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组数据元素可以是连续的，也可以是不连续的，这意味着这些数据元素可以存在内存未被占用的任意位置。在以前的顺序结构中，每个元素只要存数据信息就可以了，在链式结构中，除了要存数据元素信息外，还要存储它的后继元素的地址<br>我们把<strong>存储数据元素信息的域成为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称作指针或链。这两部分组成数据元素ai的存储映像，称为结点(Node)</strong><br>n个结点链结成一个链表，即为线性表(a1,a2…an)的链式存储结构，因此此链表的每个结点只包含一个指针域，所以叫单链表</p><p><img src="https://img1.imgtp.com/2023/07/29/YiA7ekAP.png" alt="单链表"></p><p>对于线性表来说，总得有个头和尾，链表也不例外。我们把<strong>链表中第一个结点的存储位置叫做头指针</strong>，那么整个链表的存取就必须从头指针开始进行。之后的每个结点，其实就是上一个的后继指针指向的位置，最后一个结点的指针指向“空”(通常用NULL或^表示)</p><p><img src="https://img1.imgtp.com/2023/07/29/8pnAIBbt.png" alt="头指针"></p><p>有时，我们为了方便对链表操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息，也可以存储如线性表长度等附加信息，头结点的指针域指向第一个结点的指针</p><p><img src="https://img1.imgtp.com/2023/07/29/wO3suBXu.png" alt="头结点"></p><h3 id="头指针与头结点的异同"><a href="#头指针与头结点的异同" class="headerlink" title="头指针与头结点的异同"></a>头指针与头结点的异同</h3><table><thead><tr><th>头指针</th><th>头结点</th></tr></thead><tbody><tr><td>头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针<br>头指针具有标识作用，所以常常用头指针冠以链表的名字<br>无论链表是否为空，头指针均不为空，头指针是链表的必要元素</td><td>头结点是为了操作的统一和方便而设立额，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度）<br>有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其他结点的操作就统一了<br>头结点不一定是链表的必须要素</td></tr></tbody></table><h3 id="线性表链式存储结构代码描述"><a href="#线性表链式存储结构代码描述" class="headerlink" title="线性表链式存储结构代码描述"></a>线性表链式存储结构代码描述</h3><p>单链表中，我们可以用C语言的结构指针来描述</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">&#123;</span><br>ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>&#125; Node;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">LinkList</span>;</span><br></code></pre></td></tr></table></figure><h2 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h2><p>在线性表的顺序存储结构中，我们要计算任意一个元素的存储位置是很容易的，但在单链表中，由于不知道第i个元素到底在哪？必须从头开始找。因此对于单链表实现获取第i个元素的GetElem操作，在算法上要麻烦一些：</p><ol><li>声明一个结点p指向链表第一个结点，初始化j从1开始</li><li>当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1</li><li>若到链表末尾o为空，则说明第i个元素不存在</li><li>若查找成功，返回结点p的数据</li></ol><p>实现代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C">Status <span class="hljs-title function_">GetElem</span><span class="hljs-params">(LinkList L, <span class="hljs-type">int</span> i, ElemType *e)</span><br>&#123;<br><span class="hljs-type">int</span> j;<br>    LinkList p;<span class="hljs-comment">//声明结点p</span><br>    p = L -&gt; next;<span class="hljs-comment">//让p指向链表L的第一个结点</span><br>    j = <span class="hljs-number">1</span>;<span class="hljs-comment">//j为计数器</span><br>    <span class="hljs-keyword">while</span>( p &amp;&amp; j &lt; i)<span class="hljs-comment">//p不为空或j还没有等于i时，循环继续</span><br>    &#123;<br>        p = p -&gt; next;<span class="hljs-comment">//p指向下一个结点</span><br>        ++j;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!p || j&gt;i)<br><span class="hljs-keyword">return</span> ERROR;<span class="hljs-comment">//第i个元素不存在</span><br>    *e = p -&gt; data;<span class="hljs-comment">//取第i个元素的数据</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单链表的插入与删除"><a href="#单链表的插入与删除" class="headerlink" title="单链表的插入与删除"></a>单链表的插入与删除</h2><h3 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h3><p>单链表第i个元素插入结点的算法思路是：</p><ol><li>声明结点p指向第一个结点，初始化j从1开始</li><li>当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加</li><li>若到链表末尾p为空，则说明第i个元素不存在</li><li>否则查找成功，在系统中生成一个空结点s</li><li>将数据元素e赋值给s-&gt;data</li><li>单链表的插入标准语句 s-&gt;next &#x3D; p-&gt;next; p-&gt;next &#x3D; s;</li><li>返回成功</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C">Status <span class="hljs-title function_">ListInsert</span><span class="hljs-params">(LinkList *L, <span class="hljs-type">int</span> i, ElemType e)</span><br>&#123;<br>    <span class="hljs-type">int</span> j;<br>    LinkList p,s;<br>    p = *L;<br>    j = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(p &amp;&amp; i &lt; i)<br>    &#123;<br>        p = p-&gt;next;<br>        +=j;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!p || j &gt; i)<br>        <span class="hljs-keyword">return</span> ERROR;<br>    s = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<span class="hljs-comment">//生成新结点s（C标准函数）</span><br>    s-&gt;data = e;<br>    s-&gt;next = p-&gt;next;<br>    p-&gt;next = s;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h3><p>设存储ai的结点为q，要实现将q删除单链表的操作，其实就是将它的前即继结点p的指针，指向它的后继结点。实际上就是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">q = p -&gt; next; p -&gt; next = q -&gt; next;<br></code></pre></td></tr></table></figure><p>打个比方：妈-&gt;爸-&gt;儿,三人散步，爸爸看了美铝一眼，妈咪不开心，把爸比的手(′д｀ )…彡…彡甩开，拉起儿砸就走，只留下爸爸一人呆在原地，搓着手(q-&gt;next &#x3D; p-&gt;next)不知所措。爸爸就已经和母子没有牵手联系了。<br>单链表第i个元素删除结点的算法思路：</p><ol><li>申明一节点p指向链表的第一个结点，初始化j从1开始</li><li>当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；</li><li>若到链表末尾p为空，则说明第i个元素不存在</li><li>否则查找成功，将欲删除的结点p-&gt;next赋值给q</li><li>单链表的删除标准语句p-&gt;next &#x3D; q-&gt;next</li><li>将q结点中的数据赋值给e，作为返回</li><li>释放q结点</li><li>返回成功</li></ol><p>实现代码算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">LissDelete</span><span class="hljs-params">(LinkList *L; <span class="hljs-type">int</span> i; ElemType *e)</span>;<br>&#123;<br>    <span class="hljs-type">int</span> j;<br>    LinkList p, q;<br>    p = *L;<br>    j = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(p -&gt; next &amp;&amp; j &lt; i)<br>    &#123;<br>p = p -&gt; next;<br>        ++j;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!(p -&gt; next) || j &gt; i)<br>        <span class="hljs-keyword">return</span> ERROR;<br>    q = p -&gt; next;<br>    p -&gt; next = q -&gt; next;<br>    *e = q -&gt; data;<br>    <span class="hljs-built_in">free</span>(q);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单链表的整表创建"><a href="#单链表的整表创建" class="headerlink" title="单链表的整表创建"></a>单链表的整表创建</h2><p>顺序存储结构的创建，其实就是一个数组的初始化，而单链表不像顺序存储结构这么集中，是一种动态结构，所以创建单链表的过程就是一个动态生成链表的过程。即从“空表”的初始状态启，依次建立各结点，并逐个插入链表-<strong>头插法</strong>：</p><ol><li>声明一结点p和计数器变量i</li><li>初始化空链表L</li><li>让L的头结点的指针指向NULL，即建立一个带头结点的单链表</li><li>循环：<ol><li>生成一新节点赋值给p</li><li>随机生成一数字赋值给p的数据域p-&gt;data</li><li>将p插入到头结点与前一新结点之间</li></ol></li></ol><p>实现代码算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//随机产生n个元素的值，建立带头结点的单链线性表L（头插法）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">CreateListHead</span><span class="hljs-params">(LinkList *L, <span class="hljs-type">int</span> n)</span><br>&#123;<br>    LinkList p;<br>    <span class="hljs-type">int</span> i;s<br>    <span class="hljs-title function_">srand</span><span class="hljs-params">(time(<span class="hljs-number">0</span>))</span>;<span class="hljs-comment">//初始化随机数种子</span><br>    *L = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    (*L)-&gt;next = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//建立一个带头结点的单链表</span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>p = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<span class="hljs-comment">//生成新结点</span><br>        p-&gt;data = rand()%<span class="hljs-number">100</span>+<span class="hljs-number">1</span>;<span class="hljs-comment">//随机生成100以内的数字</span><br>        p-&gt;next = (*L)-&gt;next;<br>        (*L)-&gt;next = p;<span class="hljs-comment">//插入到表头</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还可以把新结点放到最后，即尾插法，实现代码算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//随机产生n个元素的值，建立带头结点的单链线性表L(尾插法)</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">CreateListTail</span><span class="hljs-params">(LinkList *L, <span class="hljs-type">int</span> n)</span><br>&#123;<br>LinkList p,r;<br>    <span class="hljs-type">int</span> i;<br>    srand(time(<span class="hljs-number">0</span>));<span class="hljs-comment">//初始化随机数种子</span><br>    *L = (LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    r = *L;<span class="hljs-comment">//r为指向尾部的结点</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>p = (Node*)maclloc(<span class="hljs-keyword">sizeof</span>(Node));<span class="hljs-comment">//生成新结点</span><br>        p-&gt;data = rand()%<span class="hljs-number">100</span>+<span class="hljs-number">1</span>;<br>        r-&gt;next = p;<br>        r = p;<br>    &#125;<br>    r-&gt;next = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单链表整表删除"><a href="#单链表整表删除" class="headerlink" title="单链表整表删除"></a>单链表整表删除</h2><p>单链表整表删除的算法思路如下：</p><ol><li>声明一结点p和s</li><li>将第一个结点赋值给p</li><li>循环：<ol><li>将下一个结点赋值给s</li><li>释放p</li><li>将s赋值给p</li></ol></li></ol><p>实现代码算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C">ClearList(LinkList *L)<br>&#123;<br>LinkList p,s;<br>    p = (*L)-&gt;next;<br>    <span class="hljs-keyword">while</span>(p)<br>    &#123;<br>s = p-&gt;next;<br>        <span class="hljs-built_in">free</span>(p);<br>        p = s;<br>    &#125;<br>    (*L)-&gt;next = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单链表结构与顺序存储结构优缺点"><a href="#单链表结构与顺序存储结构优缺点" class="headerlink" title="单链表结构与顺序存储结构优缺点"></a>单链表结构与顺序存储结构优缺点</h2><table><thead><tr><th></th><th>顺序存储结构</th><th>链式存储结构</th></tr></thead><tbody><tr><td>存储分配方式</td><td>用一段连续的存储单元依次存储线性表的数据元素</td><td>采用链式存储结构，用一组任意的存储单元存放线性表</td></tr><tr><td>时间性能</td><td>查找：O(1)<br>插入和删除：平均移动表长一半的元素O(n)</td><td>查找：O(n)<br>插入和删除：单链表在超出某位置后，插入和删除的时间仅为O(1)</td></tr><tr><td>空间性能</td><td>需要预分配，分大了浪费，小了容易发生上溢</td><td>不需要预分配，只要有就可以分配，元素个数也不受限制</td></tr></tbody></table><h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><p>C语言有指针，可以非常容易地操作内存中的地址和数据，而后来的面向对象，如Java、C#等，虽不用指针，单因为启用了对象引用机制，从某种角度也间接实现了指针的某些作用。但对于Bassic、Fortran等早期的编程高级语言，由于没有指针，链表结构无法按照我们前面的方法实现，怎么办呢？<br>有人就想到了用数组代替指针，来描述单链表<br>首先，我们让数组的元素都是由来个数据域组成，<strong>data</strong>和<strong>cur</strong>。也就是说数组的每个下标都对应一个data和cur，data用来存放数据元素，也就是通常我们要处理的数据；而<strong>游标cur</strong>相当于单链表中的next指针，存放该元素的后继在数组中的下标，我们把这种<strong>用数组描述的链表叫静态链表</strong>，也有叫游标实现法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 1000<span class="hljs-comment">//假设链表的最大长度是1000</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    ElemType data;<br>    <span class="hljs-type">int</span> cur;<span class="hljs-comment">//游标Cursor,为0时表示无指向</span><br>&#125;Component, StaticLinkList[MAXSIZE];<br></code></pre></td></tr></table></figure><p>我们对数组第一个和最后一个元素作为特殊元素处理，不存数据。通常把<strong>未被使用的数组元素称为备用链表</strong>。而数组第一个元素，即<strong>下标为0的元素的cur</strong>就存放备用链表的<strong>第一个结点的下标</strong>；而数组的<strong>最后一个元素</strong>的cur则<strong>存放第一个有数值的元素的下标</strong>，相当于单链表中的头结点作用，当整个链表为空时，则为0^2<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//将一维数组space中各分量链成一备用链表</span><br><span class="hljs-comment">//spance[0].cur为头指针，“0”表示空指针</span><br>Status <span class="hljs-title function_">InitList</span><span class="hljs-params">(StaticLinkList space)</span><br>&#123;<br><span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; MAXSIZE - <span class="hljs-number">1</span>; i++)<br>        space[i].cur = i+<span class="hljs-number">1</span>;<br>    space[MAXSIZE<span class="hljs-number">-1</span>].cur = <span class="hljs-number">0</span>;<span class="hljs-comment">//目前静态链表为空，最后一个元素的cur为0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于不提供struct的，可以使用一对并行数组data和cur来处理。<br>假设现在我们已经存入元素“甲、乙，丁…”</p><p><img src="https://img1.imgtp.com/2023/08/02/RMgWK0km.png" alt="静态链表"></p><p>在最后一个有值元素，它的cur设置为0。而最后一个元素的cur，则因”甲“是第一有值元素而存有它的下标1.第一个元素则因空闲空间的第一个元素下标为7，所以它的cur存为7。</p><h3 id="静态链表的插入操作"><a href="#静态链表的插入操作" class="headerlink" title="静态链表的插入操作"></a>静态链表的插入操作</h3><p>在动态链表中，结点的申请和释放分别使用malloc()和free（），在静态链表中，操作的是数组，不存在这样的问题。为了辨明数组中哪些分量未被使用，解决的方法是将所有<strong>未被使用过的</strong>及 <strong>已被删除的分量</strong>用游标链组成一个备用链表，每当进行插入时，便可以从备用链表上取得第一个结点作为待插入的新结点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//若备用空间链表非空，则返回分配的结点下标，否则返回0</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Malloc_SLL</span><span class="hljs-params">(StaticLinkList space)</span><br>&#123;<br>    <span class="hljs-type">int</span> i = space[<span class="hljs-number">0</span>].cur;<span class="hljs-comment">//当前数组第一个元素的cur存的值</span><br>    <span class="hljs-comment">//就是要返回的第一个备用空间的下标</span><br>    <span class="hljs-keyword">if</span>(space[<span class="hljs-number">0</span>].cur)<br>space[<span class="hljs-number">0</span>].cur = space[i].cur;<br>        <span class="hljs-comment">//由于要拿出一个分量来使用，所以得</span><br>        <span class="hljs-comment">//把下一个分量用来做备用</span><br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码可以返回数组头元素的cur存的第一个空闲的下标。然后将下一个空闲的下标赋值给头元素。<br></p><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>**将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表(circular linkedlist)**。循环链表可以解决一个很麻烦的问题：如何从当中一个结点出发，访问到链表的全部结点。<br>为了使空链表与非空链表处理一致，我们通常设一个头结点，但并不是说一定要有头结点。循环链表带有头结点的空链表如图：</p><p><img src="https://img1.imgtp.com/2023/08/05/eiV9fDec.png" alt="带头结点循环空链表"></p><p>带头结点的非空链表如图：</p><p><img src="https://img1.imgtp.com/2023/08/05/v1OzAodx.png" alt="带头结点循环非空链表"></p><p>其实循环链表和单链表的主要差异再循环的判断条件上，原来判断p-&gt;next是否为空，现在则是p-&gt;next !&#x3D; 头结点。在单链表中，可以用O(1)的时间访问第一个结点，而最后一个结点却要O(n)，有没有可能用O(1)的时间访问到最后一个结点呢？<br>我们改造一个循环链表，不用头指针表示链表，而是用指向终端结点的尾指针来表示循环链表，此时查找开始结点和终端结点就很方便了</p><p><img src="https://img1.imgtp.com/2023/08/05/SljJwwWR.png" alt="用尾指针表示循环链表"></p><p>终端结点用尾指针rear指示，则查找终端结点是0(1)，而开始结点，其实就是rear-&gt;next-&gt;next，其时间复杂度也为0(1)。<br>有了尾指针会方便很多，比如要将两个循环链表合并成一个表时，两个尾指针分别为rearA和rearB：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">p = rearA-&gt;next;<span class="hljs-comment">//保存A表的头结点</span><br>rearA-&gt;next = rearB-&gt;next-&gt;next<span class="hljs-comment">//将本是指向B表的第一个//结点（不是头结点）赋值给rearA-&gt;next</span><br>rearB-&gt;next = p;<span class="hljs-comment">//将原A表的头结点赋值给rearB-&gt;next</span><br><span class="hljs-built_in">free</span>(p);<span class="hljs-comment">//释放P</span><br></code></pre></td></tr></table></figure><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>在单链表中，有了next指针，这就使得我们要查找下一结点的时间复杂度未O(1)。可是如果要查找上一结点的话，那最坏的情况就是O(n)了，因为要从头开始遍历查找。为了克服这一缺点，就设计出了双向链表。<strong>双向链表(double linked list)是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。</strong>所以再双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DulNode</span></span><br><span class="hljs-class">&#123;</span><br>ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DulNode</span> *<span class="hljs-title">prior</span>;</span><span class="hljs-comment">//直接前驱指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DulNode</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//直接后继指针</span><br>&#125;DulNode, *DuLinkList;<br></code></pre></td></tr></table></figure><p>既然单链表有循环链表，那么双向链表也可以有循环链表。<br>双向链表的循环带头节点的空链表如图：</p><p><img src="https://img1.imgtp.com/2023/08/06/jGbnWzwc.png" alt="空循环双向链表"></p><p>非空的循环的带头节点的双向链表如图</p><p><img src="https://img1.imgtp.com/2023/08/06/jFN9PF0Y.png" alt="非空循环带头节点双向链表"></p><p>双向链表的插入，假设待插入结点为s，s将插入到p与p-&gt;next之间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">s-&gt;prior = p;<br>s-&gt;next = p-&gt;prior;<br>p-&gt;next-&gt;prior = s;<br>p-&gt;next = s;<br></code></pre></td></tr></table></figure><p>双向链表的删除比较简单，假设要删除p结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">p-&gt;prior-&gt;next = p-&gt;next;<br>p-&gt;next-&gt;prior = p-&gt;prior;<br><span class="hljs-built_in">free</span>(p);<br></code></pre></td></tr></table></figure><h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><p><strong>栈的定义：****栈（stack）是限定仅在表尾进行插入和删除操作的线性表</strong><br>我们把插入和删除的一段成为栈顶（top），另一端成为栈底（bottom），不含任何元素的栈称为空栈。栈又称为后进先出（Last In First Out）的线性表，<strong>简称LIFO结构</strong>。<br>栈的插入操作，叫作压栈、入栈。类似子弹入弹夹；<br>栈的输出操作，叫作出栈，有的也叫弹栈。如同弹夹中的子弹出夹</p><h2 id="进栈出栈变化形式"><a href="#进栈出栈变化形式" class="headerlink" title="进栈出栈变化形式"></a>进栈出栈变化形式</h2><p>最先进栈的元素，不一定最后出栈，在不是所有元素都进栈的情况下，事先进去的元素也可以出栈，只要保证是栈顶元素出栈就可以，比如可以进一个出一个（123进，123出）、全进再出（123进，321出）…以此类推，仅仅三个元素就有5种可能的出栈次序，如果元素数量多，变化还会更多。</p><h2 id="栈的抽象数据结构"><a href="#栈的抽象数据结构" class="headerlink" title="栈的抽象数据结构"></a>栈的抽象数据结构</h2><p>对于栈来讲，理论上线性表的操作特性它都具备，可由于他的特殊性，所以它的操作会有些变化，特别是插入和删除操作，我们改名<strong>push</strong>和<strong>pop</strong>，英文直译的话是弹和压，我们一般叫进栈和出栈</p><p><img src="https://img1.imgtp.com/2023/08/07/Hk8o5Uqf.png" alt="栈的抽象结构"></p><h2 id="栈的顺序存储结构及实现"><a href="#栈的顺序存储结构及实现" class="headerlink" title="栈的顺序存储结构及实现"></a>栈的顺序存储结构及实现</h2><p>既然栈式线性表的特例，那么栈的顺序存储结构其实也是线性表顺序存储的简化，我们简称为顺序栈。线性表式用数组实现的，对于栈，我们把下标为0的一端作为栈底，定义一个top变量指示栈顶元素在数组中的位置，同时若存储栈的长度为StackSize，则栈顶位置top必须小于它。当栈存在一个元素时，top等0，因此通常把空栈的判定条件定位top等于-1</p><p>栈的结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> SElmType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>SelemType data[MAXSIZE];<br>    <span class="hljs-type">int</span> top;<br>&#125;SqStack;<br></code></pre></td></tr></table></figure><h3 id="顺序存储结构-进栈操作"><a href="#顺序存储结构-进栈操作" class="headerlink" title="顺序存储结构-进栈操作"></a>顺序存储结构-进栈操作</h3><p>对于进栈操作pash，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">Push</span><span class="hljs-params">(SqStack *s, SElemType e)</span><br>&#123;<br><span class="hljs-keyword">if</span>(s-&gt;top == MAXSIZE - <span class="hljs-number">1</span>)<span class="hljs-comment">//栈满</span><br>        <span class="hljs-keyword">return</span> ERROR;<br>    s-&gt;top ++;<br>    s-&gt;data[s-&gt;top] = e;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="顺序存储结构-出栈操作"><a href="#顺序存储结构-出栈操作" class="headerlink" title="顺序存储结构-出栈操作"></a>顺序存储结构-出栈操作</h3><p>出栈操作pop，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//若栈不为空，则删除s的栈顶元素并用e返回其值并返回OK，否则返回ERROER</span><br>Status <span class="hljs-title function_">Pop</span><span class="hljs-params">(SqStack *s, SElemType *e)</span><br>&#123;<br><span class="hljs-keyword">if</span>(s-&gt;top == <span class="hljs-number">-1</span>)<span class="hljs-comment">//空栈</span><br>        <span class="hljs-keyword">return</span> ERROR<br>    *e = s-&gt;data[s-&gt;top];<br>    s-&gt;top --;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="两栈共享空间"><a href="#两栈共享空间" class="headerlink" title="两栈共享空间"></a>两栈共享空间</h2><p>栈的顺序结构还是很方便的，因为它只准栈顶进出元素，所以不存在线性表插入和删除时需要移动元素的问题，不过它必须事先确定数组存储空间大小，万一不够用了，就需要编程手段来扩展数组的容量，非常麻烦。对于一个栈，我们只能考虑周全，设计出合适大小的数组空间来处理，但对于两个相同类型的栈，我们却可以做到最大限度地利用其事先开辟的存储空间来进行操作。我们可以用一个数组来存储两个栈，只不过需要点小技巧。<br>关键思路就是：它们是在数组的两端，向中间靠拢。top1和top2是栈1和栈2的栈顶指针，只要它们两个不见面，两个栈就可以一直使用了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>SElemType data[MAXSIZE];<br>    <span class="hljs-type">int</span> top1;<span class="hljs-comment">//栈1栈顶指针</span><br>    <span class="hljs-type">int</span> top2;<span class="hljs-comment">//栈2栈顶指针</span><br>&#125;SqDoubleStack;<br></code></pre></td></tr></table></figure><p>对于v两栈共享空间的push方法，我们除了要插入元素值参数外，还需要一个判断是栈1还是栈2的栈号参数stackNumber。插入代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">Push</span><span class="hljs-params">(SqDoubleStack *s, SelemType e, <span class="hljs-type">int</span> stackNumber)</span><br>&#123;<br><span class="hljs-keyword">if</span> (s-&gt;top1 + <span class="hljs-number">1</span> == s-&gt;top2)<span class="hljs-comment">//栈已满，不能再push新元素了</span><br>        <span class="hljs-keyword">return</span> ERROR;<br>    <span class="hljs-keyword">if</span> (stackNumber == <span class="hljs-number">1</span>)<span class="hljs-comment">//栈1有元素进栈</span><br>        s-&gt;data[ ++ s-&gt;top1] = e;<span class="hljs-comment">//先top1+1后给元素赋值</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stackNumber == <span class="hljs-number">2</span>)<span class="hljs-comment">//栈2有元素进栈</span><br>        s-&gt;data[ -- s-&gt;top2] = e;<span class="hljs-comment">//先top2-1后给元素赋值</span><br>    <span class="hljs-keyword">return</span> OK;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>对于两栈共享空间的pop方法，参数就只是判断栈1栈2的参数stackNumber:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//若栈不为空，则删除s的栈顶元素，用e返回其值，并发返回OK，否则返回ERROR</span><br>Status <span class="hljs-title function_">Pop</span><span class="hljs-params">(SqDoubleStack *s, SEmemType *e, <span class="hljs-type">int</span> stackNumber)</span><br>&#123;<br><span class="hljs-keyword">if</span>(stackNumber == <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(s-&gt;top1 == <span class="hljs-number">-1</span>)<span class="hljs-comment">//栈1为空</span><br>            <span class="hljs-keyword">return</span> ERROR;<br>        *e = s-&gt;data[ s-&gt;top1 --];<span class="hljs-comment">//将栈1的栈顶元素出栈</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stacakNumber == <span class="hljs-number">2</span>)<br>    &#123;<br><span class="hljs-keyword">if</span>(s-&gt;top2 == MAXSIZE)<span class="hljs-comment">//栈2为空</span><br>            <span class="hljs-keyword">return</span> ERROR;<br>        *e = s-&gt;data[ s-&gt;top2 ++]<span class="hljs-comment">//将栈2的栈顶元素出栈</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="栈的链式存储结构及实现"><a href="#栈的链式存储结构及实现" class="headerlink" title="栈的链式存储结构及实现"></a>栈的链式存储结构及实现</h2><p><strong>栈的链式存储结构，简称链栈</strong>，栈只有栈顶来插入和删除，那么栈顶是放在链表的头部还是尾部好呢？由于单链表有头指针，而栈顶指针也是必须的，不如让它两合二为一，另外都已经有了栈顶再头部了，单链表中常用的头节点也就失去了意义，通常对于链栈来说，是不需要头节点的。</p><p><img src="https://img1.imgtp.com/2023/08/08/MxTuT0Gc.png" alt="链栈"></p><p>对于链栈来说，基本不存在栈满的情况，除非内存已经没有可以使用的空间，如果真的发生，那此时的计算机操作系统已经面临死机崩溃的边缘了，而不是这个链栈是否溢出的问题。<br>但对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是top&#x3D;NULL的时候：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StackNode</span></span><br><span class="hljs-class">&#123;</span><br>SElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StackNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;StackNode, *LinkStackPtr;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkStack</span></span><br><span class="hljs-class">&#123;</span><br>    LinkStackPtr top;<br>    <span class="hljs-type">int</span> count;<br>&#125;LinkStack;<br></code></pre></td></tr></table></figure><h3 id="栈的链式存储结构-进栈操作"><a href="#栈的链式存储结构-进栈操作" class="headerlink" title="栈的链式存储结构-进栈操作"></a>栈的链式存储结构-进栈操作</h3><p><img src="https://img1.imgtp.com/2023/08/08/9hMvZnts.png" alt="链栈进栈"></p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//输入元素e为新的栈顶元素</span><br>Status <span class="hljs-title function_">Push</span><span class="hljs-params">(LinkStack *s, SEmleType e)</span><br>&#123;<br>LinkStackPtr p = (LinkStackPtr)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(StackNode));<br>    p-&gt;data = e;<br>    p-&gt;next = s-&gt;top;<br>    s-&gt;top = p;<br>    s-&gt;count ++;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="栈的链式存储结构-出栈操作"><a href="#栈的链式存储结构-出栈操作" class="headerlink" title="栈的链式存储结构-出栈操作"></a>栈的链式存储结构-出栈操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">pop</span><span class="hljs-params">(LinkStack *s)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(s-&gt;top == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> ERROE;<br>LinkStackPtr p;<br>    p = (*s)-&gt;top-&gt;next;<br>    <span class="hljs-built_in">free</span>((*s)-&gt;top);<br>    (*s)-&gt;top = p;<br>    (*s)-&gt;count --;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果栈的使用过程中元素变化不可预料，有时很大，有时很小，那么最好使用链栈，反之，若在可控范围内，则建议使用顺序栈。</p><h2 id="栈的应用-递归"><a href="#栈的应用-递归" class="headerlink" title="栈的应用- 递归"></a>栈的应用- 递归</h2><p>栈有一个很重要的应用：在程序设计语言中实现了递归。先来看一个经典的递归例子：斐波那契数列：<br>我们拿新出生的一对小兔子分析一下：第一个月小兔子没有繁殖能力，所以还是一对；两个月后，生下一对小兔子，小兔子数共有2对；三个月后，老兔子又生下了一对，因为小兔子还没有繁殖能力，所以一共是3对……依次类推，可以得出下表：</p><table><thead><tr><th>所经过的月数</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>兔子对数</td><td>1</td><td>1</td><td>2</td><td>3</td><td>4</td><td>8</td><td>13</td><td>21</td><td>34</td></tr></tbody></table><p>这个数列有个十分明显的特点：前面相邻两项之和，构成了后一项，如图所示：</p><p><img src="https://img1.imgtp.com/2023/08/09/kgDcRK7Z.png" alt="斐波那契数列"></p><p>可以发现，编号①的一对兔子经过6个月就变成了8对兔子，如果我们用数学函数来定义就是：</p><table><thead><tr><th></th><th>0，当n&#x3D;0</th></tr></thead><tbody><tr><td>F(n)</td><td>1，当n&#x3D;1</td></tr><tr><td></td><td>F(n-1)+F(n-2),当n&gt;1</td></tr></tbody></table><p>如果我们要实现这样的数列用常规的迭代的办法，假设要打印出前40位斐波那契数列。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> i;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">40</span>];<br>    a[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    a[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">2</span>; i &lt; <span class="hljs-number">40</span>; i++)<br>    &#123;<br>a[i] = a[i<span class="hljs-number">-1</span>] + a[i<span class="hljs-number">-2</span>];<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但其实我们如果用递归来实现，还可以更简单</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Fbi</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><br>&#123;<br>i(i&lt;<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> i == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span>:<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> Fbi(i<span class="hljs-number">-1</span>) + Fbi(i<span class="hljs-number">-2</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> i ;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">40</span>; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,Fbi(i));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递归定义"><a href="#递归定义" class="headerlink" title="递归定义"></a>递归定义</h3><p>在高级语言中，调用自己和其他函数并没有本质的不同。我们把一个<strong>直接调用自己或通过一系列的调用语句间接地调用自己的函数，称作递归函数。</strong><br>写递归程序最怕的就是陷入无穷递归中，所以，<strong>每个递归定义必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出。</strong><br>对比两种实现斐波那契的代码。迭代和递归的区别时：迭代使用的是循环结构，递归使用的是选择结构。递归能使程序的结构更清晰、更简介、更容易让人理解，从而减少读懂代码的时间。但大量的递归调用回建立函数的副本，回耗费大量的时间和内存。迭代则不需要反复调用函数和占用额外的内存。因此我们应该视不同情况选择不同的代码实现方式。</p><p><br>讲了那么多递归，和栈有什么关系呢？这得从计算机系统的内部说起。前面我们已经看到递归是如何执行它的前行和退回阶段。递归过程退回的顺序是它前行顺序的逆序。在退回过程中，可能要执行某些动作，包括回复在前行过程中存储起来的某些数据。<br>这种存储某些数据，并在后面又以存储的逆序恢复这些数据，以提供之后使用的需求，显然很符合栈这样的数据结构，因此，编译器使用栈实现递归就没什么好惊讶的了。<br>简单的说，就是在前行阶段，对于每一层递归，函数的局部变量、参数值以及返回地址都压入栈中。在退回阶段，位于栈顶的局部变量、参数值和返回地址被弹出，用于返回调用层次中执行代码的其余部分，也就是恢复了调用的状态。<br>当然，对于现在的高级语言，这样的递归问题是不需要用户来管理这个栈的，一切都由系统代劳了。</p><h2 id="栈的应用-四则运算表达式求值"><a href="#栈的应用-四则运算表达式求值" class="headerlink" title="栈的应用-四则运算表达式求值"></a>栈的应用-四则运算表达式求值</h2><h3 id="后缀（逆波兰）表示法定义"><a href="#后缀（逆波兰）表示法定义" class="headerlink" title="后缀（逆波兰）表示法定义"></a>后缀（逆波兰）表示法定义</h3><p>栈的现实应用也很多，我们再来重点讲一个比较常见的应用：数学表达式的求值。<br>比如计算器，单纯的加减或乘除计算器都能很快的算出，但遇上四则运算，先乘除后加减和带括号的算式，早期的计算器就有点吃力了，而在后来出的计算器就引入了四则运算表达式的概念，也可以输入括号了。<br>那么在新式计算器中，它是如何实现的呢？这里面的困难就在于乘除在加减的后面，却要先运算，而加入括号后，就变得更加复杂。不知道如何处理。<br>但仔细观察后发现，括号都是成对出现的，有左括号就一定会有右括号，对于多重括号，最终也是完全嵌套匹配的。这用栈结构正好合适，只有碰到左括号，就将此左括号进栈，不管表达式有多少重括号，反正遇到左括号就进栈，而后面出现右括号时，就让栈顶的左括号出栈，期间让数字运算，这样，最终有括号的表达式从左到右时巡查一遍，栈应该是由空到有元素，最终再因全部匹配成功后成为空栈的结果。</p><p>但对于四则运算，括号也只是其中的一部分，先乘除后加减使得问题依然复杂，如何有效地处理它们呢？我们伟大的科学家想到了好办法。</p><p><br>20世纪50年代，一位波兰逻辑学家想到了一种<strong>不需要括号的后缀表达式，我们把它称为逆波兰(Reverse Polish Notation, RPN)表示。</strong><br>我们先来看看，对于“9+（3-1）*3+10&#x2F;2”，如果要用后缀表示法应该是：“9 3 1-3*+10 2&#x2F;+”这样的表达式称为后缀表达式，所有的符号都是再要运算数字的后面出现。</p><h3 id="后缀表达式计算结果"><a href="#后缀表达式计算结果" class="headerlink" title="后缀表达式计算结果"></a>后缀表达式计算结果</h3><p>为了解释后缀表达式的好处，我们先来看看计算机如何应用后缀表达式计算出最终的结果：“9 3 1-3*+10 2&#x2F;+<Br>规则：从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶的两个数字出栈，进行运算，运算结果出栈，一直到最终获得结果。</p><ol><li>初始化一个空栈，此栈用来对要计算的数字进出使用</li><li>后缀表达式中前三个都是数组，所以9 3 1进栈</li><li>接下来是”-“，所以将栈中的1出栈作为减数，3出栈作为被减数，并运算3-1，得到2，再将2进栈</li><li>接着是数字3进栈</li><li>后面是”*“，也就意味着栈中3和2出栈，2与3相乘，得到6，并将6进栈</li><li>下面是”+“，所以栈中6和9出栈，9与6相加，得到15，将15进栈</li><li>接着是10与2两数字进栈</li><li>接下来是符号”&#x2F;“，栈顶的2与10出栈，10与2相除，得到5，将5进栈</li><li>最后一个符号是”+“，15与5出栈并相加，得到20，将20进栈</li><li>结果是20，出栈，栈变为空</li></ol><p>后缀表达法可以很顺利的解决计算的问题，那么这个后缀表达式是怎么出来的？</p><h3 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h3><p>我们把平时所用的标准四则运算表达式叫做中缀表达式，所有的运算符号都在两数字的中间，中缀表达式转后缀表达式规则：<br>从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式中的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。</p><ol><li>初始化一空栈，用来对符号进出栈使用</li><li>第一个字符是9，输出9，后面符号是”+“，进栈</li><li>第三个符号是”（“，依然是符号，因其只是左括号，还未配对，故进栈</li><li>第四个字符是数字3，输出，总表达式9 3，接着是”-“，进栈</li><li>接下来是数字1，输出，总表达式9 3 1，后面是符号”）“，此时我们需要去匹配此前的”（“，所以栈顶依次出栈，并输出，知道”（“出栈为止。此时左括号上方只有”-“，因此输出”-“，总表达式为9 3 1-</li><li>接着是数字3，输出，总表达式9 3 1-3.接着是符号“*”，此时栈顶符号是”+“，优先级低于”x”，因此不能输出，”x”进栈</li><li>之后是符号“+”，此时当前栈顶元素“x”比“+”的优先级高，因此栈中元素出栈并输出（没有比“+”优先级更低的优先级，所以全部出栈），总输出表达式为9 3 1 - 3*+。然后将当前这个符号“+”进栈。</li><li>紧接着数字10，输出，后是符号“&#x2F;”，所以“&#x2F;”进栈</li><li>最后一个数字2，输出，总的表达式为9 3 1-3*+10 2.</li><li>因已经到最后，所以将栈中符号全部出栈并输出，最终输出的后缀表达式结果为9 3 1-3*+10 2&#x2F;+</li></ol><p>从刚才的推到中会发现，要想让计算机具有处理我们通常的标准（中缀表达式）的能力，最重要的两步九四：</p><ol><li>将中缀表达式转化为后缀表达式（栈用来进出运算的符号）</li><li>将后缀表达式进行运算得出结果（栈用来进出运算的数字）</li></ol><h2 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h2><p>有时用电脑时，机器有时处于疑似死机的状态，鼠标点什么似乎都没用，双击任何快捷方式都不动弹。就当你失去耐心打算reset时突然他像酒醒了一样，把你刚才点击的所有操作全部都按顺序执行了一遍。这其实是因为操作系统中的多个程序需要通过一个通道输出，而按先后次序排队等待造成的。<br><strong>队列(queue)是只允许再一段进行插入操作，而在另一端进行删除操作的线性表。</strong><br>队列是一种先进先出（First In First Out）的线性表，简称FIFO。允许插入的一段称为队尾，允许删除的一段称为队头。</p><h2 id="队列的抽象数据结构"><a href="#队列的抽象数据结构" class="headerlink" title="队列的抽象数据结构"></a>队列的抽象数据结构</h2><p>同样是线性表，队列也有类似线性表的各种操作，不同的就是插入数据只能在队尾进行，删除数据只能在队头进行</p><p><img src="https://img1.imgtp.com/2023/08/09/DwiuKZZ7.png" alt="1队列"></p><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>线性表有顺序存储和链式存储，队列也是线性表，同样存在这两种存储方式。</p><h3 id="队列顺序存储的不足"><a href="#队列顺序存储的不足" class="headerlink" title="队列顺序存储的不足"></a>队列顺序存储的不足</h3><p>假设队列有n个元素，建立一个大于n的数组，并把元素存储在前n个单元，数组下标为0的一段是队头。入队列操作就是在队尾追加一个元素，时间复杂度为O(1)。而与栈不同，队列的出列是在队头，下标为0的位置，那就意味着所有元素都得向前移动，以保证队列的队头不为空。此时时间复杂度为O(n)<br>但想想，为什么出队列一定要全部移动呢？如果队头不需要一定在下标为0的位置，出队列的性能将会大大增加，引入两个指针<strong>front</strong>指向队头，<strong>rear</strong>指向队尾元素的下一个位置（不指向队尾，因为只有一个元素时会两指针会重合），但两者重合时，为空队列。<br>但这样又有新的问题，随着出队列和入队列的操作，前面会产生空缺未被使用，随着入队列元素的增加，就会产生数组越界的错误，可实际上前面位置是空闲的，我们把这种现象叫做<strong>”假溢出“</strong>。</p><h3 id="循环队列的定义"><a href="#循环队列的定义" class="headerlink" title="循环队列的定义"></a>循环队列的定义</h3><p>所以解决假溢出的办法就是后面满了，就再从头开始，也就是头尾相接的循环，<strong>我们把队列的这种头尾相接的顺序存储结构称为循环队列</strong><br>继续我们刚才的例子，当即将假溢出时，将<strong>rear</strong>指向下标0，接着继续插入元素，当rear与front指针重合时，队列就满了，但是这样又有新问题：</p><ul><li>我们刚才说，空队列时，front等于rear，现在队列满了也是，那么该如何判断时空还是满呢？</li><li>办法一就是设置一个标志变量flag，当front &#x3D;&#x3D; rear，且flag &#x3D; 0时，队列为空，当front &#x3D;&#x3D; rear且flag&#x3D;1时，队列为满</li><li>办法二说是当队列为空时，条件就是front&#x3D;&#x3D;rear，当队列满时，我们修改其条件，保留一个元素空间。也就是说，当队列满时，数组中还有一个空闲单元。</li></ul><p>我们重点来讨论第二种方法，由于rear可能比front大，也可能比front小，所以尽管它们只相差一个位置时就是满的情况，但也可能是相差整整一圈。所以若队列的最大尺寸为QueueSize,那么队列满的条件是（rear+1)%QueueSize &#x3D;&#x3D; front(取模的目的就是为了整个rear与front大小为一个问题)。</p><p>另外当rear&gt;front时，此时队列的长度为rear-front。但当rear&lt;front时，队列长度为两段，一段是QueueSize-front，另一段0+rear，加在一起，队列长度为rear-front+QueueSize。因此通用的计算队列长度公式为：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(rear-front+QueueSize)</span><span class="hljs-meta">%</span>QuwuwSize<br></code></pre></td></tr></table></figure><p>队列的顺序存储结构代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> QElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>QElemType data[MAXSIZE];<br>    <span class="hljs-type">int</span> front;<span class="hljs-comment">//头指针</span><br>    <span class="hljs-type">int</span> rear;<span class="hljs-comment">//尾指针，若队列不空，指向队列尾元素的下一个位置</span><br>&#125;SqQueue;<br></code></pre></td></tr></table></figure><p>循环队列的初始化代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">InitQueue</span><span class="hljs-params">(SqQueue *Q)</span><br>&#123;<br>Q-&gt;front = <span class="hljs-number">0</span>;<br>    Q-&gt;rear = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>K;<br>&#125;<br></code></pre></td></tr></table></figure><p>循环队列求队列长度代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">QueueLenght</span><span class="hljs-params">(SqQueue Q)</span><br>&#123;<br><span class="hljs-keyword">return</span> (Q.rear - Q.front + MAXSIZE)%MAXSIZE;<br>&#125;<br></code></pre></td></tr></table></figure><p>循环队列的入队列操作代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">EnQueue</span><span class="hljs-params">(SqQueue *Q, QElemType e)</span><br>&#123;<br><span class="hljs-keyword">if</span> ((Q-&gt;rear+<span class="hljs-number">1</span>)%MAXSIZE == Q-&gt;front)<span class="hljs-comment">//队列满的判断</span><br>        <span class="hljs-keyword">return</span> ERROR;<br>    Q-&gt;data[Q-&gt;rear] = e;<span class="hljs-comment">//将e元素赋值给队尾</span><br>    Q-&gt;rear = (Q-&gt;rear + <span class="hljs-number">1</span>) % MAXSIZE;<span class="hljs-comment">//若到最后则转到数组头部</span><br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>循环队列的出队操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">DeQueue</span><span class="hljs-params">(SqQueue *Q, QElemType *e)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(Q-&gt;front == Q-&gt;rear)<span class="hljs-comment">//队列空的判断</span><br>        <span class="hljs-keyword">return</span> ERROR;<br>   *e = Q-&gt;data[Q-&gt;front];<span class="hljs-comment">//将队头元素赋值给e</span><br>    Q-&gt;front = (Q-&gt;front +<span class="hljs-number">1</span>)%MAXSIZE;<span class="hljs-comment">//front指针向后移一位，若到最后则转到数组头部</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="队列存储结构及实现"><a href="#队列存储结构及实现" class="headerlink" title="队列存储结构及实现"></a>队列存储结构及实现</h2><p><strong>队列的链式存储结构，其实就是现象表的单链表，只不过它只能尾进头出而已，我们简称为链队列</strong>。为了操作上的方便，我们将队头指针指向链队列的头结点，而队尾指针指向终端结点。空队列时，front和rear都指向头节点。链队列的结构为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> QElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span>//结点结构</span><br><span class="hljs-class">&#123;</span><br>    QElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;QNode, *QueuePtr;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>//队列的链表结构</span><br><span class="hljs-class">&#123;</span><br>QueuePtr front, rear;<span class="hljs-comment">//队头、队尾指针</span><br>&#125;LinkQueue;<br></code></pre></td></tr></table></figure><h3 id="队列的链式存储结构-入队操作"><a href="#队列的链式存储结构-入队操作" class="headerlink" title="队列的链式存储结构-入队操作"></a>队列的链式存储结构-入队操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//插入元素e为Q的新的队尾元素</span><br>Status <span class="hljs-title function_">EnQueue</span><span class="hljs-params">(LinkQueue *Q, QElemType e)</span><br>&#123;<br>QueuePtr s = (QueuePtr)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(QNode));<br>    <span class="hljs-keyword">if</span>(!s)<span class="hljs-comment">//存储分配失败</span><br>        <span class="hljs-built_in">exit</span>(OVERFLOW);<br>    s-&gt;data = e;<br>    s-&gt;next = <span class="hljs-literal">NULL</span>;<br>    Q-&gt;rear-&gt;next = s;<span class="hljs-comment">//把拥有元素e的新节点s赋值给原队尾结点的后继</span><br>    Q-&gt;rear = s;<span class="hljs-comment">//把当前的s设置为队尾结点，rear指向s</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="队列的链式存储结构-出队操作"><a href="#队列的链式存储结构-出队操作" class="headerlink" title="队列的链式存储结构-出队操作"></a>队列的链式存储结构-出队操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">DeQueue</span><span class="hljs-params">(LinkQueue *Q, QElemType *e)</span><br>&#123;<br>QueuePtr p;<br>    <span class="hljs-keyword">if</span>(Q-&gt;front == Q-&gt;rear)<br>        <span class="hljs-keyword">return</span> ERROR;<br>    p = Q-&gt;front-&gt;next;<br>    *e = p-&gt;data;<br>    Q-&gt;front-&gt;next = p-&gt;next;<br>    <span class="hljs-keyword">if</span>(Q-&gt;rear == p)<br>        Q-&gt;rear = Q-&gt;front;<br>    <span class="hljs-built_in">free</span>(p);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><p><strong>串（string）是由零个或多个字符组成的有限序列，又名字符串</strong></p><p>，一般记为s &#x3D;”a1a2a3…an”（n&gt;&#x3D;0），s是字符串的名称，用双引号。n称为串的长度，是一个有限的值。零个字符的串称为空串（null string），长度为0，可以直接用两双引号表示“ ”“ ”。也可以使用希腊字符“fai”（打不出来）。所谓的序列，说明串的相邻字符之间具有前驱和后继的关系。</p><h2 id="串的比较"><a href="#串的比较" class="headerlink" title="串的比较"></a>串的比较</h2><p>串要如何比较呢？它们在计算机中的大小，其实取决于它们挨个字母的前后顺序。比如”silly“和”stupid“，它们第一个字母都是”s”，它们认为不存在大小初一，而第二个字母”i“比”t“更要靠前，所以“i”&lt;”t”，于是“silly”&lt;“stupid”<Br>事实上，串的比较是通过组成串的字符之间的编码来进行的，而字符的编码指的是字符在对应字符集中的序号。计算机中常用字符是使用标志的ASCII编码，更准确一点，由7位二进制数表示一个字符，总共可以表示128个字符。后来发现一些特殊字符的传销，128个不够了，于是扩展ASCII码由8位二进制数表示一个字符，总共可以表示256个字符，这已经足够满足以英语为主的语言和特殊符号进行输入、存储、输出等操作。可是单我们国家就有除汉族的满、回、藏等多个少数民族文字，换做全世界估计要有成百上千种语言与文字。所以后来就有了Unicode编码，比较常用的是由16位的二进制数表示一个字符，约65万个字符，当然为了和ASCII码兼容，Unicode的前256个字符与ASCII码完全相同。</p><h2 id="串的抽象数据类型"><a href="#串的抽象数据类型" class="headerlink" title="串的抽象数据类型"></a>串的抽象数据类型</h2><p>串的逻辑结构和线性表很相似，但串针对的是字符集，也就是串中的元素都是字符，因此对于串的基本操作与线性表是有很大差异的，线性表中关注的是单个元素的操作，比如查找一个元素、插入或删除一个元素，但串中更多的是查找子串的位置、得到指定位置的子串、替换子串等操作</p><p><img src="https://img1.imgtp.com/2023/08/11/MRbBamip.png" alt="串的抽象数据类型"></p><p>我们先来看一个操作index的实现算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//t为非空串。若主串s中第pos个字符之后存在与t相等的子串，则返回第一个这样的子串在s中的位置，否则返回0</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Index</span><span class="hljs-params">(String s, String t, <span class="hljs-type">int</span> pos)</span><br>&#123;<br><span class="hljs-type">int</span> n, m, j;<br>    <span class="hljs-keyword">if</span>(pos &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>n = StrLength(s);<span class="hljs-comment">//得到主串s的长度</span><br>        m = StrLength(t);<span class="hljs-comment">//得到子串t的长度</span><br>        i = pos;<br>        <span class="hljs-keyword">while</span>(i &lt;= n-m+<span class="hljs-number">1</span>)<br>        &#123;<br>            SubString(sub, s, i, m);<span class="hljs-comment">//取主串第i个位置，长度与t相等子串给sub</span><br>            <span class="hljs-keyword">if</span>(StrCompare(sub, t) != <span class="hljs-number">0</span>)<span class="hljs-comment">//如果两串不相等</span><br>                ++i;<br>            <span class="hljs-keyword">else</span> <span class="hljs-comment">//如果两串相等</span><br>                <span class="hljs-keyword">return</span> i;<span class="hljs-comment">//放回i值</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//若无子串与t相等，返回0</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h2><h3 id="串的顺序存储结构"><a href="#串的顺序存储结构" class="headerlink" title="串的顺序存储结构"></a>串的顺序存储结构</h3><p>串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列。一般用定长数组来定义。</p><h3 id="串的链式存储结构"><a href="#串的链式存储结构" class="headerlink" title="串的链式存储结构"></a>串的链式存储结构</h3><p>串的链式存储结构，与线性表是相似的，但由于串结构的特殊性，结构中的每个元素数据是一个字符，如果也简单的应用链表存储串值，一个结点对应一个字符，就会造成很大的空间浪费。因此，一个结点也可以考虑存放多个字符，最后一个结点若是未被占满，可以用“#”或其他非串值字符补全。</p><h2 id="朴素的模式匹配算法"><a href="#朴素的模式匹配算法" class="headerlink" title="朴素的模式匹配算法"></a>朴素的模式匹配算法</h2><p><strong>子串的定位操作通常称为串的模式匹配</strong>，应该算是串中最重要的操作之一。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0</span><br><span class="hljs-comment">//T非空，1&lt;= pos &lt;= StrLength(S)</span><br><span class="hljs-comment">//假设长度存在[0]中</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Index</span><span class="hljs-params">(String S, String T, <span class="hljs-type">int</span> pos)</span><br>&#123;<br><span class="hljs-type">int</span> i = pos;<span class="hljs-comment">//i用于主串s中当前位置下标，若pos不为1泽聪pos位置开始匹配</span><br>    <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<span class="hljs-comment">//j用于子串t中当前位置下标值</span><br>    <span class="hljs-keyword">while</span>(i &lt;= S[<span class="hljs-number">0</span>] &amp;&amp; j &lt;= T[<span class="hljs-number">0</span>])<span class="hljs-comment">//若i小于s长度且j小于t的长度时循环</span><br>    &#123;<br><span class="hljs-keyword">if</span>(S[i] == T[j])<span class="hljs-comment">//若两字符相等则继续</span><br>        &#123;<br>++i;<br>            ++j;<br>        &#125;<br>        <span class="hljs-keyword">else</span><span class="hljs-comment">//指针后退重新开始匹配</span><br>        &#123;<br>i = i-j+<span class="hljs-number">2</span>;<span class="hljs-comment">//返回上次匹配首位的下一位</span><br>            j = <span class="hljs-number">1</span>;<span class="hljs-comment">//j退回到子串t的首位</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(j &gt; T[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">return</span> i-T[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">else</span> <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="KMP模式匹配算法"><a href="#KMP模式匹配算法" class="headerlink" title="KMP模式匹配算法"></a>KMP模式匹配算法</h2><p>朴素模式匹配算法很低效，于是就有三位前辈发表了一个模式匹配算法我们称之为克努特-莫里斯-普拉特算法，简称KMP算法。如果有人搜索到我的博客，想学习KMP算法，还是建议看视频教学，或搭配着看，这部分图片或视频更容易理解，光看文字可能没什么概念。同时KMP算法的next数组实现方法不止一种。</p><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>定义一个next数组，记录子串各个部分的最长公共前后缀长度，再利用next数组，在进行主串与子串之间的挨个比对时，当出现不等元素时，跳过已经遍历过的公共部分，比如s&#x3D;”ababcxxxx” t&#x3D;”ababd” next&#x3D;”00120”。当对比到最后一位元素时，出现了不同，此时对于前面遍历过的abab，最长公共前后缀长度是2，也就是ab。我们可以跳过2个元素，因为后缀元素与前缀元素是相同的。</p><h3 id="KMP算法C语言实现"><a href="#KMP算法C语言实现" class="headerlink" title="KMP算法C语言实现"></a>KMP算法C语言实现</h3><p>我们前面说了，在对比s和t中的元素时，若出现不等于的情况，可以直接跳过最长公共前后缀个元素，接着比较。s&#x3D;“ababbaa” t&#x3D;“ababc”。我们对比到第5个元素时，发现不相同，我们就看next数组的第4（就是5-1）个元素，它的值是2，说明前面这些元素最长公共前后缀是2，也就是说，我们可以跳过t的前2个元素，直接从t的第3个元素对比。具体代码实现为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">indexKMP</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> t)</span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">//主串s的元素</span><br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<span class="hljs-comment">//子串t的元素</span><br><span class="hljs-type">int</span> next[<span class="hljs-number">100</span>];<br>getNext(t, next);<br><span class="hljs-keyword">while</span>( i &lt; <span class="hljs-built_in">strlen</span>(s) &amp;&amp; j &lt; <span class="hljs-built_in">strlen</span>(t))&#123;<span class="hljs-comment">//当未达到主串或子串的末尾时，继续</span><br><span class="hljs-keyword">if</span>( s[i] == t[j])&#123;<span class="hljs-comment">//元素相等，主串指针和子串指针同时后移</span><br>i++;<br>j++;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//如果j等于0，则子串无法再回溯，说明主串的对应元素不是遍历过的子串中的一部分，下一个</span><br>i++;<span class="hljs-comment">//主串指针后移</span><br>&#125;<br><span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果不相等且j != 0 ，则需要对子串指针进行回溯</span><br>j = next[j<span class="hljs-number">-1</span>];<span class="hljs-comment">//回溯并跳过公共前后缀</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>( j == <span class="hljs-built_in">strlen</span>(t))<span class="hljs-comment">//子串被遍历完，说明子串存在于主串</span><br><span class="hljs-keyword">return</span> i - j;<br><span class="hljs-keyword">else</span> <br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="创建next数组"><a href="#创建next数组" class="headerlink" title="创建next数组"></a>创建next数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">getNext</span><span class="hljs-params">(<span class="hljs-built_in">string</span> t, <span class="hljs-type">int</span>* next)</span>&#123;<br><span class="hljs-type">int</span> f = <span class="hljs-number">0</span>;<span class="hljs-comment">//前缀末尾元素 和 最长公共前后缀长度</span><br><span class="hljs-type">int</span> b = <span class="hljs-number">1</span>;<span class="hljs-comment">//后缀末尾元素</span><br>next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>( b &lt; <span class="hljs-built_in">strlen</span>(t))&#123;<br><span class="hljs-keyword">if</span>(t[f] == t[b])&#123;<span class="hljs-comment">//相等</span><br>f++;<span class="hljs-comment">//前缀指针后移，同时也表示最长公共前后缀长度+1</span><br>next[b] = f;<span class="hljs-comment">//记录b位置的最长公共前后缀长度</span><br>b++;<span class="hljs-comment">//后缀指针后移</span><br>&#125;<br><span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//不相等</span><br><span class="hljs-keyword">if</span>( f == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//如果前缀指针指向0/当前最长公共前后缀长度为0 且t[f] != t[b]</span><br>next[b] = <span class="hljs-number">0</span>;<span class="hljs-comment">//b位置的最长公共前后缀长度为0</span><br>b++;<span class="hljs-comment">//后缀指针后移</span><br>&#125;<br><span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果f不为0且前后缀不等</span><br>f = next[f<span class="hljs-number">-1</span>];<span class="hljs-comment">//前缀指针回溯，并跳过公共部分</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><p>之前我们一直在谈论一对一的关系，而树则是一种一对多的关系，<br>树（Tree）是n（n&gt;&#x3D;0）个结点的有限集。n&#x3D;0时称为空树。在任意一颗非空树中：有且只有一个特定的称为根（root）的结点；当n&gt;1时，其余结点可分为m（m&gt;0）个互不相交的有限集T1、T2…Tm，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）</p><p><img src="https://img1.imgtp.com/2023/08/27/l1q4S7sj.png" alt="树"></p><p>树的定义骑士就是我们在讲解栈时提到的递归的方法，也就是在数之中还用到了树的概念，这是一种比较新的定义方法。下图的子树T1和子树T2就是根结点A的子树。当然D、G、H、I组成的树又是B为结点的子树，E、J组成的树是C为结点的子树。</p><p><img src="https://img1.imgtp.com/2023/08/27/mycb8Ut5.png" alt="子树"></p><p>定于树的定义还需强调两点：</p><ol><li>n&gt;0时根节点是唯一的，不可能存在多个根节点</li><li>m&gt;0时，子树的个数没有限制，但它们一定是互不相交的。</li></ol><h3 id="结点分类"><a href="#结点分类" class="headerlink" title="结点分类"></a>结点分类</h3><p>树的结点包含一个数据元素及若干指向其子树的分支。<strong>结点拥有的子树数称为结点的度（Degree）</strong>。<strong>度为0的结点称为叶节点（leaf）或终端结点；度不为0的结点称为非终端结点或分支结点。</strong>除根结点之外，分支结点也称内部结点。<strong>树的度是树内各结点的度的最大值。</strong></p><p><img src="https://img1.imgtp.com/2023/08/27/8YCk4cZE.png" alt="结点分类"></p><h3 id="结点间关系"><a href="#结点间关系" class="headerlink" title="结点间关系"></a>结点间关系</h3><p><strong>结点的子树的根称为该结点的孩子（child），相应的，该结点称为孩子的双亲（parent），</strong>同一个双亲的孩子之间互称兄弟（sibling）（这个词本身是可以泛指兄弟姐妹）。结点的祖先是从根到该结点所经分支上的所有结点。所以对于H来说，DBA都是它的祖先。以<strong>某结点为根的子树中的任一结点都称为该结点的子孙。</strong></p><h3 id="树的其他相关概念"><a href="#树的其他相关概念" class="headerlink" title="树的其他相关概念"></a>树的其他相关概念</h3><p><strong>结点的层次（level）</strong>从根开始定义起，根为第一层，根的孩子为第二层。若某结点在第i层，则其子树的根就在第i+1层。其双亲在同一层的结点互为堂兄弟。<strong>树中结点的最大层次称为树的深度（depth）或高度</strong>，当前树的深度为4。</p><p><img src="https://img1.imgtp.com/2023/08/28/BOVjwWsu.png" alt="结点的层次"></p><p><strong>如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。</strong><br><strong>森林（forest）是m（m&gt;&#x3D;0）棵互不相交的树的集合。</strong>对于树中每个结点而言，其子树的集合即为森林。<br>线性表与树结构对比：</p><table><thead><tr><th>线性结构</th><th>树结构</th></tr></thead><tbody><tr><td>第一个元素：无前驱</td><td>根结点：无双亲，唯一</td></tr><tr><td>最后一个元素：无后继</td><td>叶结点：无孩子，可以多个</td></tr><tr><td>中间元素：一个前驱一个后继</td><td>中间结点：一个双亲多个孩子</td></tr></tbody></table><h2 id="树的抽象数据类型"><a href="#树的抽象数据类型" class="headerlink" title="树的抽象数据类型"></a>树的抽象数据类型</h2><p><img src="https://img1.imgtp.com/2023/08/28/ELroyX3l.png" alt="树的抽象数据类型"></p><h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><p>说到存储结构，就会想到我们前面讲过的顺序存储结构和链式存储结构两种结构。对于树的存储结构的表示，我们要介绍三种不同的表示法：双亲表示法、孩子表示法、孩子兄弟表示法。</p><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><p>无论是谁都不可能是从石头里蹦出来的，所以一定会有父母。树里除了根节点外，其余每个结点，它不一定有孩子，但一定有且仅有一个双亲。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SIZE 100</span><br>typeof <span class="hljs-type">int</span> TElemType;<span class="hljs-comment">// 数结点的数据类型</span><br>typeof <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PTnode</span>// 结点结构</span><br><span class="hljs-class">&#123;</span><br>  TElemType data;<span class="hljs-comment">//结点数据</span><br>  <span class="hljs-type">int</span> parent;<span class="hljs-comment">//双亲位置</span><br>&#125;PTnode<br>typeof <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  PTnode nodes[MAX_SIZE];<span class="hljs-comment">//结点数组</span><br>  <span class="hljs-type">int</span> r,n;<span class="hljs-comment">//根的位置和结点数</span><br>&#125; PTree;<br></code></pre></td></tr></table></figure><p>这样就可以通过双亲来表示结点了，由于根节点没有双亲，所以它双亲位置下标为<code>-1</code></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
      <tag>学习笔记</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C/C++ EasyX图形库</title>
    <link href="/2023/05/17/C-C++%20EasyX%E5%9B%BE%E5%BD%A2%E5%BA%93/"/>
    <url>/2023/05/17/C-C++%20EasyX%E5%9B%BE%E5%BD%A2%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p class="note note-success"><a href="https://docs.easyx.cn/zh-cn/intro"><b>-->官方文档<--</b></a></p><h1 id="EsayX头文件"><a href="#EsayX头文件" class="headerlink" title="EsayX头文件"></a>EsayX头文件</h1><p>头文件有两个</p><ul><li><p><strong>graphics.h</strong>:包含了已经被淘汰的函数</p></li><li><p><strong>easyx.h</strong>：只有最新的函数</p></li></ul><h1 id="窗口的创建与关闭"><a href="#窗口的创建与关闭" class="headerlink" title="窗口的创建与关闭"></a>窗口的创建与关闭</h1><ul><li><strong>initgraph(int x ,int y ,int style)</strong>:x,y为窗口大小，style为是否显示控制台</li><li><strong>closegraph()</strong>:关闭窗口</li></ul><h1 id="设置窗口属性"><a href="#设置窗口属性" class="headerlink" title="设置窗口属性"></a>设置窗口属性</h1><ul><li>**setbkcolor(颜色)**：设置窗口颜色<ul><li>颜色宏：颜色英文大写，可在easyx.h文件中支持的颜色</li><li>RGB</li></ul></li></ul><h1 id="基本绘图函数"><a href="#基本绘图函数" class="headerlink" title="基本绘图函数"></a>基本绘图函数</h1><ul><li><p>**line(int x,int y.int xx .int yy)**：两点确定一条直线</p></li><li><p><strong>circle(int x ,int y ,int r)</strong>:使用圆心和半径画圆</p><ul><li>fillcircle(int x,int y ,int r):填充圆(带边界线)</li><li>solidcircle(int x,int y,int r):填充圆(不带边界线)</li></ul></li><li><p>**rectangle(int x ,int y ,int xx ,int yy)**：使用左上角坐标，右下角坐标画矩形</p><ul><li>fillrectangle(int x,int y,int xx,int yy):填充矩形(带边界线)</li><li>solidrectangle(int x,int y,int r):填充矩形(不带边界线)</li></ul></li><li><p><strong>setfillcolor(颜色)</strong>:设置填充颜色</p></li><li><p><strong>cleardevice()</strong>:刷新</p></li></ul><h1 id="贴图"><a href="#贴图" class="headerlink" title="贴图"></a>贴图</h1><p>定义IMAGE变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">IMAGE img;<span class="hljs-comment">//用IMAGE变量表示图片</span><br></code></pre></td></tr></table></figure><p>加载图像</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">loadimage(IMAGE *img,URL);<span class="hljs-comment">//原始大小</span><br>loadimage(IMAGE *img,URL,<span class="hljs-type">int</span> width,<span class="hljs-type">int</span> height);<span class="hljs-comment">//修改大小</span><br></code></pre></td></tr></table></figure><p>显示图像</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">putimage(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,IMAGE* img);<br></code></pre></td></tr></table></figure><ul><li><p>原样贴图:按照上面步骤进行</p></li><li><p>透明贴图</p><ol><li><p>使用位与运算显示<strong>二进制掩码图</strong></p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">putimage(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,IMAGE* img,SRCAND);<br></code></pre></td></tr></table></figure></li><li><p>使用位异或运算显示<strong>背景图</strong></p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">putimage(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,IMAGE* img,SRCPAINT);<br></code></pre></td></tr></table></figure></li></ol></li><li><p>png贴图</p><p>  直接载入的话透明部分会显示为黑色，可通过算法解决。（自行寻找）</p></li></ul><h2 id="透明贴图素材制作与原理"><a href="#透明贴图素材制作与原理" class="headerlink" title="透明贴图素材制作与原理"></a>透明贴图素材制作与原理</h2><p><strong>二进制掩码图</strong>：</p><p>将需要设置成透明的部分填充成白色，要保留的部分填充成黑色，用1表示白色，0表示黑色，故称为二进制掩码图</p><p><strong>背景图</strong>：</p><p>将需要设置成透明的部分填充成黑色，要保留的地方不变</p><p><strong>原理(个人理解)</strong>:</p><p><pclass="note note-warning">以下内容仅为个人理解，没有任何依据，仅供方便理解记忆</p></p><p>以下内容仅为个人理解，没有依据，仅供方便理解参考</p><p>我们可以用<strong>setcolor()<strong>设置</strong>窗口背景颜色</strong>，或是使用<strong>putimage()<strong>设置一张图片作为</strong>窗口背景图</strong>，用二进制表示每个位的颜色，0为黑，其余统一为1。<br></p><p>接着使用**SRCAND()**将二进制掩码图和窗口背景图进行位与运算，由于掩码图将需要保留的部分填充为黑色，将需要透明的部分填充为白色，与运算后，会得到一张需要保留的部分为黑色，需要成透明的部分为窗口背景图的图，称为a<br></p><p>最后使用SRCPAINT(),将背景图与a进行位异或运算，由于背景图要保留的部分是不为黑的1，透明部分为黑0，与b运算后，会得到一张</p><p>所需要的透明图了。</p><p><img src="/img/easyX/%E9%80%8F%E6%98%8E%E5%8E%9F%E7%90%86.jpg" alt="图示"></p><h1 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h1><p><strong>阻塞式交互</strong></p><p>不交互就无法继续进行</p><p><strong>非阻塞式交互</strong></p><p>不交互仍然会进行</p><h2 id="定时器和双缓冲绘图"><a href="#定时器和双缓冲绘图" class="headerlink" title="定时器和双缓冲绘图"></a>定时器和双缓冲绘图</h2><p><strong>定时器</strong></p><p>sleep()是一个全局阻塞，可以使用定时器进行单个对象的刷新</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span><span class="hljs-comment">//头文件</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Timer</span><span class="hljs-params">(<span class="hljs-type">int</span> id,<span class="hljs-type">int</span> duration)</span><span class="hljs-comment">//输入时间间隔和计时器id</span><br>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> startTime[<span class="hljs-number">10</span>];<span class="hljs-comment">//静态变量默认初始化为0</span><br>    <span class="hljs-type">int</span> endTime = clock();<span class="hljs-comment">//clock函数，获取程序开始运行目前位置的时间</span><br>    <span class="hljs-keyword">if</span>(endTime - startTime[id] &gt;= duration)<br>    &#123;<br>        startTime[id] = endTime;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>双缓冲绘图</strong></p><p>双缓冲绘图是指，在屏幕看不见的地方，先将图形绘制出来，然后再移动到指定位置，可以避免频闪问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;graphics.h&gt;</span></span><br>BeginBatchDraw();<span class="hljs-comment">//开启双缓冲绘图</span><br>FlushBatchDraw();<span class="hljs-comment">//显示每一帧，不开的话图形会不显示</span><br>EndBatchDraw();<span class="hljs-comment">//关闭双缓冲绘图</span><br></code></pre></td></tr></table></figure><h2 id="键盘交互"><a href="#键盘交互" class="headerlink" title="键盘交互"></a>键盘交互</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;conio.h&gt;</span></span><br><span class="hljs-built_in">getch</span>();<span class="hljs-comment">//getch()不需要回车确认，可配合switch和if语句进行键盘输入和操作,但会造成阻塞</span><br><br><span class="hljs-built_in">kbhit</span>()<span class="hljs-comment">//检查当前是否有键盘输入，有则返回一个非0值，否则返回0，而且按下键盘后必须有getch一类将输入接收掉，不然会一直有返回值。</span><br><br>异步处理<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;graphics.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">keyDown</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">GetAsyncKeyState</span>(vkey))<span class="hljs-comment">//vkey为虚拟键码</span><br>&#125;<br><span class="hljs-comment">//使用异步处理，运动会更快速更流畅，速度可以配合定时器控制。</span><br><br></code></pre></td></tr></table></figure><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/inputdev/virtual-key-codes">虚拟键码 (Winuser.h) - Win32 apps | Microsoft Learn</a></p><h2 id="鼠标交互"><a href="#鼠标交互" class="headerlink" title="鼠标交互"></a>鼠标交互</h2>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java-面向对象</title>
    <link href="/2023/05/16/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/05/16/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象的概念"><a href="#面向对象的概念" class="headerlink" title="面向对象的概念"></a>面向对象的概念</h1><p>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一一实现，使用的时候依次调用。面向对象则是把构成问题的事务按照一定规则划分为多个独立对象，然后通过调用对象的方法来解决问题，通过多个对象配合来解决问题，这样当程序功能需要改动时，只需要修改个别的对象就可以了，从而更容易维护。</p><h2 id="面向对象的特点"><a href="#面向对象的特点" class="headerlink" title="面向对象的特点"></a>面向对象的特点</h2><p>主要可以概括为：<strong>封装性</strong>、<strong>继承性</strong>、<strong>多态性</strong></p><ul><li><strong>封装性</strong>：封装是面向对象的核心思想，将对象的属性和行为封装起来，不需要让外界知道具体实现环节，这就是封装思想。例如：用户使用计算机只需要手指敲键盘就行了，不需要了解计算机的工作原理，就算知道，在使用时也并不依赖这些原理。</li><li><strong>继承性</strong>：继承性主要描述的时类与类之间的关系，通过继承，可以在无需重新编写原有类的情况下，对原有类的功能进行扩展。例如有个汽车的类，描述了汽车的普遍特征和功能，而轿车的类中不仅要包含汽车的特征和功能，还应该添加轿车特有的功能。这时可以让轿车类继承汽车类，然后单独添加轿车特征。继承不仅增强了代码的复用性，提高了开发效率，还为程序的维护提供了便捷。</li><li><strong>多态性</strong>：多态性指的是在程序中允许出现重名的情况，它指在一个类中定义的属性和方法被其他类继承后，它们可以具有不同的数据类型或表现出不同的行为，这使得同一个属性和方法在不同的类中有不同的含义。</li></ul><h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><p>类是对某一类事物的抽象描述，而对象用于表示现实中该类事物的个体。比如玩具模型可以看成一个类，将一个个玩具看成对象。<br></p><p>类用于描述多个对象的共同特征，它是对象的模板。对象用于描述现实中的个体，它是类的实例。</p><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>要在程序中创建对象，首先需要定义一个类，类是对象的抽象，用于描述一组对象的共同特征和行为。类中可以定义成员变量和成员方法，其中成员变量用于描述对象的特征，也被称为属性；成员方法用于描述对象的行为，可简称为方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义Person类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-type">int</span> age; <span class="hljs-comment">//定义int类型的成员变量age</span><br>    <br>    <span class="hljs-comment">//定义speak()方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">speak</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;大家好，我今年&quot;</span> + age + <span class="hljs-string">&quot;岁&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-success"> 在Java中，定义在类中的变量被称为成员变量，定义在方法中的变量称为局部变量，如果在某个方法中定义的局部变量与成员变量同名，是允许的，此时方法中通过变量访问到的是局部变量，而非成员变量</p><h2 id="对象的创建与使用"><a href="#对象的创建与使用" class="headerlink" title="对象的创建与使用"></a>对象的创建与使用</h2><p>在程序中，可以使用new关键字创造对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">类名 对象名称 = <span class="hljs-keyword">new</span> 类名();<br><br><span class="hljs-comment">//创建Person类的实例对象</span><br><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br></code></pre></td></tr></table></figure><p>在上述代码中，“new Person()”用于创建Person类的一个实例对象，”Person p”则是定义了一个Person类型的变量p。中间的等于号将Person对象在内存中的地址赋值给变量p，这样p就持有了对象的引用。<br></p><p>在创建对象后，可以通过对象的引用来访问对象的所有成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">对象引用.对象成员<br>    <br><span class="hljs-comment">//访问Person p中的age成员和speak()方法</span><br><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>p.age = <span class="hljs-number">10</span>;<br>p.speak();<br></code></pre></td></tr></table></figure><p>运行的结果为”我的年龄是10岁”<br></p><p>在实例化对象时，针对成员变量的类型的不同，java虚拟机将会赋予不同的初值。</p><table border="1"><tbody><tr><td>成员变量类型</td><td>初始值</td></tr><tr><td>byte</td><td>0</td></tr><tr><td>short</td><td>0</td></tr><tr><td>int</td><td>0</td></tr><tr><td>long</td><td>0L</td></tr><tr><td>float</td><td>0.0F</td></tr><tr><td>double</td><td>0.0D</td></tr><tr><td>char</td><td>空字符'/u0000'</td></tr><tr><td>boolean</td><td>false</td></tr><tr><td>引用数据类型</td><td>null</td></tr></tbody></table><p>当对象被实例化后，在程序中可以通过对象的引用变量来访问该对象的成员。需要注意的是，当没有任何变量引用这个歌对象时，它将成为垃圾对象，不能再被使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是人&quot;</span>)；<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-comment">//创建Person对象</span><br>        p1.say();<br>        p1 = <span class="hljs-literal">null</span>;<br>        p1.say();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class = "note note-info"> 运行结果:<br>我是一个人<br>报错信息</p><p>在将p1赋值null后，p1指向了一个空指针，被p1引用的Person对象就会失去引用，成为垃圾对象</p><h2 id="类的封装"><a href="#类的封装" class="headerlink" title="类的封装"></a>类的封装</h2><p>类的封装是指在定义一个类时，将类中的属性私有化，即使用private关键字来修饰私有属性，使他只能在它所在的类中被访问，如果外界想要访问私有属性，需要提供一些使用public修饰的公有方法，其中包括用于获取属性值的getXxx方法和设置属性值的setXxx方法。</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>在实例化一个对象后，要修改对象的属性必须要通过直接访问对象的属性或setXxx方法的方式才可以。如果要在<strong>实例化的同时也为属性赋值</strong>，则需要通过构造方法。构造方法是类的一个特殊成员，在类实例化时自动调用。</p><h2 id="构造方法的定义"><a href="#构造方法的定义" class="headerlink" title="构造方法的定义"></a>构造方法的定义</h2><p>首先构造方法必须满足三个要求</p><ol><li>方法名与类名相同</li><li>方法名的前面没有返回值类型的声明</li><li>在方法中不能使用return语句返回一个值，但可以单纯些return语句作为方法的结束</li></ol><p><strong>无参</strong>构造方法实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-comment">//构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;无参的构造方法被调用了&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-comment">//实例化对象</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-info">运行结果：<br>无参的构造方法被调用了</p><p>既然有无参的，那必有<strong>有参</strong>的</p><div id="1.0"></div><p><strong>有参</strong>构造方法实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-type">int</span> age;<span class="hljs-comment">//定义age属性</span><br>    <br>  <span class="hljs-comment">//定义有参的构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123;<br>     age = a;   <br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;今年我&quot;</span> + age + <span class="hljs-string">&quot;岁了&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//实例化对象，同时输入参数</span><br>    p1.say();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class="note note-info">运行结果：<br>今年我10岁了</p><h2 id="构造方法的重载"><a href="#构造方法的重载" class="headerlink" title="构造方法的重载"></a>构造方法的重载</h2><p>和普通方法一样，构造方法也可以重载，重载就是允许多个同名方法存在，只要参数个数或参数类型不同即可。</p><blockquote><hr><p>每个类都至少有一种构造方法，若没定义，则系统会自动创建一个默认的构造方法，也就是说，以下两种方式是等效的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//不定义构造方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;&#125;<br><br><span class="hljs-comment">//定义无参无内容的构造方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这也就是为什么，我们未定义任何构造方法却仍可以使用new Person()实例化对象</p><p class="note note-warning">若定义了构造方法，则系统会舍弃默认构造方法，如定义了一个有参的Person(int a)，则在实例化对象时无法使用new Person()，</p><p>所以在定义构造方法时，为了防止出错，最好在手动定义一个默认方法</p><hr></blockquote><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>像我们刚刚定义<a href="#1.0">有参构造方法</a>时，将a赋值给age属性，这样的定义方法会影响程序的可读性，最好是将表示年龄的变量统一为age，可这样会导致局部变量和全局变量冲突，使得方法无法访问全局成员变量age，为了解决，java提供了this关键字指代当前对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//this调用成员</span><br><span class="hljs-built_in">this</span>.age;<br><br><span class="hljs-comment">//this调用方法</span><br><span class="hljs-built_in">this</span>.say();<br><br><span class="hljs-comment">//this调用构造方法</span><br><span class="hljs-built_in">this</span>(参数<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3.</span>..);<br></code></pre></td></tr></table></figure><p class="note note-warning">对于第三顶，需要注意以下几点<ul type=circle>        <li>只能在构造方法中使用this调用其他构造方法，不能再成员方法中使用</li><li>        在构造方法中，使用this调用构造方法的语句必须位于第一行，且只能出现一次</li><li>        不能在一个类的两个构造方法中使用this互相调用</li></ul><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>​在java中，一个对象成为垃圾后仍会占用内存，时间一长导致内存不足。于是java引入了垃圾回收机制，java虚拟机会自动回收垃圾对象所占用得内存。当垃圾堆积到一定程度时就会自动释放，也可以调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.gc();<br></code></pre></td></tr></table></figure><p>方法来通知java虚拟机立即进行垃圾回收。当一个对象在内存中被释放时，它的finalize()方法会被自动调用，因此可以通过定义finalize()方法来观察对象何时被释放。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;对象作为垃圾被回收&quot;</span>);<br>    &#125;<br>    <br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        p1 = <span class="hljs-literal">null</span>;<br>        p2 = <span class="hljs-literal">null</span>;<br>        System.gc();<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p class = "note note-info">运行结果：<br>对象作为垃圾被回收<br>对象作为垃圾被回收</p><h1 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h1><h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><p>在定义一个类时，只是描述某类事物的特征和行为，并不会产生具体的数据，只有在new创建实例对象后，系统才会为每个对象分配空间，存储<strong>各自的数据</strong>。但有时我们希望某个特征被所有对象共享，比如学校中的每个学生都在一个学校内，他们的学校名称地址等属性应是相同的。此时不需要在每个学生的内存空间中都定义学校名称，可以在对象以外的空间定义一个表示学校名称的变量，用于共享。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br><span class="hljs-keyword">static</span> String schoolName;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        Student.schoolName = <span class="hljs-string">&quot;学校名&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>在开发时，有时会希望<strong>不创建对象就调用某个方法</strong>，只需要在定义的方法钱加上static关键字即可。静态方法可以使用<strong>类名.方法名</strong>调用。</p><h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><p>用一对大括号括起来的几行代码被称为代码块，用static修饰的代码块被称为静态代码块。<strong>当类被加载时，静态代码块会被自动执行</strong>，由于<strong>类只加载一次</strong>，因此静态代码块也只执行一次。</p><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在Java中允许在一个类的内部定义类，称为<strong>内部类</strong>，根据内部类的位置、修饰符和定义的方式可分为<strong>成员内部类、静态内部类、匿名内部类、局部内部类。</strong>相对的，内部类所在的类称为<strong>外部类</strong></p><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>成员内部类是普通的内部类，成员内部类可以无限制访问外部类的所有成语和方法（包括private和静态成员），当内部类存在和外部类同名的方法或成员时，默认访问的是内部类中的方法或成员，此时可以用this访问外部类。<br></p><p>虽然<strong>成员内部类可以无限制访问外部类</strong>，但<strong>外部类访问成员内部类的成员就需要先创建一个内部类对象</strong>，再通过这个对象来访问。<br></p><h3 id="创建成员内部类对象"><a href="#创建成员内部类对象" class="headerlink" title="创建成员内部类对象"></a>创建成员内部类对象</h3><p>成员内部类是依靠外部类存在的，所以要创建成员内部类对象要先创建外部类对象，方法有2种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outter</span>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//方法一</span><br><span class="hljs-type">Outter</span> <span class="hljs-variable">outter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outter</span>();<br>Outter.<span class="hljs-type">Intter</span> <span class="hljs-variable">Intter</span> <span class="hljs-operator">=</span> outter.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br><br><span class="hljs-comment">//方法二</span><br>Outer.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outter</span>(). <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br></code></pre></td></tr></table></figure><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>局部内部类和成员内部类类似，但是<strong>是定义在方法或作用域内，且没有访问外部类的权限</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outter</span> &#123;<br>  <span class="hljs-comment">//定义方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//方法中定义局部内部类</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>() &#123;<br>      <br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>静态内部类相当于外部类的一个类属性，<strong>可以脱离外部实例化，直接初始化</strong></p><h3 id="创建静态内部类"><a href="#创建静态内部类" class="headerlink" title="创建静态内部类"></a>创建静态内部类</h3><p>只需要在<strong>成员内部类的前面加<code>public static</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outter</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Outter</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;外部类被创建&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Inner</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;内部类被创建&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">hello</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>    <br>    <span class="hljs-comment">//脱离外部实例化，直接初始化</span><br>        Outter.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outter</span>.Inner();<br>        System.out.println(inner.i);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">内部类被创建<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的概念"><a href="#继承的概念" class="headerlink" title="继承的概念"></a>继承的概念</h2><p>类的继承是指<strong>用现有的类去创建新的类</strong>，子类可以<strong>继承父类的属性和方法</strong>。</p><p>继承通过<strong>extends</strong>关键字声明，格式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SonClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FatherClass</span> &#123;<br>  <span class="hljs-comment">//重载或自定义方法、属性</span><br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>比如dog狗这一类，可以从animal动物类继承，同时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animals</span> &#123;<br>   <span class="hljs-comment">//重载或自定义方法、属性</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在java中只有<strong>单继承，一个类只能有一个父类，但是可以有多个子类</strong></p><h2 id="重写父类方法"><a href="#重写父类方法" class="headerlink" title="重写父类方法"></a>重写父类方法</h2><p>在继承中，子类会自动继承父类的方法，但有时需要对父类的方法进行一些修改，这就需要在子类的对父类的方法进行重写（不是重载，重载在前面）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FatherClass</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;I am father&quot;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SonClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FatherClass</span> &#123;<br>  <span class="hljs-comment">// 对父类同名方法进行重写</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;I am son&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="super关键字访问父类成员"><a href="#super关键字访问父类成员" class="headerlink" title="super关键字访问父类成员"></a>super关键字访问父类成员</h2><p>在重写父类方法后，我们直接调用的就是重写后的方法，如果想调用父类未重写的方法，就需要通过**<code>super</code>关键字**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SonClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FatherClass</span> &#123;<br>  <span class="hljs-comment">// 对父类同名方法进行重写</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;I am son&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 声明新方法通过super调用父类方法或属性</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fSay</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">super</span>.say();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><code>super</code>也可以访问父类的构造函数方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SonClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FatherClass</span> &#123;<br><span class="hljs-comment">// 调用构造函数</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">super</span>([参数]);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在初始化子类的时候，<strong>父类的构造函数会自动调用</strong>，如果父类的构造函数会对成员进行修改，修改后的成员也会被继承到子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FatherClass</span> &#123;<br>  <span class="hljs-comment">// 声明成员变量</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 声明无参构造函数</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">FaherClass</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 修改成员变量</span><br>    a = <span class="hljs-number">10</span>;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SonClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FatherClass</span> &#123;<br>  <span class="hljs-comment">// 声明构造函数</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">SonClass</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 打印继承的成员变量，结果为10</span><br>    System.out.println(a);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：如果在<strong>父类只声明了有参构造函数</strong>，则在子类的继承中，必须<strong>显式的调用父类的构造方法,否则会报错</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SonClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FatherClass</span> &#123;<br>  <span class="hljs-comment">// 子类声明构造函数</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">SonClass</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 显式调用父类的构造函数</span><br>    <span class="hljs-built_in">super</span>([参数]);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><p>final关键字可以用来修饰类、变量和方法</p><ul><li>被修饰的类不能被继承</li><li>被修饰的方法不能被子类重写</li><li>被修饰的变量是常量，只能被赋值一次</li></ul><h1 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h1><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>在定义类的时候一般都需要定义一些方法来描述它的行为特征，比如dog类可以有shout()方法，表示它的叫声，但对于比较广泛的类，比如animal类，dog可以从animal继承到shout方法，但是每个动物的叫声都不同，那么animal类中的shout方法该怎么写呢？</p><p><strong>可以留空交给子类重写。不写方法体的方法就是抽象方法。带有抽象方法的类就是抽象类。抽象类必须用abstract关键字修饰，用abstract关键字修饰的抽象类不一定含有抽象方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明抽象类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FatherClass</span> &#123;<br>  <span class="hljs-comment">// 声明抽象方法</span><br>  <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SonClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FatherClass</span> &#123;<br>  <span class="hljs-comment">// 对抽象方法重写</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 方法体内容</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在使用的时候需要注意以下几点：</p><ul><li><strong>方法体为空不等于抽象方法</strong>：比如<code>void f()&#123;&#125;</code>并不是一个抽象方法，不可以用<code>abstract</code>修饰。抽象方法是<strong>没有方法体，而不是方法体为空</strong></li><li><strong>抽象方法一定要被重写</strong>：在子类继承之后，抽象方法一定要进行重写，*<em>否则会报错</em></li><li><strong>抽象类不能被实例化</strong>：如果进行编译，会提示“xx是抽象的; 无法实例化”</li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是由常量和抽象方法组成的特殊类，是对抽象类的进一步抽象。定义接口用**<code>interface</code>**关键字修饰，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">[<span class="hljs-keyword">public</span>] interface 接口名 [extends 接口<span class="hljs-number">1</span>，接口<span class="hljs-number">2.</span>..] &#123;<br>  [<span class="hljs-keyword">public</span>] [<span class="hljs-keyword">static</span>] [<span class="hljs-keyword">final</span>] 数据类型 常量名 = 常量值;<br>  [<span class="hljs-keyword">public</span>] [<span class="hljs-keyword">abstract</span>] 返回值 抽象方法名([参数列表]);<br>&#125;<br></code></pre></td></tr></table></figure><p>接口克服了类单继承的缺点，<strong>一个接口可以通过<code>extends</code>继承多个父接口</strong>，<strong>一个类可以实现多个接口</strong>（类重写接口的抽象方法称为实现，可以理解成不同类型间的继承）。接口中定义的方法默认是**<code>public abstract</code><strong>，</strong>如果接口为<code>public</code>则接口中的变量和方法全部为public**。</p><p>由于接口里只有抽象方法，无法进行实例化，需要通过类似<code>extends</code>继承的方法去调用并重写抽象方法，这需要用到关键字**<code>implements</code>**（实现）。格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[&lt;修饰符&gt;] class &lt;类名&gt; [extends &lt;父类名&gt;] [implements] &lt;接口<span class="hljs-number">1</span>&gt;,&lt;接口<span class="hljs-number">2</span>&gt;...]<br></code></pre></td></tr></table></figure><p>和抽象类一样，子类需要对父类进行重写，但是不同的是，<strong>如果实现接口的是一个抽象类，则可以只实现部分接口</strong></p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="多态的概念"><a href="#多态的概念" class="headerlink" title="多态的概念"></a>多态的概念</h2><p><strong>多态也就是一个对象拥有多种形态</strong>，具体指的为<strong>编译时和运行时的状态不同</strong>。代码中体现为父类做类型，子类做实现（父类引用指向子类），代码格式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">父类名称 对象名 = <span class="hljs-keyword">new</span> 子类名称();<br>接口名称 对象名 = <span class="hljs-keyword">new</span> 实现类名称();<br></code></pre></td></tr></table></figure><p>举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义父类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fa</span> &#123;<br>  <span class="hljs-comment">// 定义成员变量</span><br>  <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Fa&quot;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 子类继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fa</span> &#123;<br>  <span class="hljs-comment">// 定义同名成员变量</span><br>  <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;345&quot;</span>;<br>  <span class="hljs-comment">// 方法重写</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Son&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 定义子类特有的方法</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say2</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;s2&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;    <br>    <span class="hljs-comment">// 多态</span><br><span class="hljs-type">Fa</span> <span class="hljs-variable">son</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>(); <br>    <br>    <span class="hljs-comment">// 编译时看父类，运行时看子类,调用的是子类的say方法</span><br>    son.say();<br>    <span class="hljs-comment">// 编译时看父类，父类没有say2方法，编译不通过</span><br>    son.say2();<br>    <span class="hljs-comment">// 编译时看父类，son.a调用的是父类的成员变量</span><br>    System.out.println(son.a)<br>    <br>    <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对比之下，多态的写法更加统一。</p><p>那么多态中会执行哪个类中的方法呢？答案是子类的中的方法，<strong>new的是哪个类，使用的就是谁的成员方法</strong>，如果没有，就会到父类找。而如果是访问成员变量，则是相反，<strong>用的是父类的成员变量</strong>，总结就是<strong>编译看（等号）左边，运行看右边</strong></p><h2 id="多态应用"><a href="#多态应用" class="headerlink" title="多态应用"></a>多态应用</h2><p>有时，我们可能会有多个子类，比如Animal，可以有Cat、Dog等子类，假设现在我需要写一个方法，要求<strong>输入Animal类的对象，自动使用其中的方法</strong>，如果java没有多态性，那么你需要给每一种子类单独写一个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 为子类声明方法</span><br><span class="hljs-keyword">public</span> staic <span class="hljs-keyword">void</span>  <span class="hljs-title function_">useAnimal</span><span class="hljs-params">(Dog dog)</span> &#123;<br>  dog.shout();<br>&#125;<br><span class="hljs-keyword">public</span> staitc <span class="hljs-keyword">void</span> <span class="hljs-title function_">useAnimal</span><span class="hljs-params">(Cat cat)</span> &#123;<br>  cat.shout();<br>&#125;<br></code></pre></td></tr></table></figure><p>而由于多态性，现在你可以用父类Animal做形参类型，并支持传入子类类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">useAnimal</span><span class="hljs-params">(Animal an)</span> &#123;<br>  an.shout();<br>&#125;<br><br><span class="hljs-comment">// 实例化子类</span><br><span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br><span class="hljs-type">Cat</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br><span class="hljs-comment">// 调用方法</span><br>useAnimal(dog);<br>useAnimal(cat);<br></code></pre></td></tr></table></figure><p>上面的方法可以把实例化省略，变成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">useAnimal(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>())<br></code></pre></td></tr></table></figure><p>而由于我们形参是Animal。所以在userAnimal方法内部，实际上是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Animal</span> <span class="hljs-variable">an</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br></code></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>在上面的代码中，我们将Dog类传递给了Animal类，可以理解为进行了类型转换，这种称为<strong>”向上转型“</strong>，我们在使用<code>useAnimal()</code>方法时，虽然传入了Dog对象，但是并不能使用Dog中特有的方法，只能使用Animal类中的方法，如果想使用，就需要对Animal进行类型转换，变为Dog()子类，这种转换称为<strong>”向下转型“</strong>。方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">useAnimal</span><span class="hljs-params">(Animal an)</span> &#123;<br>  <span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> (Dog) an;<br>  dog.dogShout();<br>&#125;<br></code></pre></td></tr></table></figure><p>其实就是进行强制类型转换</p><p>但是由于有多个子类，我们要怎么判断传入的类是不是Dog呢？就需要使用<strong>instanceof关键字</strong></p><h2 id="instanceof判断类"><a href="#instanceof判断类" class="headerlink" title="instanceof判断类"></a>instanceof判断类</h2><p>可以用来判断对象是否为某个类或接口的实例或子类实例，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">对象(或对象引用变量) <span class="hljs-keyword">instanceof</span> 类(或接口)<br></code></pre></td></tr></table></figure><p>它会返回bool值。</p><h1 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h1><p>Object类是所有类的父类或间接父类，所有对象（包括数组）都实现了这个类的方法。Object类中的常用方法有</p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>equals()</td><td>指示其他某个对象是否与此对象“相等”</td></tr><tr><td>getClass()</td><td>返回此Object的运行时类</td></tr><tr><td>hashCode()</td><td>返回该对象的哈希值</td></tr><tr><td>toString()</td><td>返回该对象的字符串表示</td></tr></tbody></table><p>下面是个演示toString的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fa</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;A&quot;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>    System.out.println(a.toString());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对象a中没有定义toString方法但仍能正常使用，这是因为从Obejct中继承了。</p><p>toString的代码具体如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + Integer.toHexString(hashCode());<br></code></pre></td></tr></table></figure><h1 id="匿名内部类-1"><a href="#匿名内部类-1" class="headerlink" title="匿名内部类"></a>匿名内部类</h1><p>匿名内部类是定义在类的内部，没有名字的内部类，是一种<strong>实现接口的简便方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 定义匿名内部类实现接口并传入</span><br>    Animalshout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Animals</span>() &#123;<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shout</span><span class="hljs-params">()</span> &#123;<br>        System.out.print(<span class="hljs-string">&quot;喵喵&quot;</span>);<br>      &#125;<br>    &#125;);<br>  &#125;<br>  <span class="hljs-comment">// 定义静态方法调用shout</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Animalshout</span><span class="hljs-params">(Animals an)</span> &#123;<br>    an.shout();<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 定义接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animals</span> &#123;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">shout</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>类</tag>
      
      <tag>对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS</title>
    <link href="/2023/04/17/CSS/"/>
    <url>/2023/04/17/CSS/</url>
    
    <content type="html"><![CDATA[<blockquote><hr><p>嗨嗨嗨</p><hr></blockquote><h1 id="CSS定义"><a href="#CSS定义" class="headerlink" title="CSS定义"></a>CSS定义</h1><p>CSS的全名是层叠样式表（Cascading Style Sheets，缩写为CSS），是一种样式表语言，用来描述HTML文档的美化内容，CSS有多种写法（位置不同）<br></p><h1 id="CSS书写顺序"><a href="#CSS书写顺序" class="headerlink" title="CSS书写顺序"></a>CSS书写顺序</h1><ol><li>盒子模型属性</li><li>文字样式</li><li>圆角、阴影等修饰属性</li></ol><h2 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h2><p>将CSS代码写在title下方，用<strong>双style</strong>标签。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>hello world<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-comment">/*选择器&#123;&#125;*/</span></span><br><span class="language-css">    <span class="hljs-selector-tag">p</span> &#123;</span><br><span class="language-css">        <span class="hljs-comment">/*CSS属性:属性值;*/</span></span><br><span class="language-css">        <span class="hljs-attribute">color</span>:red;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    红色文本<br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样后面使用的p文本都会变为红色</p><h2 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h2><p>将CSS代码写在<strong>单独的CSS文件中（.css）</strong>，在HTML使用<strong>link</strong>标签引入</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>外部样式表<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;my.css&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>stylesheet是样式表</p><h2 id="行内样式表"><a href="#行内样式表" class="headerlink" title="行内样式表"></a>行内样式表</h2><p>配合JavaScript使用。CSS写在标签的<strong>style</strong>属性值里</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red; font-size:20px;&quot;</span>&gt;</span><br>    这是div标签<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h1><h2 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h2><ul><li><p><strong>标签选择器</strong>：使用<strong>标签名</strong>作为选择器，选中<strong>同名标签</strong>设置相同的格式，无法差异化设置设置标签的显示效果</p></li><li><p><strong>类选择器</strong>：查找标签，<strong>差异化</strong>设置标签的显示效果</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css">定义类选择器：<br>.类名<br>使用类选择器：<br>标签添加 class=&quot;类名&quot;<br><br>&lt;style&gt;<br><span class="hljs-comment">/*定义*/</span><br><span class="hljs-selector-class">.red</span> &#123;<br><span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-comment">/*使用*/</span><br>&lt;<span class="hljs-selector-tag">p</span> class=&quot;red&quot;&gt;红色字体&lt;/<span class="hljs-selector-tag">p</span>&gt;<br></code></pre></td></tr></table></figure><p>  一个标签只有一个class属性，但是class可以有多个属性值，中间用<strong>空格隔开</strong></p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;red size&quot;</span>&gt;</span><br>    使用了red类和size类，中间用空格隔开<br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>  <strong>类名有多个单词可以用-连接</strong></p></li><li><p><strong>ID选择器</strong>：查找标签，<strong>差异化</strong>设置标签的显示效果<br>id选择器一般配合<strong>JavaScript使用</strong>，很少用来设置CSS样式</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">定义id选择器：<br>#id名<br>使用id选择器：<br>标签添加id=&quot;id名&quot; <br></code></pre></td></tr></table></figure><p>  <strong>同一个id选择器在一个页面中只能用一次</strong></p></li><li><p><strong>通配符选择器</strong>：查找页面<strong>所有标签，设置相同样式</strong></p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html">* &#123;<br>    color:red;<br>&#125;<br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    p标签颜色为红<br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    div标签颜色为红<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><br>    h1标签颜色为红<br><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><p>  通配符选择器一般在网页开发初期使用，用来清除标签的默认样式，比如间距颜色等，需要多少再自己设置</p></li></ul><h2 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h2><p>定义：由<strong>两个</strong>或<strong>多个基础选择器</strong>，通过不同的方式组合而成。<br>作用：<strong>更准确、更高效</strong>的选择目标元素（标签）</p><ul><li><p><strong>后代选择器</strong>：选中某元素的<strong>后代</strong>元素，包含儿子、孙子、重孙子…</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*父选择器 子选择器&#123;CSS属性&#125; ，父子选择器之间用空格隔开*/</span><br>&lt;style&gt; <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">span</span>&#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br>&lt;/style&gt;<br><br>&lt;<span class="hljs-selector-tag">span</span>&gt; 这是<span class="hljs-selector-tag">span</span>标签，黑色的&lt;/<span class="hljs-selector-tag">span</span>&gt;<br>&lt;<span class="hljs-selector-tag">div</span>&gt;<br>&lt;<span class="hljs-selector-tag">span</span>&gt;这是<span class="hljs-selector-tag">div</span>的儿子<span class="hljs-selector-tag">span</span>，红色的&lt;/<span class="hljs-selector-tag">span</span>&gt;<br>&lt;<span class="hljs-selector-tag">p</span>&gt;&lt;<span class="hljs-selector-tag">span</span>&gt;这是<span class="hljs-selector-tag">div</span>的孙子<span class="hljs-selector-tag">span</span>，红色的&lt;/<span class="hljs-selector-tag">span</span>&gt;&lt;/<span class="hljs-selector-tag">p</span>&gt;<br>&lt;/<span class="hljs-selector-tag">div</span>&gt;<br><br></code></pre></td></tr></table></figure></li><li><p><strong>子代选择器</strong>：选中某元素的<strong>子代元素</strong>（<strong>最近的子级</strong>）</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*父选择器 &gt; 子选择器&#123;CSS属性&#125; 父子选择器之间用逗号隔开*/</span><br>&lt;style&gt;<br><span class="hljs-selector-tag">div</span> &gt; <span class="hljs-selector-tag">span</span>&#123;<br><span class="hljs-attribute">color</span>: red;<br>&#125;<br>&lt;/style&gt;<br><br>&lt;<span class="hljs-selector-tag">div</span>&gt;&lt;<span class="hljs-selector-tag">span</span>&gt;这是<span class="hljs-selector-tag">div</span>的儿子<span class="hljs-selector-tag">span</span>，红色的&lt;/<span class="hljs-selector-tag">span</span>&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>&lt;<span class="hljs-selector-tag">div</span>&gt;&lt;<span class="hljs-selector-tag">p</span>&gt;&lt;<span class="hljs-selector-tag">span</span>&gt;这是<span class="hljs-selector-tag">div</span>的孙子<span class="hljs-selector-tag">span</span>，黑色的&lt;/<span class="hljs-selector-tag">span</span>&gt;&lt;/<span class="hljs-selector-tag">p</span>&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;<br></code></pre></td></tr></table></figure></li><li><p><strong>并集选择器</strong>：选中<strong>多组</strong>标签设置<strong>相同</strong>的样式</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*选择器1,选择器2,..,选择器n&#123;CSS属性&#125;  选择器之间用,隔开*/</span><br>&lt;style&gt;<br><span class="hljs-selector-tag">div</span>,<br><span class="hljs-selector-tag">p</span>,<br><span class="hljs-selector-tag">span</span>&#123;<br>        <span class="hljs-attribute">color</span>: red;<br>&#125;<br>&lt;/style&gt;<br><br>&lt;<span class="hljs-selector-tag">div</span>&gt;<span class="hljs-selector-tag">div</span>标签，红色&lt;/<span class="hljs-selector-tag">div</span>&gt;<br>&lt;<span class="hljs-selector-tag">p</span>&gt;<span class="hljs-selector-tag">p</span>标签，红色&lt;/<span class="hljs-selector-tag">p</span>&gt;<br>&lt;<span class="hljs-selector-tag">span</span>&gt;<span class="hljs-selector-tag">span</span>标签，红色&lt;/<span class="hljs-selector-tag">span</span>&gt;<br></code></pre></td></tr></table></figure></li><li><p><strong>交集选择器</strong>：选中同时<strong>满足多个条件</strong>的元素(了解即可)</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*选择器1选择器2选择3...&#123;CSS属性&#125; 选择器之间连写*/</span><br><span class="hljs-comment">/*标签选择器要写在最前面*/</span><br><br>&lt;style&gt;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.box</span>&#123;<br>    <span class="hljs-attribute">color</span>: red;<br>    <span class="hljs-comment">/*既是p标签，又有box类的*/</span><br>&#125;<br><br>&lt;<span class="hljs-selector-tag">p</span> class=&quot;box&quot;&gt;既是<span class="hljs-selector-tag">p</span>标签又是box类，红色&lt;/<span class="hljs-selector-tag">p</span>&gt;<br>&lt;<span class="hljs-selector-tag">p</span>&gt;只是<span class="hljs-selector-tag">p</span>标签，黑色&lt;/<span class="hljs-selector-tag">p</span>&gt;<br>&lt;<span class="hljs-selector-tag">div</span> class=&quot;box&quot;&gt;只是box类&lt;/<span class="hljs-selector-tag">div</span>&gt;<br></code></pre></td></tr></table></figure></li><li><p><strong>伪类选择器</strong>：伪类表示元素<strong>状态</strong>，选中元素的某个状态设置样式。</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*选择器:状态&#123;CSS属性&#125;*/</span><br>&lt;style&gt;<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>&#123;<br><span class="hljs-attribute">color</span>: red;<br>        <span class="hljs-comment">/*鼠标悬停状态的链接，红色*/</span><br>&#125;<br><span class="hljs-selector-class">.box</span><span class="hljs-selector-pseudo">:hover</span>&#123;<br>    <span class="hljs-attribute">color</span>:green;<br>        <span class="hljs-comment">/*box类鼠标悬停状态，绿色*/</span><br>&#125;<br>&lt;/style&gt;<br><br>&lt;<span class="hljs-selector-tag">a</span> href=&quot;#&quot;&gt;<span class="hljs-selector-tag">a</span> 标签悬停变红&lt;/<span class="hljs-selector-tag">a</span>&gt;<br>&lt;<span class="hljs-selector-tag">div</span> class=&quot;box&quot;&gt;box类，悬停变绿&lt;/<span class="hljs-selector-tag">div</span>&gt;<br></code></pre></td></tr></table></figure><p>  超链接的四种状态</p><table><thead><tr><th>选择器</th><th>作用</th></tr></thead><tbody><tr><td>:link</td><td>访问前</td></tr><tr><td>:visited</td><td>访问后</td></tr><tr><td>:hover</td><td>鼠标悬停</td></tr><tr><td>:active</td><td>点击时（激活）</td></tr></tbody></table><p>  如果要给超链接设置以上四个状态，必须按<strong>LVHA</strong>（LV好啊）的顺序书写</p></li><li><p><strong>结构伪类选择器</strong>：根据元素的<strong>结构关系</strong>查找元素。</p><table><thead><tr><th>选择器</th><th>说明</th></tr></thead><tbody><tr><td>E:first-child</td><td>查找第一个E元素</td></tr><tr><td>E:last-child</td><td>查找最后一个E元素</td></tr><tr><td>E:nth-child(N)</td><td>查找第N个元素(第一个E元素N为1)</td></tr><tr><td>E:net-child(公式)</td><td>查找多个元素</td></tr></tbody></table><table><thead><tr><th>功能</th><th>公式</th></tr></thead><tbody><tr><td>偶数标签</td><td>2n</td></tr><tr><td>奇数标签</td><td>2n+1;2n-1</td></tr><tr><td>5的倍数的标签</td><td>5n</td></tr><tr><td>找到第5个以后的标签</td><td>n+5</td></tr><tr><td>找到第5个以前的标签</td><td>-n+5</td></tr></tbody></table></li><li><p><strong>伪元素选择器</strong>：创建<strong>虚拟元素</strong>（伪元素），用来摆放<strong>装饰性</strong>内容</p><table><thead><tr><th>选择器</th><th>说明</th></tr></thead><tbody><tr><td>E::before</td><td>在E元素<strong>里面</strong>最<strong>前</strong>面添加一个伪元素</td></tr><tr><td>E::after</td><td>在E元素<strong>里面</strong>最<strong>后</strong>面添加一个伪元素</td></tr></tbody></table><p>  注意：</p><ul><li><strong>必须</strong>设置**content:””**属性，用来设置伪元素的内容，如果没有内容，引号留空即可</li><li>伪元素默认是<strong>行内</strong>显示模式</li><li><strong>权重</strong>和<strong>标签选择器</strong>相同</li></ul></li></ul><h1 id="文字效果"><a href="#文字效果" class="headerlink" title="文字效果"></a>文字效果</h1><table><tr style="background-color: red;color: white;">    <td>描述</td>    <td>属性</td>    <td>效果</td></tr><tr>    <td>字体大小</td>    <td>font-size</td>    <td>文字&<span style="font-size: 20px;">文字</span></td></tr><tr>    <td>字体粗细</td>    <td>font-weiight</td>    <td>文字&<span style="font-weight:900;">文字</span></td></tr><tr>    <td>字体倾斜</td>    <td>font-style</td>    <td>文字&<span style="font-style:oblique">文字</span></td></tr><tr>    <td>行高</td>    <td>line-height</td>    <td>文字<br><span style="line-height:50px;">文字</span></td></tr><tr>    <td>字体族</td>    <td>font-family</td>    <td>文字&<span style="font-family:cursive">文字</span></td></tr><tr>    <td>字体复合属性</td>    <td>font</td>    <td>复合属性</td></tr><tr>    <td>文字缩进</td>    <td>text-indent</td>    <td style="text-indent:20px">段落</td></tr><tr>    <td>文本对齐</td>    <td>text-align</td>    <td style="text-align:center">对齐</td></tr><tr>    <td>修饰线</td>    <td>text-decoration</td>    <td>文字&<span style="text-decoration-line:underline;">文本</span>&<span style="text-decoration-line:line-through">文字</span></td></tr><tr>    <td>颜色</td>    <td>color</td>    <td style="color:red">文字<span style="color:green">文字</span></td></tr></table>个别属性注意事项：<ul><li><p><strong>字体大小font-size</strong>：设置字体大小，属性值为数字+px，文字默认大小是16，h1默认32</p></li><li><p><strong>字体加粗font-weight</strong>：可以设置字体的粗细，属性值可以是数字也可以是关键字，如normal（正常）和bold（加粗），但在开发中一般使用数字，<strong>正常为400，加粗为700.</strong></p></li><li><p><strong>字体样式font-style：一般是用来清除文字默认的倾斜效果</strong>，比如em标签，font-style有两个属性值：<strong>normal（正常）</strong>和italic（倾斜）。</p></li><li><p><strong>行高line-height：</strong>设置多行文本的间距，属性值：数字+px或直接数字（当前标签font-size属性值的倍数）。行高&#x3D;上下间距+文本高度。</p></li><li><p><strong>行高实现垂直居中</strong>：行高属性值等于盒子高度属性值。</p></li><li><p><strong>字体族font-family：</strong>设置文字字体，属性值为字体名</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">font-family</span>:楷体<br></code></pre></td></tr></table></figure><p>  属性值可以些多个字体名，中间用<strong>逗号</strong>隔开，执行顺序是从左到右依次查找，如果未找到该字体则使用默认效果。属性<strong>最后</strong>设置一个字体族名，网页开发建议使用<strong>无衬线字体</strong>（sans-serif）。</p></li><li><p><strong>复合属性font</strong>：使用场景：设置网页文字公共样式，有两种写法</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">font-style</span>: italic;<br>    <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">700</span>;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">40px</span>;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">2</span>;<br>    <span class="hljs-attribute">font-family</span>: 楷体;<br>&#125;<br></code></pre></td></tr></table></figure><p>  也可以使用font写法：</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br><span class="hljs-attribute">font</span>: italic <span class="hljs-number">700</span> <span class="hljs-number">30px</span>/<span class="hljs-number">2</span> 楷体;<br>    <span class="hljs-comment">/*倾斜，加粗，字体大小30px，行高2倍， 字体楷体*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>  <strong>font的属性必须按顺序写：倾斜，加粗。字体&#x2F;行高 字体（字号和字体必须写，否则font不生效）</strong></p></li><li><p><strong>文字缩进text-indent：</strong>属性值为：数字+px或<strong>数字+em（推荐使用，1em&#x3D;当前标签的字号大小）</strong>。</p></li><li><p><strong>文字对齐方式text-align</strong>：属性值left（左对齐默认），<strong>center（居中）</strong>，right（右对齐）。还可以用来对齐图片，将img放入div中，div再使用text-align属性。</p></li><li><p><strong>修饰线text-decoration</strong>：可以去除或添加线，比如去除a标签默认的下划线。属性值有四个：<strong>none(无)，underline（下划线）</strong>，line-through（删除线）， overline（上划线）</p></li><li><p><strong>color文字颜色</strong>：</p><table><thead><tr><th>颜色表示方式</th><th>属性值</th><th>说明</th><th>使用场景</th></tr></thead><tbody><tr><td>颜色关键字</td><td>颜色英文单词</td><td>red、green、blue</td><td>学习，测试</td></tr><tr><td>rgb表示法</td><td>rgb(r,g,b)</td><td>rgb表示红绿蓝三原色，取值0-255</td><td>了解</td></tr><tr><td>rgba表示大</td><td>rgba(r,g,b,a)</td><td>a表示透明度，取值<strong>0-1</strong></td><td>开发，实现<strong>透明色</strong></td></tr><tr><td>十六进制表示法</td><td>#RRGGBB</td><td>#000000，#ffcc00，简写：#000，#fc0</td><td>开发使用（从设计稿复制）</td></tr></tbody></table></li></ul><h1 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h1><p>在浏览器按f12，当发现效果未生效时，可以在元素中找到对应的html代码，可以点样式，查看该行的CSS，如果有错误，浏览器会提示，并提示错误的行数。<br>当鼠标移动到CSS代码上时，会出现多个多选框，勾选意味着对应的属性生效，可以很方便的调试。</p><h1 id="CSS特性"><a href="#CSS特性" class="headerlink" title="CSS特性"></a>CSS特性</h1><ul><li><p><strong>继承性</strong>：<strong>子</strong>级默认继承<strong>父</strong>级的<strong>文字控制属性</strong>。所以在工作中，一般<strong>对body设置文字控制属性</strong>。如果<strong>标签自带样式</strong>，那么生效自己的样式，<strong>不继承</strong>。比如p可以继承颜色和字号，a自带颜色，只能继承字号，h自带字号，只能继承颜色等。</p></li><li><p><strong>层叠性</strong>：<strong>对于相同标签</strong></p><ul><li>相同的属性会<strong>覆盖</strong>：<strong>后面</strong>的CSS属性覆盖<strong>前面</strong>的CSS属性</li><li>不同的属性会<strong>叠加</strong>：<strong>不同</strong>的CSS属性<strong>都生效</strong></li></ul></li><li><p><strong>优先级</strong>：也叫权重，当一个标签使用了<strong>多种</strong>选择器时，基于不同种类的选择器的<strong>匹配规则</strong>。<br><strong>通配符选择器&lt;标签选择器&lt;类选择器&lt;id选择器&lt;行内样式&lt;!important</strong>（<strong>选中标签的范围越大，优先级越低</strong>）在属性的分号前加!important，会把该属性的权重提升到<strong>最高</strong></p></li><li><p><strong>优先级-叠加计算规则</strong>：如果是<strong>复合选择器，则需要权重叠加计算</strong></p><p>  （行内样式，id选择器个数，类选择器个数，标签选择器个数）</p><p>  规则：</p><ul><li>从左往右依次比较选个数，同一级个数多的优先级高，如果个数相同，向后比较。</li><li>!important权重最高</li><li>继承权重最低</li></ul></li></ul><h1 id="Emmet写法"><a href="#Emmet写法" class="headerlink" title="Emmet写法"></a>Emmet写法</h1><p>代码的简写方式，输入缩写vscode会自动生成代码</p><ul><li><p>HTML：</p><table><thead><tr><th>说明</th><th>标签结构</th><th>Emmet</th></tr></thead><tbody><tr><td>类选择器</td><td><div class="box"></div></td><td>标签名，类名</td></tr><tr><td>id选择器</td><td><div id="box"></div></td><td>标签名#类名</td></tr><tr><td>同级标签</td><td><div></div><p><p></td><td>div+p</td></tr><tr><td>父子级标签</td><td><div><p></p></div></td><td>div&gt;p</td></tr><tr><td>多个相同标签</td><td><span>1<span>2<span>3</span></span></span></td><td>span*3</td></tr><tr><td>有内容的标签</td><td><div>内容</div></td><td>div{内容}</td></tr></tbody></table></li><li><p>CSS：大多数简写方式为属性单词的<strong>首字母</strong></p></li></ul><h1 id="背景属性"><a href="#背景属性" class="headerlink" title="背景属性"></a>背景属性</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color: rgb(151, 38, 38);color: white&quot;</span>&gt;</span>描述<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color: rgb(151, 38, 38);color: white&quot;</span>&gt;</span>属性<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>背景色<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>background-color<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>背景图<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>background-image<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>背景图平铺方式<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>background-repeat<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>背景图位置<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>background-position<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>背景图缩放<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>background-size<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>背景图固定<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>background-attachment<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>背景复合属性<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>background<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><p>用法与注意事项：</p><ul><li><p><strong>背景图background-image</strong>：属性值为：<strong>url(.&#x2F;xx.jpg)<strong>，</strong>默认平铺效果</strong></p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br><span class="hljs-selector-tag">div</span> &#123;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;<br>        <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;<br>        <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">./images/1.png</span>);<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure></li><li><p><strong>背景图平铺方式background-repeat</strong>：属性值为：**no-repeat(不平铺，左上角)**，repeat（平铺，默认），repeat-x(水平平铺)，repeat-y（垂直平铺）</p></li><li><p><strong>背景图位置background-position</strong>：属性值可以是<strong>关键字</strong>也可以是<strong>数字</strong>，还可以是二者<strong>混用</strong>。</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-comment">/*bakcground-position: 水平位置 垂直位置*/</span><br><span class="hljs-attribute">background-position</span><span class="hljs-selector-pseudo">:left</span> <span class="hljs-attribute">top</span>;<br>    <span class="hljs-comment">/*图片水平居左，垂直居上*/</span><br>    <span class="hljs-attribute">background-position</span>:<span class="hljs-number">50px</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/*图片水平向右移动50px*/</span><br>    bakcground-<span class="hljs-attribute">position</span>:<span class="hljs-number">0</span> <span class="hljs-number">50px</span>;<br>    <span class="hljs-comment">/*图片垂直向下移动50px*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>  使用数字的话，正数为水平向右垂直向下，负数反之。关键字有left,right,center,top,bottom。</p><ul><li>特殊写法：<ul><li><strong>关键字</strong>取值方法可以<strong>颠倒</strong>取值顺序</li><li>可以只写一个关键字，<strong>另一个方向</strong>默认为<strong>居中</strong>；数字只写一个表示<strong>水平方向</strong>，<strong>垂直方向居中</strong>。</li></ul></li></ul></li><li><p><strong>背景图缩放background-size</strong>：属性值有关键字、百分比、数字+单位。</p><ul><li><strong>关键字</strong>：<ul><li>cover:等比例缩放背景图片以完全覆盖背景图片，可能背景图片部分不可见</li><li>contain:等比例缩放背景图片以完全装入背景区，可能背景部分空白</li></ul></li><li><strong>百分比</strong>：根据盒子尺寸计算图片大小</li><li>数字加单位</li></ul></li><li><p><strong>背景图固定background-attachment</strong>：属性值：fixed。使背景不会随着元素的内容滚动</p></li><li><p><strong>背景图复合属性background</strong>：和之前说过的font一样，多个属性值之间用空格隔开，但不需要区分顺序。</p></li></ul><h1 id="显示模式"><a href="#显示模式" class="headerlink" title="显示模式"></a>显示模式</h1><ul><li><p><strong>块级元素</strong></p><ul><li><strong>独占一行</strong></li><li>宽度默认是<strong>父</strong>级的<strong>100%</strong></li><li>添加<strong>宽高</strong>属性<strong>生效</strong></li></ul><p>  如div</p></li><li><p><strong>行内元素</strong></p><ul><li>一行共存<strong>多个</strong></li><li>尺寸由<strong>内容</strong>撑开</li><li>添加宽高属性<strong>不生效</strong></li></ul><p>  如span</p></li><li><p><strong>行内块元素</strong></p><ul><li>一行共存<strong>多个</strong></li><li>默认尺寸由<strong>内容</strong>撑开</li><li>添加宽高属性<strong>生效</strong></li></ul><p>  如img</p></li></ul><h1 id="转换显示模式"><a href="#转换显示模式" class="headerlink" title="转换显示模式"></a>转换显示模式</h1><p>属性名：<strong>display</strong><br>属性值：</p><table><thead><tr><th>属性值</th><th>效果</th></tr></thead><tbody><tr><td>block(常用)</td><td>块级</td></tr><tr><td>inline-block(常用)</td><td>行内块</td></tr><tr><td>inline(不常用)</td><td>行内</td></tr></tbody></table><h1 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h1><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul><li>内容区域-width&amp;height</li><li>内边距-<strong>padding</strong>（出现在内容与盒子边缘之间）</li><li>边框线-<strong>border</strong></li><li>外边框-<strong>margin</strong>（出现在盒子外面）</li></ul><h2 id="边框线"><a href="#边框线" class="headerlink" title="边框线"></a>边框线</h2><p>属性名：border<br>属性值：边框线粗细 线条样式 颜色（中间用空格隔开，不区分顺序）<br>常用线条样式：</p><table><thead><tr><th>属性值</th><th>线条样式</th></tr></thead><tbody><tr><td>solid</td><td>实线</td></tr><tr><td>dashed</td><td>虚线</td></tr><tr><td>dotted</td><td>点线</td></tr></tbody></table><ul><li><p>设置单方向边框线<strong>border-方位名词</strong>：属性值：边框线粗细 线条样式 颜色</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">2px</span> solid red;<br>    <span class="hljs-comment">/*设置上边框线*/</span><br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">3px</span> dashed green;<br>    <span class="hljs-comment">/*设置右*/</span><br><span class="hljs-attribute">border-left</span>: ...;<br>    <span class="hljs-comment">/*设置左*/</span><br>    <span class="hljs-attribute">border-bottom</span>:...;<br>    <span class="hljs-comment">/*设置下*/</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="内边距"><a href="#内边距" class="headerlink" title="内边距"></a>内边距</h2><p>设置<strong>内容</strong>与<strong>盒子边缘</strong>之间的距离</p><p>属性名：<strong>padding</strong>&#x2F;<strong>padding-方位名词</strong></p><ul><li><p>内边距多值写法：</p><table><thead><tr><th>取值个数</th><th>示例</th><th>含义</th></tr></thead><tbody><tr><td>一个值</td><td>padding: 10px</td><td>四个方向内边距均为10px</td></tr><tr><td>四个值</td><td>padding: 10px 20px 40px 80px</td><td>上右下左</td></tr><tr><td>三个值</td><td>padding: 10px 40px 80px</td><td>上，左右，下</td></tr><tr><td>两个值</td><td>padding: 10px 80px</td><td>上下，左右</td></tr></tbody></table><p>  记忆方法：从上开始顺时针旋转，如果没有对应的值，则于对面的相同。</p></li></ul><h2 id="盒子尺寸计算"><a href="#盒子尺寸计算" class="headerlink" title="盒子尺寸计算"></a>盒子尺寸计算</h2><ul><li>默认情况：盒子尺寸&#x3D;内容尺寸+border尺寸+内边距尺寸</li><li>结论：给盒子border&#x2F;padding会<strong>撑大</strong>盒子</li><li>解决：<ul><li><strong>手动做减法</strong>，减掉border&#x2F;padding的尺寸</li><li>内减模式：<strong>添加代码：box-sizing:border-box</strong></li></ul></li></ul><h2 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h2><p>拉开两个盒子之间的距离，与padding属性值写法、含义相同。</p><ul><li>版心居中效果：盒子设置宽度后，将padding值设置为auto，这样盒子到浏览器两边的距离会相等。</li></ul><h2 id="清除默认样式"><a href="#清除默认样式" class="headerlink" title="清除默认样式"></a>清除默认样式</h2><p>清除标签默认的样式，如：默认的内容边框。有两种写法，一种是使用通配选择器清除所有标签的样式，一种是用并集选择器清除所有有默认样式的标签。</p><h2 id="元素溢出-overflow"><a href="#元素溢出-overflow" class="headerlink" title="元素溢出-overflow"></a>元素溢出-overflow</h2><p>控制<strong>溢出</strong>元素的<strong>内容</strong>的<strong>显示方式</strong><br></p><table><thead><tr><th>属性值</th><th>效果</th></tr></thead><tbody><tr><td><strong>hiddne</strong></td><td><strong>隐藏</strong></td></tr><tr><td>scroll</td><td>溢出滚动（无论是否溢出，都显示滚动条位置）</td></tr><tr><td>auto</td><td>溢出滚动（溢出才显示滚动条位置）</td></tr></tbody></table><h2 id="外边距问题-合并现象"><a href="#外边距问题-合并现象" class="headerlink" title="外边距问题-合并现象"></a>外边距问题-合并现象</h2><p>场景：<strong>垂直</strong>排列的<strong>兄弟</strong>元素，<strong>上下maegin</strong>会合并<br>现象：取两个margin中的<strong>较大值</strong>生效</p><h2 id="外边距问题-塌陷问题"><a href="#外边距问题-塌陷问题" class="headerlink" title="外边距问题-塌陷问题"></a>外边距问题-塌陷问题</h2><p>场景：<strong>父子级</strong>的标签，<strong>子级</strong>的添加<strong>上外边距</strong>会产生<strong>塌陷</strong>问题<br>现象：导致父级一起向下移动<br>解决方法：</p><ul><li><strong>取消子级margin</strong>，<strong>父</strong>级设置<strong>padding</strong></li><li><strong>父</strong>级设置<strong>overflow:hidden</strong></li><li><strong>父</strong>级设置<strong>border-top</strong></li></ul><h2 id="圆角border-radius"><a href="#圆角border-radius" class="headerlink" title="圆角border-radius"></a>圆角border-radius</h2><p>设置元素的外边框为圆角。属性名：border-radius。属性值：数字+px&#x2F;百分比，属性值为半径。和border一样，顺时针，从左上角开始。</p><h2 id="阴影box-shadow"><a href="#阴影box-shadow" class="headerlink" title="阴影box-shadow"></a>阴影box-shadow</h2><p>给元素设置阴影效果<br>属性值：X轴偏移量 Y轴偏移量 模糊半径 扩散半径 颜色 内外阴影</p><ul><li>X轴和Y轴偏移量<strong>必须</strong>书写</li><li><strong>默认是外阴影</strong>，内阴影需要使用<strong>inset</strong></li></ul><h1 id="标准流、浮动与flex"><a href="#标准流、浮动与flex" class="headerlink" title="标准流、浮动与flex"></a>标准流、浮动与flex</h1><ul><li><p>标准流：也叫文档流，指的是标签在页面中默认的<strong>排布规则</strong></p></li><li><p>浮动：让块级元素水平排列。以前常用，现在多使用flex布局。</p></li><li><p>flex布局：</p></li></ul><h1 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>作用：让块元素水平排列。属性名：<strong>float</strong>。属性值：</p><ul><li><strong>left</strong>：左对齐</li><li><strong>right</strong>：右对齐</li></ul><p>浮动的特点：盒子均为<strong>顶对齐</strong>，且变为<strong>行内块</strong>。若display直接改为行内块会对齐最长盒子的底部。且使用了浮动的元素，会<strong>脱离标准流的控制</strong>，比如现在写了两个盒子，one使用了float:left，two不使用，那么浏览器会认为<strong>two才是第一个元素</strong>，one和two会同时位于左上角重合，<strong>且one浮于上方。</strong> </p><h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><p>场景：浮动元素会<strong>脱标</strong>，如果<strong>父级没有高度</strong>，<strong>子级无法撑开父级高度</strong>（可能导致页面布局错乱）<br>解决方法：<strong>清除浮动</strong></p><ul><li>额外标签法：<ul><li><p>在<strong>父</strong>元素<strong>内容的最后</strong>添加一个块级元素，设置CSS属性<strong>clear:both</strong></p></li><li><p>单伪元素法：</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span> &#123;<br><span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></td></tr></table></figure><p>  将父元素的添加clearfix类，原理与额外标签法相同</p></li><li><p><strong>双伪元素（推荐）</strong>：</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::before</span>,<span class="hljs-comment">/*解决外边距塌陷问题*/</span><br><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span>&#123;<span class="hljs-comment">/*清除浮动的影响*/</span><br><span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-attribute">display</span>: table;<br>&#125;<br><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span>&#123;<br>    <span class="hljs-attribute">clear</span>:both;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>overflow<br>  父元素添加CSS属性<strong>overflow:hidden</strong></p></li></ul></li></ul><h1 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h1><p>Flex布局也叫弹性布局，是浏览器提倡的的布局模型，非常适合结构化布局，提供了强大的<strong>空间分布</strong>和<strong>对齐</strong>能力。Flex模型<strong>不会</strong>产生浮动布局中<strong>脱标</strong>现象，布局网页<strong>更简单和灵活</strong></p><h2 id="Flex组成"><a href="#Flex组成" class="headerlink" title="Flex组成"></a>Flex组成</h2><p>设置方式：给<strong>父元素</strong>设置<strong>display:flex</strong>，<strong>子元素</strong>可以<strong>自动挤压或拉伸</strong><br>组成部分：</p><ul><li>弹性容器</li><li>弹性盒子</li><li>主轴：默认在<strong>水平方向</strong></li><li>测轴&#x2F;交叉轴：默认在<strong>垂直方向</strong></li></ul><h2 id="Flex布局属性"><a href="#Flex布局属性" class="headerlink" title="Flex布局属性"></a>Flex布局属性</h2><table>    <tr style="background-color: rgb(219, 8, 8);color:#fff">        <td>描述</td>        <td>属性</td>    </tr>    <tr>        <td>创建flex容器</td>        <td>display:flex</td>    </tr>    <tr>        <td>主轴对齐方式</td>        <td>justify-content</td>    </tr>    <tr>        <td>侧轴对齐方式</td>        <td>align-items</td>    </tr>    <tr>        <td>某个弹性盒子侧轴对齐方式</td>        <td>align-self</td>    </tr>    <tr>        <td>修改主轴方向</td>        <td>flex-direction</td>    </tr>    <tr>        <td>弹性伸缩比</td>        <td>flex</td>    </tr>    <tr>        <td>弹性盒子换行</td>        <td>flex-wrap</td>    </tr>    <tr>        <td>行对齐方式</td>        <td>align-content</td>    </tr></table><ul><li><p>主轴对齐方式<br>  属性名：<strong>justify-content</strong></p><table><thead><tr><th>属性值</th><th>效果</th></tr></thead><tbody><tr><td>flex-start</td><td>默认值，弹性盒子从<strong>起点</strong>开始依次排列</td></tr><tr><td>flex-end</td><td>弹性盒子从<strong>终点</strong>开始依次排列</td></tr><tr><td><strong>center</strong></td><td>弹性盒子沿主轴<strong>居中</strong>排列</td></tr><tr><td><strong>space-between</strong></td><td>弹性盒子沿主轴均匀排列，空白间距均分在弹性盒子<strong>之间</strong></td></tr><tr><td><strong>space-around</strong></td><td>弹性盒子沿主轴均匀排列，空白间距均分在弹性盒子<strong>两侧</strong></td></tr><tr><td><strong>space-evenly</strong></td><td>弹性盒子沿主轴均匀分布排列，弹性盒子与容器之间间距相等</td></tr></tbody></table></li><li><p>侧轴对齐方式</p><p>  属性名：</p><ul><li><strong>align-items</strong>:当前弹性容器内<strong>所有</strong>弹性盒子的侧轴对齐方式（给弹性容器设置）</li><li><strong>align-self</strong>:单独控制<strong>某个</strong>弹性盒子的侧轴对齐方式（给弹性盒子设置）</li></ul><table><thead><tr><th>属性值</th><th>效果</th></tr></thead><tbody><tr><td><strong>stretch</strong></td><td>弹性盒子沿着侧轴线<strong>拉伸至铺满容器</strong>（弹性盒子没有设置侧轴方向尺寸则默认拉伸）</td></tr><tr><td><strong>center</strong></td><td>弹性盒子沿侧轴<strong>居中</strong>排列</td></tr><tr><td>flex-start</td><td>弹性盒子从<strong>起点</strong>开始依次排列</td></tr><tr><td>flex-end</td><td>弹性盒子从<strong>终点</strong>开始依次排列</td></tr></tbody></table></li><li><p>修改主轴方向</p><p>  主轴<strong>默认在水平方向</strong>，侧轴默认在垂直方向</p><p>  属性名：<strong>flex-direcation</strong>：</p><table><thead><tr><th>属性名</th><th>效果</th></tr></thead><tbody><tr><td>row</td><td>水平方向，从左至右（默认）</td></tr><tr><td><strong>column</strong></td><td>垂直方向，从上到下</td></tr><tr><td>row-reverse</td><td>水平方向，从右到左</td></tr><tr><td>column-reverse</td><td>垂直方向，从下到上</td></tr></tbody></table></li><li><p>弹性伸缩比</p><p>  控制弹性盒子的<strong>主轴</strong>方向的<strong>尺寸</strong></p><p>  属性名：flex</p><p>  属性值：<strong>整数数字</strong>，表示占用父级<strong>剩余</strong>尺寸的<strong>份数</strong></p></li><li><p>弹性盒子换行</p><p>  弹性盒子可以<strong>自动挤压或拉伸</strong>，默认情况下，所有弹性盒子都在一行显示</p><p>  属性名：<strong>flex-wrap</strong></p><p>  属性值</p><ul><li><strong>wrap：换行</strong></li><li>nowrap:不换行（默认）</li></ul></li><li><p>行对齐方式</p><p>  在开启换行情况下，多行之间的对齐方式</p><p>  属性名：<strong>align-content</strong></p><p>  属性值：</p><table><thead><tr><th>属性值</th><th>效果</th></tr></thead><tbody><tr><td>flex-start</td><td>默认值，弹性盒子从<strong>起点开始依次排序</strong></td></tr><tr><td>flex-end</td><td>弹性盒子从<strong>终点开始依次排序</strong></td></tr><tr><td><strong>center</strong></td><td>弹性盒子沿主轴<strong>居中排列</strong></td></tr><tr><td><strong>spance-between</strong></td><td>弹性盒子沿主轴均匀排列，空白间距均分在弹性盒子<strong>之间</strong></td></tr><tr><td><strong>spance-around</strong></td><td>弹性盒子沿主轴均匀排列，空白间距均分在弹性盒子<strong>两侧</strong></td></tr><tr><td><strong>space-evenly</strong></td><td>弹性盒子沿主轴均匀排列，弹性盒子与容器之间间距相等</td></tr></tbody></table></li></ul><h1 id="定位和层叠"><a href="#定位和层叠" class="headerlink" title="定位和层叠"></a>定位和层叠</h1><h2 id="定位-position"><a href="#定位-position" class="headerlink" title="定位 position"></a>定位 position</h2><p><strong>作用</strong>：灵活的改变盒子在网页中的位置</p><p><strong>实现：</strong></p><ol><li>设置定位模式：position</li><li>偏移值：设置盒子的位置</li></ol><p><strong>position</strong>用来设置定位模式有以下取值</p><table><thead><tr><th>取值</th><th>说明</th></tr></thead><tbody><tr><td>relative</td><td>1. 相对位置。相对于自己原本的位置。2.不脱标，偏移后的位置依然会有空位。3.不改变显示模式。</td></tr><tr><td>absolute</td><td>1.绝对定位。相对于已定位的最近祖先元素。没有则参照窗口。2.脱标。3.显示模式具备行内块特点。</td></tr><tr><td>fixed</td><td>1.固定定位。网页滚动时位置不会改变。2.脱标。3.显示模式具备行内块特点。</td></tr></tbody></table><p><strong>偏移</strong>值可以通过以下属性设置</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>top</td><td>顶部距离</td></tr><tr><td>right</td><td>右边距离</td></tr><tr><td>left</td><td>左边距离</td></tr><tr><td>bottom</td><td>底部距离</td></tr></tbody></table><p>注意，偏移值和position设置的模式有关，relative相对自己原本的位置如：<code>top:10px</code>则会下移10像素，absolute相对已定位的最近祖先元素；fixed相对于浏览器，比如<code>top:50%</code>移动到浏览器的中部（上边框的位置位于浏览器中线）。</p><p>还可以通过设置<strong>transform</strong>属性的**translate(x,y)**，会移动自身，如果参数设置百分比则是自身大小的百分比。</p><h2 id="堆叠层级-z-index"><a href="#堆叠层级-z-index" class="headerlink" title="堆叠层级 z-index"></a>堆叠层级 z-index</h2><p><strong>默认效果：</strong>当我们给多个标签设置了定位，会按照标签的书写顺序，后来者居上。</p><p><strong>作用：</strong>设置<strong>定位</strong>元素的<strong>层级顺序</strong>，改变定位元素的显示顺序。</p><p><strong>实现：</strong>设置z-index的值，值越大越靠上。</p><h2 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h2><p>定位在我们的网页中很常见，比如轮播图两边&#x2F;下边的按钮，使用了absolute定位；当我们下滑网页时，出现的“返回顶部”按钮，使用了fixed定位。</p><h1 id="CSS精灵"><a href="#CSS精灵" class="headerlink" title="CSS精灵"></a>CSS精灵</h1><p><strong>CSS Sprites</strong>（<del>CSS雪碧</del>）又叫<strong>CSS精灵</strong>，是一种网页图片<strong>应用</strong>处理方式，把网页中的<strong>背景图</strong>整合到一张图片上，再用<strong>background-position</strong>定位出图片的位置。</p><p><strong>优点：</strong>减少服务器请求次数，提高加载速度。</p><h1 id="字体图标"><a href="#字体图标" class="headerlink" title="字体图标"></a>字体图标</h1><p>展示的是<strong>图标</strong>，本质是<strong>文字</strong>。</p><p><strong>作用：</strong>添加简单、纯色的小图标</p><p><strong>优点：</strong></p><ul><li>灵活性：修改样式灵活，如：尺寸颜色等</li><li>轻量级：体积小、渲染快、降低服务器请求次数</li><li>兼容性：几乎兼容所有主流浏览器</li><li>使用方便：下载后使用</li></ul><p><strong>推荐下载站点：</strong>inconfont</p><p>下载后将文件解压得到的文件中，html是示例文件，需要用到图标时在里面找类名，css样式文件，和字体文件。</p><p>解压导入后，给标签设置对应的类名就可以使用了。</p><p><strong>使用示例：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--引入样式表--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;./iconfont/iconfont.css&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-comment">/*使用选择器时需要注意优先级，字体图标自带样式*/</span></span><br><span class="language-css">        <span class="hljs-selector-class">.iconfont</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">10px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;iconfont icon-icon-test1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="垂直对齐-vertical-align"><a href="#垂直对齐-vertical-align" class="headerlink" title="垂直对齐 vertical-align"></a>垂直对齐 vertical-align</h1><p>当我们同时放入文字和图片（行内块）时，会发现，图片和文字似乎是底部对齐的方式，当放大后会发现，图片下方由一段小空白，实际上，这种对齐方式叫做<strong>基线对齐</strong>，我们写单词时，都是以第三条线做基线，有的基线在底部（abc…)，有的基线不在底部（pqg），而我们写字的方式就是基线对齐。</p><p>当我们把文字和行内块放一起时，行内块会当作文字处理，他的基线在底部，而有的文字基线不是在底部，所以会加上一小段空白。</p><p>需要改变这种对齐方式，给高的行内块使用<strong>vertical-align</strong>就可以了</p><p><strong>取值：</strong></p><table><thead><tr><th>取值</th><th>说明</th></tr></thead><tbody><tr><td>baseline</td><td>基线对齐，默认</td></tr><tr><td>top</td><td>顶部对齐</td></tr><tr><td>middle</td><td>居中对齐</td></tr><tr><td>bottom</td><td>底部对齐</td></tr></tbody></table><p>其中<strong>middle</strong>是最常用的。</p><h1 id="过渡属性-transition"><a href="#过渡属性-transition" class="headerlink" title="过渡属性-transition"></a>过渡属性-transition</h1><p><strong>作用：</strong>为一个元素<strong>不同状态</strong>的切换添加<strong>过渡效果</strong></p><p><strong>属性名：</strong>transition（复合属性）</p><p><strong>属性值：</strong>过渡的属性 【空格】花费时间（s或ms）</p><p>过渡的属性可以是<strong>具体的CSS属性</strong>，也可以是<strong>all</strong>（两个状态属性不同的所有属性，都产生过渡效果）。</p><p>滑动解锁：</p><p>设置hover，一直移动且添加过渡效果，</p><h1 id="透明度-opacity"><a href="#透明度-opacity" class="headerlink" title="透明度-opacity"></a>透明度-opacity</h1><p><strong>作用：</strong>设置<strong>整个元素的透明度</strong>（包括背景和内容）</p><p><strong>取值：</strong>0-1之间，1为完全透明，0为不透明</p><h1 id="光标类型-cursor"><a href="#光标类型-cursor" class="headerlink" title="光标类型-cursor"></a>光标类型-cursor</h1><p><strong>作用：</strong>鼠标<strong>悬停</strong>在元素上时<strong>显示指针样式</strong></p><p><strong>属性值：</strong></p><table><thead><tr><th>属性值</th><th>效果</th></tr></thead><tbody><tr><td>default</td><td>默认值，通常是箭头</td></tr><tr><td>pointer</td><td>小手效果，提示用户可以点击</td></tr><tr><td>text</td><td>工字形，提示用户可以选择文字</td></tr><tr><td>move</td><td>十字光标，提示用户可以移动</td></tr></tbody></table><h1 id="SEO搜索引擎优化"><a href="#SEO搜索引擎优化" class="headerlink" title="SEO搜索引擎优化"></a>SEO搜索引擎优化</h1><p>在公司中一般会有专门的SEO人员，但有时也需要前端的配合。SEO就是网站排名，下面是提升网站排名的一些常用方法：</p><ol><li>花钱</li><li>将网页制作成html后缀</li><li>标签语义化</li><li>…</li></ol><p>网页头部SEO标签：</p><ul><li>title：网页标题</li><li>description：网页描述</li><li>keywords：网页关键词</li></ul><h1 id="网站图标-favicon"><a href="#网站图标-favicon" class="headerlink" title="网站图标 favicon"></a>网站图标 favicon</h1><p>出现在标题栏的图标，增加网站辨识度。</p><p>在vsconde中输入<code>link:favicon</code>即可快速生成</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;shortcut icon&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;favicon.ico&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;image/x-icon&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h1 id="平面转换"><a href="#平面转换" class="headerlink" title="平面转换"></a>平面转换</h1><h2 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h2><p><strong>作用：</strong>为元素添加动态效果，一般与过渡使用</p><p><strong>概念：</strong>改变盒子<strong>平面内</strong>的形态（位移、旋转、缩放、倾斜）</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>translate(x轴移动距离，y轴移动距离)</td><td>平移，输入百分比是以自己为参考，只输入一个值表示x轴移动，也可以使用translateX（）</td></tr><tr><td>rotate（旋转角度）</td><td>旋转，角度的单位是deg，正数顺时针，负数逆时针</td></tr><tr><td>scale（缩放倍数）&#x2F;scale（x缩放，y缩放）</td><td>中心缩放，输入负数就镜像</td></tr><tr><td>skew（角度）</td><td>倾斜，角度单位deg</td></tr></tbody></table><p>关于缩放有一点说下，我一开始觉得用<code>width</code>和<code>height</code>也可以，但后面发现，这样做出来的缩放中心点是在左上角的，效果很差。</p><h2 id="改变转换原点-transform-origin"><a href="#改变转换原点-transform-origin" class="headerlink" title="改变转换原点 transform-origin"></a>改变转换原点 transform-origin</h2><p><strong>默认：</strong>盒子中心点</p><p><strong>属性：</strong><code>transform-origin: 水平原点位置 </code></p><p><strong>取值：</strong></p><ul><li><strong>方位名词</strong>（left,top,right,bottom,center）</li><li>像素单位数值</li><li>百分比</li></ul><h2 id="多重转换"><a href="#多重转换" class="headerlink" title="多重转换"></a>多重转换</h2><p>如果我们想要给一个盒子设置多种转换效果，比如轮胎，一边旋转一边平移，就需要使用到多重转换，多重转换需要一些技巧</p><ul><li><p><strong>先平移后旋转</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>() <span class="hljs-built_in">rotate</span>();<br></code></pre></td></tr></table></figure><p>因为旋转会改变坐标轴向，坐标轴向以第一个转换为准，如果反过来你会发现轮胎螺旋着出去了（<del>其实也挺酷的</del>）</p></li><li><p><strong>必须复合属性</strong></p><p>不能拆开写</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>();<br><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>();<br></code></pre></td></tr></table></figure><p>这样写后面的属性会把前面的覆盖掉</p></li></ul><h1 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h1><p><strong>分类：</strong></p><ul><li><p>线性渐变：linear-gradient（to 方位名词&#x2F;角度， 颜色1 终点位置， 颜色2 终点位置）</p></li><li><p>径向渐变：radial-gradient（半径 at 圆心位置，颜色1 终点位置， 颜色2 终点位置）</p><p>如果写了两个半径则为椭圆。</p></li></ul><p><strong>线性渐变：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>    //红色向做渐变为黄色<br>    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(to left, red <span class="hljs-number">20%</span> ,yellow <span class="hljs-number">100%</span>);<br>    //<span class="hljs-number">45</span>度向上渐变<br>    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">45deg</span>, red <span class="hljs-number">20%</span> ,yellow <span class="hljs-number">100%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>径向渐变：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">radial-gradient</span>(<span class="hljs-number">50px</span> at <span class="hljs-number">50%</span> <span class="hljs-number">50%</span>, red <span class="hljs-number">50%</span>, yellow <span class="hljs-number">100%</span>);<br>    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">radial-gradient</span>(<span class="hljs-number">50px</span> <span class="hljs-number">50px</span> at center center, red <span class="hljs-number">50%</span>, yellow <span class="hljs-number">100%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="空间转换"><a href="#空间转换" class="headerlink" title="空间转换"></a>空间转换</h1><h2 id="transform-1"><a href="#transform-1" class="headerlink" title="transform"></a>transform</h2><p><strong>属性值：</strong></p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>translate3d(x,y,z)</td><td>平移，用法和translate一样，但必须写满三个参数，变种有<code>translateX,Y,Z</code>,使用空间转换之前需要设置<strong>视距</strong></td></tr><tr><td>rotateX,Y,Z(角度)</td><td>旋转，rotateX表示绕X轴旋转，以此类推，坐标轴原点在盒子中心。（说起来参数正负旋转的方向和魔方有点像）</td></tr><tr><td>rotate3d(x,y,z,角度)</td><td>设置自定义旋转轴的位置及旋转角度，x,y,z三个位置取值为0-1</td></tr><tr><td>scale3d(x,y,z)</td><td>缩放，<code>scaleX,Y,Z()</code></td></tr></tbody></table><p>关于旋转方向的两种记忆方式</p><ol><li>类比魔方（<del>夹带私货</del>），比如R，表示从魔方的右面看顺时针转动，那么类比下来，<code>translateX(10deg)</code>就表示从<strong>X正方向</strong>看（坐X轴的箭头指向自己），<strong>顺时针</strong>转动，从正面看起来就是，盒子的上边远离，下边靠近。</li><li><strong>左手定则</strong>，不知道在看的你还记不记得物理学过的左手定则，将大拇指指向想要沿着旋转的轴，其余四指旋转方向就是正数。</li></ol><h2 id="视距-perspective"><a href="#视距-perspective" class="headerlink" title="视距 perspective"></a>视距 perspective</h2><p><strong>作用：</strong>指定<strong>观察者</strong>与<strong>z&#x3D;0</strong>平面的<strong>距离</strong>，为元素添加<strong>透视效果</strong></p><p>在相同的位移下，视距越大，变化越不明显，可以类比人眼，蚂蚁在眼前走几毫米立马就知道了，太阳时时刻刻转动却没感觉。</p><p><strong>透视效果：近大远小，近实远虚</strong></p><p><strong>属性值：</strong>添加给<strong>直接父级</strong>，范围<strong>800-12200</strong>（经验）</p><h2 id="立体呈现-transform-style"><a href="#立体呈现-transform-style" class="headerlink" title="立体呈现 transform-style"></a>立体呈现 transform-style</h2><p><strong>作用：</strong>设置元素的<strong>子元素</strong>是否位于<strong>3d空间中</strong></p><p><strong>属性值：</strong></p><ul><li>flat：子级位于平面（默认）</li><li>preserve-3d：子级位于3d空间</li></ul><h1 id="动画-animation"><a href="#动画-animation" class="headerlink" title="动画 animation"></a>动画 animation</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><strong>过渡与动画的区别：</strong></p><ul><li>过渡：实现<strong>两个状态</strong>之间的变化过程</li><li>动画：实现<strong>多个状态</strong>的变化过程，<strong>动画可控（重复播放、最终画面、是否暂停）</strong></li></ul><p><strong>实现：</strong></p><ol><li><p>定义动画</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*实现两个状态之间的动画*/</span><br><span class="hljs-keyword">@keyframes</span> 动画名词 &#123;<br>    <span class="hljs-selector-tag">from</span> &#123;&#125;<br>    <span class="hljs-selector-tag">to</span> &#123;&#125;<br>&#125;<br><span class="hljs-comment">/*实现多个状态之间的动画*/</span><br><span class="hljs-keyword">@keyframes</span> 动画名称 &#123;<br>    <span class="hljs-number">0%</span> &#123;&#125;<br>    <span class="hljs-number">10%</span> &#123;&#125;<br>    ...<br>    <span class="hljs-number">100%</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用动画</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*给需要动画的标签设置animation*/</span><br><span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">animation</span>: 动画名称 动画时长 ...;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><strong>属性值：</strong></p><p><strong>animation</strong>是个复合属性，他的属性值有：动画名称、动画时长、速度曲线、延迟时间、重复次数、动画方向 执行完毕时状态。</p><p>其中动画名称和动画时长为必填，<strong>取值不分先后</strong>，如果有两个时间，第一个表示<strong>动画时长</strong>，第二个表示<strong>延迟时间</strong></p><table><thead><tr><th>属性</th><th>说明</th><th>取值</th></tr></thead><tbody><tr><td>animation-name</td><td>动画名称</td><td>动画名</td></tr><tr><td>animation-duration</td><td>动画时长，秒或毫秒</td><td>1s,1ms等</td></tr><tr><td>animation-timing-function</td><td>速度曲线</td><td><a href="#animation-timing-function">详情</a></td></tr><tr><td>animation-fill-mode</td><td>规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式。</td><td></td></tr><tr><td>animation-delay</td><td>动画延迟播放</td><td>1s,1ms等，默认0</td></tr><tr><td>animation-iteration-count</td><td>动画播放次数</td><td>默认1</td></tr><tr><td>animation-direction</td><td>动画在下一周期是否逆向播放</td><td>默认normal，<a href="#animation-iteration-count">详情</a></td></tr><tr><td>animation-play-state</td><td>动画状态，暂停或播放</td><td>running&#x2F;paused,默认running</td></tr></tbody></table><h2 id="多组动画"><a href="#多组动画" class="headerlink" title="多组动画"></a>多组动画</h2><p>在animation属性中可以用逗号将多个动画隔开，做到多组动画。</p><h2 id="属性详解"><a href="#属性详解" class="headerlink" title="属性详解"></a>属性详解</h2><h3 id="animation-timing-function"><a href="#animation-timing-function" class="headerlink" title="animation-timing-function"></a>animation-timing-function</h3><div id="animation-timing-function"></div><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>linear</td><td>匀速播放</td></tr><tr><td>ease</td><td>默认，先慢后快再慢</td></tr><tr><td>ease-in</td><td>以慢速开始</td></tr><tr><td>ease-out</td><td>以慢速结束</td></tr><tr><td>ease-in-out</td><td>开始和结束都是慢速</td></tr><tr><td>steps(uint, start|end)</td><td>逐帧动画，第一个参数为步长，就是将动画分成几部分；第二个参数是可选的start&#x2F;end，默认值为end</td></tr><tr><td>cubic-bezier(n,n,n,n)</td><td>定义三次贝塞尔曲线,<a href="cubic-bezier.com">推荐网站</a></td></tr></tbody></table><h3 id="animation-fill-mode"><a href="#animation-fill-mode" class="headerlink" title="animation-fill-mode"></a>animation-fill-mode</h3><div id="animation-fill-mode"></div><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>none</td><td>默认值。动画在动画执行之前和之后不会应用任何样式到目标元素。</td></tr><tr><td>forwards</td><td>结束后停留在结束状态</td></tr><tr><td>backwards</td><td>结束后停留在开始状态</td></tr><tr><td>both</td><td>动画遵循 forwards 和 backwards 的规则。也就是说，动画会在两个方向上扩展动画属性。</td></tr></tbody></table><h3 id="animation-iteration-count"><a href="#animation-iteration-count" class="headerlink" title="animation-iteration-count"></a>animation-iteration-count</h3><div id="animation-iteration-count"></div><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>normal</td><td>默认值，动画正常播放</td></tr><tr><td>reverse</td><td>动画反向播放</td></tr><tr><td>altemate</td><td>动画在奇数次正向播放，在偶数次反向播放</td></tr><tr><td>alternate-reverse</td><td>动画在偶数次正向播放，在奇数次反向播放</td></tr></tbody></table><h1 id="移动端布局"><a href="#移动端布局" class="headerlink" title="移动端布局"></a>移动端布局</h1><h2 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h2><p>设别的分辨率分为物理（不可变）和逻辑（可变，比如电脑设置里的100%，150%等），在制作网页的时候，参考的是逻辑分辨率。</p><p>在制作pc网页的时候，html的宽和逻辑分辨率是一样的，但是默认情况下<strong>移动端网页的宽和逻辑分辨率是不一样的</strong>，想要一样就需要设置<strong>视口</strong></p><h2 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h2><ul><li><p>视口： <strong>显示HTML网页的时候，用来约束HTML尺寸</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个标签需要认识，不会写也没关系，用vscode的<code>!</code>回车生成的HTML结构中自带了。</p><p>如果<strong>不写</strong>这个会怎么样呢？答案是<strong>网页的宽度和逻辑宽度不相等</strong>。</p><p>现在使用谷歌浏览器仿真设备，我使用iphoneSE逻辑宽度是<strong>375</strong>，如果不写该标签，则HTML宽度是<strong>980</strong>，而写了之后，HTML的宽度就和逻辑宽度一样了。</p></li><li><p>width&#x3D;device-width: 视口宽度 &#x3D; 设备宽度</p></li><li><p>initial-scale &#x3D; 1.0: 缩放1倍（不缩放）</p></li></ul><h2 id="二倍图"><a href="#二倍图" class="headerlink" title="二倍图"></a>二倍图</h2><h2 id="适配方案"><a href="#适配方案" class="headerlink" title="适配方案"></a>适配方案</h2><ul><li><p>宽度适配：宽度自适应</p><p>一般用在pc端，常见的有百分比（也叫流式布局）和flex布局，只能实现宽度自适应，高度固定。</p></li><li><p>等比适配：宽高等比缩放</p><ul><li>rem</li><li>vw</li></ul></li></ul><p>设计稿一般是750px（iPhone留下的传统）;</p><h2 id="rem布局"><a href="#rem布局" class="headerlink" title="rem布局"></a>rem布局</h2><h3 id="rem-单位"><a href="#rem-单位" class="headerlink" title="rem 单位"></a>rem 单位</h3><p><strong>rem</strong>是一个相对单位，<strong>1rem &#x3D; 1HTML字号大小</strong>，但是字号是不变的，所以我需要通过一些方法改变字号的大小，来实现等比适配。这个方法就是<strong>媒体查询</strong></p><h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><p><strong>媒体查询</strong>能够<strong>检测视口的宽度</strong>，然后<strong>编写差异化的CSS</strong>，当某个<strong>条件成立时</strong>，<strong>执行对应的CSS</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> (媒体特性)&#123;<br>    选择器 &#123;<br>        CSS属性<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在目前的rem布局中，HTML标签的字号为<strong>视口宽度的1&#x2F;10</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*视口宽度为320px时，根字号为32px*/</span><br><span class="hljs-keyword">@midia</span> (<span class="hljs-attribute">wdith</span>: <span class="hljs-number">320px</span>) &#123;<br>    <span class="hljs-selector-tag">html</span> &#123;<br>        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">32px</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是如果只使用<code>meida</code>，每适配一台设备，就需要人工多写一个<code>meida</code>，而且即使是一台设备也可以设置多种分辨率（120%，150%等），这样一台设备又得写许多个<code>media</code>。</p><p>所以在实际中，我们需要配合一个js</p><h3 id="flexible-js"><a href="#flexible-js" class="headerlink" title="flexible.js"></a>flexible.js</h3><p>这是手淘开发出的一个用来<strong>适配移动端</strong>的<strong>js库</strong>，核心原理就是根据<strong>不同的视口宽度</strong>给网页中<strong>HTML根节点</strong>设置<strong>不同的font-sze</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">/*导入js库*/<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./js/flexible.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里是GitHub链接<a href="https://github.com/amfe/lib-flexible">GitHub - amfe&#x2F;lib-flexible: 可伸缩布局方案</a></p><p>也可以直接复制源码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span> <span class="hljs-title function_">flexible</span> (<span class="hljs-variable language_">window</span>, <span class="hljs-variable language_">document</span>) &#123;<br>  <span class="hljs-keyword">var</span> docEl = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span><br>  <span class="hljs-keyword">var</span> dpr = <span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span> || <span class="hljs-number">1</span><br><br>  <span class="hljs-comment">// adjust body font size</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setBodyFontSize</span> () &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>) &#123;<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = (<span class="hljs-number">12</span> * dpr) + <span class="hljs-string">&#x27;px&#x27;</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, setBodyFontSize)<br>    &#125;<br>  &#125;<br>  <span class="hljs-title function_">setBodyFontSize</span>();<br><br>  <span class="hljs-comment">// set 1rem = viewWidth / 10</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setRemUnit</span> () &#123;<br>    <span class="hljs-keyword">var</span> rem = docEl.<span class="hljs-property">clientWidth</span> / <span class="hljs-number">10</span><br>    docEl.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = rem + <span class="hljs-string">&#x27;px&#x27;</span><br>  &#125;<br><br>  <span class="hljs-title function_">setRemUnit</span>()<br><br>  <span class="hljs-comment">// reset rem unit on page resize</span><br>  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, setRemUnit)<br>  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;pageshow&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-keyword">if</span> (e.<span class="hljs-property">persisted</span>) &#123;<br>      <span class="hljs-title function_">setRemUnit</span>()<br>    &#125;<br>  &#125;)<br><br>  <span class="hljs-comment">// detect 0.5px supports</span><br>  <span class="hljs-keyword">if</span> (dpr &gt;= <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">var</span> fakeBody = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;body&#x27;</span>)<br>    <span class="hljs-keyword">var</span> testElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>)<br>    testElement.<span class="hljs-property">style</span>.<span class="hljs-property">border</span> = <span class="hljs-string">&#x27;.5px solid transparent&#x27;</span><br>    fakeBody.<span class="hljs-title function_">appendChild</span>(testElement)<br>    docEl.<span class="hljs-title function_">appendChild</span>(fakeBody)<br>    <span class="hljs-keyword">if</span> (testElement.<span class="hljs-property">offsetHeight</span> === <span class="hljs-number">1</span>) &#123;<br>      docEl.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;hairlines&#x27;</span>)<br>    &#125;<br>    docEl.<span class="hljs-title function_">removeChild</span>(fakeBody)<br>  &#125;<br>&#125;(<span class="hljs-variable language_">window</span>, <span class="hljs-variable language_">document</span>))<br></code></pre></td></tr></table></figure><h2 id="LESS"><a href="#LESS" class="headerlink" title="LESS"></a>LESS</h2><h3 id="什么是less"><a href="#什么是less" class="headerlink" title="什么是less"></a>什么是less</h3><p>less是一个<strong>CSS预处理器</strong>，文件后缀是<code>.less</code>。扩充了CSS，使CSS具备一定的逻辑性、计算能力。</p><p>浏览器不识别less，目前需要用less转成css，网页引入对应的css文件。</p><p>可以用vscode插件<strong>Easy LESS</strong>，保存后自动生成对应的css文件。</p><p>另一种方法是使用<code>node.js</code>进行手动编译，命令行输入</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>安装工具<br>npm install -g less<br><br><span class="hljs-regexp">//</span>编译less文件（生成的文件名可自定义）<br>lessc index.less &gt; index.css<br></code></pre></td></tr></table></figure><h3 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h3><p>less的语法和css差不多，但是可以使用数值进行运算，结构也比css更有逻辑性</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.father</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>    <span class="hljs-attribute">width</span>: ( <span class="hljs-number">68</span> / <span class="hljs-number">37.5rem</span>);<br>    <span class="hljs-selector-class">.son</span> &#123;<br>        <span class="hljs-attribute">height</span>: (<span class="hljs-number">29</span> / <span class="hljs-number">37.5rem</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>相信学习过css的你一定看得懂上面的代码，上面的代码编译成css如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">1.81333333rem</span>;<br>&#125;<br><span class="hljs-selector-class">.father</span> <span class="hljs-selector-class">.son</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0.77333333rem</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>使用<code>//单行注释</code>和<code>/*块注释*/</code></p><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>加减乘除直接写运算就可以了，但是<strong>除法</strong>需要用<strong>小括号</strong>括起，或者使用<code>./</code></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100</span> + <span class="hljs-number">50px</span>;<br>    <span class="hljs-attribute">width</span>: (<span class="hljs-number">100</span>/<span class="hljs-number">50px</span>);<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100</span>./<span class="hljs-number">50px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过一般还是推荐使用<strong>小括号写法</strong></p><p>运算的<strong>单位</strong>一般写在<strong>最后</strong>，如果有<strong>多个单位</strong>，则<strong>只会</strong>以<strong>第一个单位</strong>为准</p><h3 id="less嵌套"><a href="#less嵌套" class="headerlink" title="less嵌套"></a>less嵌套</h3><p>less选择器可以<strong>嵌套</strong>，用来表示<strong>子代选择器</strong>，上面有代码了，这里不累述。</p><p>在less的嵌套中有一个<code>&amp;</code>符号，这个符号表示当前选择器，举个例子</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.father</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>    <span class="hljs-comment">//嵌套a标签</span><br>    <span class="hljs-selector-tag">a</span> &#123;<br>        <span class="hljs-attribute">color</span>: blue;<br>    &#125;<br>    <span class="hljs-comment">//同时设置a标签的悬停状态</span><br>    <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>        <span class="hljs-attribute">color</span>: green;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译出的css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.father</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-selector-class">.father</span> <span class="hljs-selector-tag">a</span> &#123;<br>    <span class="hljs-attribute">color</span>: blue;<br>&#125;<br><span class="hljs-selector-class">.father</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">color</span>: orange;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种写法没什么问题，但是在less中显得累赘，本来都是设置给a的样式却要分开写，这时候就可以使用<code>&amp;</code>符号</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.father</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>    <span class="hljs-comment">//嵌套a标签</span><br>    <span class="hljs-selector-tag">a</span> &#123;<br>        <span class="hljs-attribute">color</span>: blue;<br>        <span class="hljs-comment">//使用&amp;符号,&amp;表示本身</span><br>        <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>            <span class="hljs-attribute">color</span>: orange;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样生成的css和上面的是一样的。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><strong>定义变量：</strong> <code>@变量名:数据;</code></p><p><strong>使用变量：</strong> <code>CSS属性: @变量名;</code></p><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p><strong>作用：</strong>用来导入less公共样式文件</p><p><strong>语法：</strong><code>@import &quot;文件路径&quot;;</code>，如果是less文件可以省略后缀</p><p>为什么要这样写呢？一个页面可能有不止一个css&#x2F;less文件，我们可以一个个导入，也可以使用less导入后编译成一个css文件，再进行导入。</p><h3 id="导出与禁止导出"><a href="#导出与禁止导出" class="headerlink" title="导出与禁止导出"></a>导出与禁止导出</h3><p><strong>注意：以下内容仅使用于easy less插件，而非less本身语法</strong></p><ul><li><p>导出</p><p><strong>作用：</strong>设置导出的css文件名和路劲</p><p><strong>语法：</strong>在文件开头<code>//out: URL</code>，注意，如果只写到目标文件夹，需要在结尾加<code>/</code></p></li><li><p>禁止导出</p><p><strong>作用：</strong>在less文件保存的时候不生成css</p><p><strong>语法：</strong>第一行添加<code>//out: false</code></p></li></ul><h2 id="vw布局"><a href="#vw布局" class="headerlink" title="vw布局"></a>vw布局</h2><h2 id="vw和vh"><a href="#vw和vh" class="headerlink" title="vw和vh"></a>vw和vh</h2><p>vw和vh是一个相对单位，1vw &#x3D; 视口宽度的百分之一，vh同理。</p><p>在实际开发中，我们拿到设计稿之后，需要知道该设计稿面向的视口宽度&#x2F;高度是多少，然后<strong>将元素大小除以一个vw</strong>，这样对才能适应不同的屏幕。假设视口宽度是375px，设计稿其中一个元素的宽度是10px，那么我们在制作网页时，这个元素的宽度应该写为<code>(10/3.75)vw</code>。因为1vm&#x3D;1&#x2F;100视口宽度，而现在视口宽度是375px，1个vw也就是3.75px。所以，10px在375px宽的屏幕里，占了（10&#x2F;3.75）个vw。</p><p>而在less中我们可以写为<code>width:(10/3.75vw)</code>，也可以<strong>用变量将3.75vw存储起来（推荐）</strong>，写为<code>@vm:3.75vw</code>，然后设置元素宽度<code>width:(10/@vw)</code></p><p>这样就实现了对不同屏幕大小的适配。</p><h2 id="vw、vh混用问题"><a href="#vw、vh混用问题" class="headerlink" title="vw、vh混用问题"></a>vw、vh混用问题</h2><p>vw和vh一般在开发中只会使用一个，不能混用，如果混用可能导致<strong>盒子变形</strong></p><h1 id="响应式网页"><a href="#响应式网页" class="headerlink" title="响应式网页"></a>响应式网页</h1><h2 id="什么响应式网页"><a href="#什么响应式网页" class="headerlink" title="什么响应式网页"></a>什么响应式网页</h2><p><strong>用一套代码适配不同的设备</strong>，需要根据不同的设备修改盒子的布局。</p><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>常用的实现方法有两种，<strong>媒体查询</strong>和<strong>bootstrap框架</strong></p><h2 id="媒体查询-1"><a href="#媒体查询-1" class="headerlink" title="媒体查询"></a>媒体查询</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>媒体查询的语法我们上面有讲过一点</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> (媒体特性) &#123;<br>选择器 &#123;<br>样式<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是之前我们写的条件是<code>width:123px</code>这种当宽度相等触发的，但是响应式布局是不同区间有不同的布局，那么要如何实现呢？</p><h3 id="max-width-min-width"><a href="#max-width-min-width" class="headerlink" title="max-width,min-width"></a>max-width,min-width</h3><p>需要用到两个属性：<code>max-width</code>、<code>min-width</code>，最大宽度和最小宽度。一般<strong>只用一个</strong>，也可以两个表示区间都写（嵌套写法，不推荐使用，只提供一个想法）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*小于等于768px*/</span><br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">768px</span>) &#123;<br>    <span class="hljs-selector-tag">body</span> &#123;<br>        <span class="hljs-attribute">background-color</span>: red;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*大于等于1200px*/</span><br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">1200px</span>) &#123;<br>    <span class="hljs-selector-tag">body</span> &#123;<br>        <span class="hljs-attribute">background-color</span>: green;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*1500到2000之间*/</span><br><span class="hljs-comment">/*不推荐*/</span><br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">2000px</span>) &#123;<br>    <span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">1500px</span>) &#123;<br>        <span class="hljs-selector-tag">body</span> &#123;<br>            <span class="hljs-attribute">background-color</span>: red;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于第三种写法有更好的解决方法，因为css是会覆盖的，假设我先写了<code>&gt;=100px</code>的样式，下面再写<code>&gt;=200px</code>的样式，下面的代码是会将上面的覆盖的，所以<code>&gt;=100px</code>的样式其实只会在<code>100到200</code>区间生效。</p><p>所以书写顺序很重要，一定注意<code>max-width</code>和<code>min-width</code>的书写顺序是反过来的。</p><h3 id="媒体查询-完整写法"><a href="#媒体查询-完整写法" class="headerlink" title="媒体查询-完整写法"></a>媒体查询-完整写法</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> 逻辑操作符 媒体类型 <span class="hljs-keyword">and</span> (媒体特性) &#123;CSS代码&#125;<br></code></pre></td></tr></table></figure><ul><li><p>逻辑操作符：<code>and</code>、<code>only</code>、<code>not</code></p></li><li><p>媒体类型：<strong>用来区分设备类型的</strong>，屏幕设备、打印设备等（手机电脑平板都属于屏幕设备）</p><table><thead><tr><th>类型</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>屏幕</td><td>screen</td><td>带屏幕的设别</td></tr><tr><td>打印预览</td><td>print</td><td>打印预览设备</td></tr><tr><td>阅读器</td><td>speech</td><td>屏幕阅读模式</td></tr><tr><td>不区分类型</td><td>all</td><td>默认值，包括以上三种类型</td></tr></tbody></table></li><li><p>媒体类型：主要用来<strong>描述媒体类型的具体特征</strong>，如屏幕宽高等</p><p>​</p><table><thead><tr><th>特性</th><th>属性</th><th>值</th></tr></thead><tbody><tr><td>视口的宽高</td><td>width,height</td><td>数值</td></tr><tr><td>视口最大宽高</td><td>max-width,max-height</td><td>数值</td></tr><tr><td>视口最小</td><td>min-width,min-height</td><td>数值</td></tr><tr><td>屏幕方向</td><td>orientation</td><td>portrait:竖屏，landscape:横屏</td></tr></tbody></table></li></ul><h3 id="搭配单文件css"><a href="#搭配单文件css" class="headerlink" title="搭配单文件css"></a>搭配单文件css</h3><p>媒体查询是可以搭配单独的CSS文件使用的，实现也很简单。<strong>当我们用<code>link</code>引用css文件的时候，设置media即可</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;link red=&quot;stylesheet&quot; media=&quot;逻辑符 媒体类型 and（媒体特性）&quot; href=&quot;xx<span class="hljs-selector-class">.css</span>&quot;&gt;<br></code></pre></td></tr></table></figure><h2 id="bootstrap框架"><a href="#bootstrap框架" class="headerlink" title="bootstrap框架"></a>bootstrap框架</h2><p>是推特开发的开源工具包，详细了解请自行百度。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>CSS</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
